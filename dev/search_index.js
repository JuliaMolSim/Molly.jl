var documenterSearchIndex = {"docs":
[{"location":"api/#Molly-API","page":"API","title":"Molly API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The API reference can be found here.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Molly also re-exports StaticArrays.jl, Unitful.jl and AtomsBase.jl, making the likes of SVector and 1.0u\"nm\" available when you call using Molly.","category":"page"},{"location":"api/","page":"API","title":"API","text":"The visualize function is only available once you have called using GLMakie. Requires.jl is used to lazily load this code when GLMakie.jl is available, which reduces the dependencies of the package.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Order   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Molly]\nPrivate = false\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"api/#Molly.AbstractGBSA","page":"API","title":"Molly.AbstractGBSA","text":"Generalized Born (GB) implicit solvent models augmented with the hydrophobic solvent accessible surface area (SA) term. Custom GBSA methods should sub-type this type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.AbstractNeighborFinder","page":"API","title":"Molly.AbstractNeighborFinder","text":"A way to find near atoms to save on simulation time. Custom neighbor finders should sub-type this type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.AndersenThermostat","page":"API","title":"Molly.AndersenThermostat","text":"AndersenThermostat(temperature, coupling_const)\n\nRescale random velocities according to the Andersen thermostat.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.Atom","page":"API","title":"Molly.Atom","text":"Atom(; <keyword arguments>)\n\nAn atom and its associated information. Properties unused in the simulation or in analysis can be left with their default values. The types used should be bits types if the GPU is going to be used.\n\nArguments\n\nindex::Int: the index of the atom in the system.\ncharge::C=0.0: the charge of the atom, used for electrostatic interactions.\nmass::M=0.0u\"u\": the mass of the atom.\n::S=0.0u\"nm\": the Lennard-Jones finite distance at which the inter-particle   potential is zero.\n系::E=0.0u\"kJ * mol^-1\": the Lennard-Jones depth of the potential well.\nsolute::Bool=false: whether the atom is part of the solute.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.AtomData","page":"API","title":"Molly.AtomData","text":"AtomData(atom_type, atom_name, res_number, res_name)\n\nData associated with an atom. Storing this separately allows the atom types to be bits types and hence work on the GPU.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.BerendsenThermostat","page":"API","title":"Molly.BerendsenThermostat","text":"BerendsenThermostat(temperature, coupling_const)\n\nThe Berendsen thermostat. This thermostat should not be used in general as it can lead to simulation artifacts.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.CellListMapNeighborFinder","page":"API","title":"Molly.CellListMapNeighborFinder","text":"CellListMapNeighborFinder(; nb_matrix, matrix_14, n_steps, dist_cutoff, x0, unit_cell)\n\nFind close atoms by distance, and store auxiliary arrays for in-place threading. x0 and unit_cell  are optional initial coordinates and system unit cell that improve the first approximation of the cell list structure. The unit cell can be provided as a three-component vector of box sides on each direction, in which case the unit cell is considered OrthorhombicCell, or as a unit cell matrix, in which case the cell is considered a general TriclinicCell by the cell list algorithm.\n\nExample\n\njulia> coords\n15954-element Vector{SVector{3, Quantity{Float64, , Unitful.FreeUnits{(nm,), , nothing}}}}:\n [2.5193063341012127 nm, 3.907448346081021 nm, 4.694954671434135 nm]\n [2.4173958848835233 nm, 3.916034913604175 nm, 4.699661024574953 nm]\n \n [1.818842280373283 nm, 5.592152965227421 nm, 4.992100424805031 nm]\n [1.7261366568663976 nm, 5.610326185704369 nm, 5.084523386833478 nm]\n\njulia> box_size\n3-element SVector{3, Quantity{Float64, , Unitful.FreeUnits{(nm,), , nothing}}} with indices SOneTo(3):\n              5.676 nm\n             5.6627 nm\n             6.2963 nm\n\njulia> neighbor_finder = CellListMapNeighborFinder(\n           nb_matrix=s.neighbor_finder.nb_matrix, matrix_14=s.neighbor_finder.matrix_14, \n           n_steps=10, dist_cutoff=1.2u\"nm\",\n           x0 = coords, unit_cell = box_size\n       )\nCellListMapNeighborFinder{Quantity{Float64, , Unitful.FreeUnits{(nm,), , nothing}}, 3, Float64}\n  Size of nb_matrix = (15954, 15954)\n  n_steps = 10\n  dist_cutoff = 1.2 nm\n\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.CoordinateLogger","page":"API","title":"Molly.CoordinateLogger","text":"CoordinateLogger(n_steps; dims=3)\n\nLog the coordinates throughout a simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.Coulomb","page":"API","title":"Molly.Coulomb","text":"Coulomb(; cutoff, nl_only, weight_14, coulomb_const, force_units, energy_units)\n\nThe Coulomb electrostatic interaction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.CoulombReactionField","page":"API","title":"Molly.CoulombReactionField","text":"CoulombReactionField(; dist_cutoff, solvent_dielectric, nl_only, weight_14,\n                        coulomb_const, force_units, energy_units)\n\nThe Coulomb electrostatic interaction modified using the reaction field approximation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.DistanceCutoff","page":"API","title":"Molly.DistanceCutoff","text":"DistanceCutoff(dist_cutoff)\n\nCutoff that sets the potential and force to be zero past a specified cutoff point.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.DistanceNeighborFinder","page":"API","title":"Molly.DistanceNeighborFinder","text":"DistanceNeighborFinder(; nb_matrix, matrix_14, n_steps, dist_cutoff)\n\nFind close atoms by distance.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.DistanceVecNeighborFinder","page":"API","title":"Molly.DistanceVecNeighborFinder","text":"DistanceVecNeighborFinder(; nb_matrix, matrix_14, n_steps, dist_cutoff)\n\nFind close atoms by distance in a GPU and differentiable safe manner.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.Gravity","page":"API","title":"Molly.Gravity","text":"Gravity(; G, nl_only)\n\nThe gravitational interaction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.HarmonicAngle","page":"API","title":"Molly.HarmonicAngle","text":"HarmonicAngle(; th0, cth)\n\nA harmonic bond angle between three atoms.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.HarmonicBond","page":"API","title":"Molly.HarmonicBond","text":"HarmonicBond(; b0, kb)\n\nA harmonic bond between two atoms.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.ImplicitSolventOBC","page":"API","title":"Molly.ImplicitSolventOBC","text":"ImplicitSolventOBC(atoms, atoms_data, bonds)\n\nOnufriev-Bashford-Case GBSA model. Should be used along with a Coulomb or CoulombReactionField interaction. The keyword argument use_OBC2 determines whether to use parameter set I (false, the default) or II (true).\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.Interaction","page":"API","title":"Molly.Interaction","text":"An interaction between atoms that contributes to forces on the atoms.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.InteractionList2Atoms","page":"API","title":"Molly.InteractionList2Atoms","text":"InteractionList2Atoms(is, js, types, inters)\nInteractionList2Atoms(inter_type)\n\nA list of specific interactions between two atoms.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.InteractionList3Atoms","page":"API","title":"Molly.InteractionList3Atoms","text":"InteractionList3Atoms(is, js, ks, types, inters)\nInteractionList3Atoms(inter_type)\n\nA list of specific interactions between three atoms.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.InteractionList4Atoms","page":"API","title":"Molly.InteractionList4Atoms","text":"InteractionList4Atoms(is, js, ks, ls, types, inters)\nInteractionList4Atoms(inter_type)\n\nA list of specific interactions between four atoms.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.KineticEnergyLogger","page":"API","title":"Molly.KineticEnergyLogger","text":"KineticEnergyLogger(n_steps)\n\nLog the kinetic energy of the system throughout a simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.LennardJones","page":"API","title":"Molly.LennardJones","text":"LennardJones(; cutoff, nl_only, lorentz_mixing, weight_14, weight_solute_solvent,\n             force_units, energy_units, skip_shortcut)\n\nThe Lennard-Jones 6-12 interaction. The potential is given by\n\nV_ij(r_ij) = 4varepsilon_ij leftleft(fracsigma_ijr_ijright)^12 - left(fracsigma_ijr_ijright)^6right\n\nand the force on each atom by\n\nbeginaligned\nvecF_i = 24varepsilon_ij left(2fracsigma_ij^12r_ij^13 - fracsigma_ij^6r_ij^7right) fracvecr_ijr_ij \n= frac24varepsilon_ijr_ij^2 left2left(fracsigma_ij^6r_ij^6right)^2 -left(fracsigma_ijr_ijright)^6right vecr_ij\nendaligned\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.Mie","page":"API","title":"Molly.Mie","text":"Mie(; m, n, cutoff, nl_only, lorentz_mixing, force_units, energy_units, skip_shortcut)\n\nThe Mie generalized interaction. When m equals 6 and n equals 12 this is equivalent to the Lennard-Jones interaction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.NeighborList","page":"API","title":"Molly.NeighborList","text":"NeighborList()\nNeighborList(n, list)\n\nStructure to contain pre-allocated neighbor lists.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.NeighborListVec","page":"API","title":"Molly.NeighborListVec","text":"NeighborListVec(n, list)\n\nStructure to contain neighbor lists for broadcasting.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.NoCoupling","page":"API","title":"Molly.NoCoupling","text":"NoCoupling()\n\nPlaceholder coupler that does nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.NoCutoff","page":"API","title":"Molly.NoCutoff","text":"NoCutoff()\n\nPlaceholder cutoff that does not alter forces or potentials.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.NoNeighborFinder","page":"API","title":"Molly.NoNeighborFinder","text":"NoNeighborFinder()\n\nPlaceholder neighbor finder that returns no neighbors. When using this neighbor finder, ensure that nl_only for the interactions is set to false.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.OpenMMAtomType","page":"API","title":"Molly.OpenMMAtomType","text":"OpenMMAtomType(class, element, mass, , 系)\n\nAn OpenMM atom type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.OpenMMForceField","page":"API","title":"Molly.OpenMMForceField","text":"OpenMMForceField(ff_files...)\nOpenMMForceField(T, ff_files...)\nOpenMMForceField(atom_types, residue_types, bond_types, angle_types,\n                    torsion_types, torsion_order, weight_14_coulomb,\n                    weight_14_lj)\n\nAn OpenMM force field. Read one or more OpenMM force field XML files by passing them to the constructor.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.PairwiseInteraction","page":"API","title":"Molly.PairwiseInteraction","text":"A pairwise interaction that will apply to all or most atom pairs. Custom pairwise interactions should sub-type this type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.PeriodicTorsion","page":"API","title":"Molly.PeriodicTorsion","text":"PeriodicTorsion(; periodicities, phases, ks, proper)\n\nA periodic torsion angle between four atoms.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.PeriodicTorsionType","page":"API","title":"Molly.PeriodicTorsionType","text":"PeriodicTorsionType(periodicities, phases, ks, proper)\n\nA periodic torsion type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.PotentialEnergyLogger","page":"API","title":"Molly.PotentialEnergyLogger","text":"PotentialEnergyLogger(n_steps)\n\nLog the potential energy of the system throughout a simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.RBTorsion","page":"API","title":"Molly.RBTorsion","text":"RBTorsion(; f1, f2, f3, f4)\n\nA Ryckaert-Bellemans torsion angle between four atoms.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.RescaleThermostat","page":"API","title":"Molly.RescaleThermostat","text":"RescaleThermostat(temperature)\n\nThe velocity rescaling thermostat. This thermostat should not be used in general as it can lead to simulation artifacts.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.ShiftedForceCutoff","page":"API","title":"Molly.ShiftedForceCutoff","text":"ShiftedForceCutoff(dist_cutoff)\n\nCutoff that shifts the force to be continuous at a specified cutoff point.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.ShiftedPotentialCutoff","page":"API","title":"Molly.ShiftedPotentialCutoff","text":"ShiftedPotentialCutoff(dist_cutoff)\n\nCutoff that shifts the potential to be continuous at a specified cutoff point.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.SoftSphere","page":"API","title":"Molly.SoftSphere","text":"SoftSphere(; cutoff, nl_only, lorentz_mixing, force_units, energy_units, skip_shortcut)\n\nThe soft-sphere potential.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.SpecificForce2Atoms","page":"API","title":"Molly.SpecificForce2Atoms","text":"SpecificForce2Atoms(f1, f2)\n\nForces on two atoms arising from an interaction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.SpecificForce3Atoms","page":"API","title":"Molly.SpecificForce3Atoms","text":"SpecificForce3Atoms(f1, f2, f3)\n\nForces on three atoms arising from an interaction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.SpecificForce4Atoms","page":"API","title":"Molly.SpecificForce4Atoms","text":"SpecificForce4Atoms(f1, f2, f3, f4)\n\nForces on four atoms arising from an interaction.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.SpecificInteraction","page":"API","title":"Molly.SpecificInteraction","text":"A specific interaction between sets of specific atoms, e.g. a bond angle. Custom specific interactions should sub-type this type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.StormerVerlet","page":"API","title":"Molly.StormerVerlet","text":"StormerVerlet(; <keyword arguments>)\n\nThe St枚rmer-Verlet integrator. In this case the velocities given to the simulator act as the previous step coordinates for the first step. Does not currently work with units or thermostats.\n\nArguments\n\ndt::T: the time step of the simulation.\ncoupling::C=NoCoupling(): the coupling which applies during the simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.StructureWriter","page":"API","title":"Molly.StructureWriter","text":"StructureWriter(n_steps, filepath, excluded_res=String[])\n\nWrite 3D output structures to the PDB file format throughout a simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.System","page":"API","title":"Molly.System","text":"System(; <keyword arguments>)\n\nA physical system to be simulated. Properties unused in the simulation or in analysis can be left with their default values. atoms, atoms_data, coords and velocities should have the same length. This is a sub-type of AbstractSystem from AtomsBase.jl and implements the interface described there.\n\nArguments\n\natoms::A: the atoms, or atom equivalents, in the system. Can be   of any type but should be a bits type if the GPU is used.\natoms_data::AD: other data associated with the atoms, allowing the atoms to   be bits types and hence work on the GPU.\npairwise_inters::PI=(): the pairwise interactions in the system, i.e.   interactions between all or most atom pairs such as electrostatics.   Typically a Tuple.\nspecific_inter_lists::SI=(): the specific interactions in the system,   i.e. interactions between specific atoms such as bonds or angles. Typically   a Tuple.\ngeneral_inters::GI=(): the general interactions in the system,   i.e. interactions involving all atoms such as implicit solvent. Typically   a Tuple.\ncoords::C: the coordinates of the atoms in the system. Typically a   vector of SVectors of 2 or 3 dimensions.\nvelocities::V=zero(coords): the velocities of the atoms in the system.\nbox_size::B: the size of the box in which the simulation takes place.   Typically a SVector of 2 or 3 dimensions.\nneighbor_finder::NF=NoNeighborFinder(): the neighbor finder used to find   close atoms and save on computation.\nloggers::L=Dict(): the loggers that record properties of interest during a   simulation.\nforce_units::F=u\"kJ * mol^-1 * nm^-1\": the units of force of the system.\nenergy_units::E=u\"kJ * mol^-1\": the units of energy of the system.\ngpu_diff_safe::Bool: whether to use the code path suitable for the   GPU and taking gradients. Defaults to isa(coords, CuArray).\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.System-Tuple{AbstractString, OpenMMForceField}","page":"API","title":"Molly.System","text":"System(coordinate_file, force_field; <keyword arguments>)\n\nRead a coordinate file in a file format readable by Chemfiles and apply a force field to it.\n\nSystem(coordinate_file, topology_file; <keyword arguments>)\nSystem(T, coordinate_file, topology_file; <keyword arguments>)\n\nRead a Gromacs coordinate file and a Gromacs topology file with all includes collapsed into one file.\n\nArguments\n\nvelocities=nothing: the velocities of the atoms in the system, set to   zero by default.\nbox_size=nothing: the size of the cubic box used for simulation, read   from the file by default.\nloggers=Dict(): the loggers that record properties of interest during a   simulation.\nunits::Bool=true: whether to use Unitful quantities.\ngpu::Bool=false: whether to move the relevant parts of the system onto   the GPU.\ngpu_diff_safe::Bool: whether to use the code path suitable for the   GPU and taking gradients, defaults to the value of gpu.\ndist_cutoff=1.0u\"nm\": cutoff distance for long-range interactions.\nnl_dist=1.2u\"nm\": cutoff distance for neighbor list, should not be less   than dist_cutoff.\nimplicit_solvent=nothing: specify a string to add an implicit solvent   model, options are \"obc1\" or \"obc2\".\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.TemperatureLogger","page":"API","title":"Molly.TemperatureLogger","text":"TemperatureLogger(n_steps)\nTemperatureLogger(T, n_steps)\n\nLog the temperature throughout a simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.TotalEnergyLogger","page":"API","title":"Molly.TotalEnergyLogger","text":"TotalEnergyLogger(n_steps)\n\nLog the total energy of the system throughout a simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.TreeNeighborFinder","page":"API","title":"Molly.TreeNeighborFinder","text":"TreeNeighborFinder(; nb_matrix, matrix_14, n_steps, dist_cutoff)\n\nFind close atoms by distance using a tree search.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.VelocityLogger","page":"API","title":"Molly.VelocityLogger","text":"VelocityLogger(n_steps; dims=3)\n\nLog the velocities throughout a simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.VelocityVerlet","page":"API","title":"Molly.VelocityVerlet","text":"VelocityVerlet(; <keyword arguments>)\n\nThe velocity Verlet integrator.\n\nArguments\n\ndt::T: the time step of the simulation.\ncoupling::C=NoCoupling(): the coupling which applies during the simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#AtomsBase.velocity-Tuple{Any, Any}","page":"API","title":"AtomsBase.velocity","text":"velocity(mass, temperature; dims=3)\n\nGenerate a random velocity from the Maxwell-Boltzmann distribution.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.accelerations","page":"API","title":"Molly.accelerations","text":"accelerations(system, neighbors=nothing; parallel=true)\n\nCalculate the accelerations of all atoms using the pairwise and specific interactions and Newton's second law. If the interactions use neighbor lists, the neighbors should be computed first and passed to the function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.apply_coupling!-Tuple{System, Any, NoCoupling}","page":"API","title":"Molly.apply_coupling!","text":"apply_coupling!(system, simulator, coupling)\n\nApply a coupler to modify a simulation. Custom couplers should implement this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.bond_angle-NTuple{4, Any}","page":"API","title":"Molly.bond_angle","text":"bond_angle(coord_i, coord_j, coord_k, box_size)\nbond_angle(vec_ba, vec_bc)\n\nCalculate the bond or pseudo-bond angle in radians between three coordinates or two vectors. The angle between BA and BC is returned in the range 0 to .\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.born_radii_and_grad-Tuple{ImplicitSolventOBC, Any, Any}","page":"API","title":"Molly.born_radii_and_grad","text":"born_radii_and_grad(inter, coords, box_size)\n\nCalculate Born radii and gradients of Born radii with respect to atomic distance. Custom GBSA methods should implement this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.charge-Tuple{Atom}","page":"API","title":"Molly.charge","text":"charge(atom)\n\nThe partial charge of an atom.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.displacements-Tuple{Any, Any}","page":"API","title":"Molly.displacements","text":"displacements(coords, box_size)\n\nGet the pairwise vector displacements of a set of coordinates, accounting for the periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.distances-Tuple{Any, Any}","page":"API","title":"Molly.distances","text":"distances(coords, box_size)\n\nGet the pairwise distances of a set of coordinates, accounting for the periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.extract_parameters-Tuple{System, OpenMMForceField}","page":"API","title":"Molly.extract_parameters","text":"extract_parameters(system, force_field)\n\nForm a Dict of all parameters in a System, allowing gradients to be tracked.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.find_neighbors","page":"API","title":"Molly.find_neighbors","text":"find_neighbors(s::System,\n                nf::CellListMapNeighborFinder,\n                current_neighbors=nothing,\n                step_n::Integer=0;\n                parallel::Bool=true)\n\nFind neighbors using CellListMap, without in-place updating. Should be called only the first time the cell lists are built. Modifies the mutable nf structure.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.find_neighbors-Tuple{System}","page":"API","title":"Molly.find_neighbors","text":"find_neighbors(system, neighbor_finder, current_neighbors=nothing,\n                step_n=0; parallel=true)\nfind_neighbors(system; parallel=true)\n\nObtain a list of close atoms in a system. Custom neighbor finders should implement this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.float_type-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}","page":"API","title":"Molly.float_type","text":"float_type(sys)\n\nThe float type a System uses.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.force","page":"API","title":"Molly.force","text":"force(inter::PairwiseInteraction, vec_ij, coord_i, coord_j,\n      atom_i, atom_j, box_size)\nforce(inter::SpecificInteraction, coord_i, coord_j,\n      box_size)\nforce(inter::SpecificInteraction, coord_i, coord_j,\n      coord_k, box_size)\nforce(inter::SpecificInteraction, coord_i, coord_j,\n      coord_k, coord_l, box_size)\n\nCalculate the force between atoms due to a given interation type. For PairwiseInteractions returns a single force vector and for SpecificInteractions returns a type such as SpecificForce2Atoms. Custom pairwise and specific interaction types should implement this function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.forces","page":"API","title":"Molly.forces","text":"forces(system, neighbors=nothing; parallel=true)\nforces(system, coords, atoms, neighbors=nothing, neighbors_all=nothing)\n\nCalculate the forces on all atoms in the system. If the interactions use neighbor lists, the neighbors should be computed first and passed to the function.\n\nforces(inter, system, neighbors=nothing)\n\nCalculate the forces on all atoms in the system arising from a general interaction. If the interaction uses neighbor lists, the neighbors should be computed first and passed to the function. Custom general interaction types should implement this function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.inject_gradients","page":"API","title":"Molly.inject_gradients","text":"inject_gradients(sys, params_dic)\n\nAdd parameters from a dictionary to a System. Allows gradients for individual parameters to be tracked. Returns atoms, pairwise interactions and specific interaction lists.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.is_gpu_diff_safe-Union{Tuple{System{D, G}}, Tuple{G}, Tuple{D}} where {D, G}","page":"API","title":"Molly.is_gpu_diff_safe","text":"is_gpu_diff_safe(sys)\n\nWhether a System uses the code path suitable for the GPU and     for taking gradients.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.kinetic_energy-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}","page":"API","title":"Molly.kinetic_energy","text":"kinetic_energy(s)\n\nCompute the kinetic energy of the system.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.log_property!","page":"API","title":"Molly.log_property!","text":"log_property!(logger, system, neighbors=nothing, step_n=0)\n\nLog a property of the system thoughout a simulation. Custom loggers should implement this function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.mass-Tuple{Atom}","page":"API","title":"Molly.mass","text":"mass(atom)\n\nThe mass of an atom.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.maxwell_boltzmann-Tuple{Any, Any}","page":"API","title":"Molly.maxwell_boltzmann","text":"maxwell_boltzmann(mass, temperature)\n\nGenerate a random speed along one dimension from the Maxwell-Boltzmann distribution.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.place_atoms-Tuple{Integer, Any, Any}","page":"API","title":"Molly.place_atoms","text":"place_atoms(n_atoms, box_size, min_dist)\n\nObtain n_atoms 3D coordinates in a box with sides box_size where no two points are closer than min_dist, accounting for periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.place_diatomics-Tuple{Integer, Any, Any, Any}","page":"API","title":"Molly.place_diatomics","text":"place_diatomics(n_molecules, box_size, min_dist, bond_length)\n\nObtain 3D coordinates for n_molecules diatomics in a box with sides box_size where no two points are closer than min_dist and the bond length is bond_length, accounting for periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.potential_energy-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}, Tuple{System{D, G, T}, Any}} where {D, G, T}","page":"API","title":"Molly.potential_energy","text":"potential_energy(s, neighbors=nothing)\n\nCompute the potential energy of the system. If the interactions use neighbor lists, the neighbors should be computed first and passed to the function.\n\npotential_energy(inter::PairwiseInteraction, vec_ij, coord_i, coord_j,\n                 atom_i, atom_j, box_size)\npotential_energy(inter::SpecificInteraction, coords_i, coords_j,\n                 box_size)\npotential_energy(inter::SpecificInteraction, coords_i, coords_j,\n                 coords_k, box_size)\npotential_energy(inter::SpecificInteraction, coords_i, coords_j,\n                 coords_k, coords_l, box_size)\npotential_energy(inter, system, neighbors=nothing)\n\nCalculate the potential energy due to a given interation type. Custom interaction types should implement this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.random_velocities!-Tuple{System, Any}","page":"API","title":"Molly.random_velocities!","text":"random_velocities!(sys, temp)\n\nSet the velocities of a System to random velocities generated from the Maxwell-Boltzmann distribution.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.random_velocities-Union{Tuple{D}, Tuple{System{D}, Any}} where D","page":"API","title":"Molly.random_velocities","text":"random_velocities(sys, temp)\n\nGenerate random velocities from the Maxwell-Boltzmann distribution for a System.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.rdf-Tuple{Any, Any}","page":"API","title":"Molly.rdf","text":"rdf(coords, box_size; npoints=200)\n\nGet the radial distribution function of a set of coordinates. This describes how density varies as a function of distance from each atom. Returns a list of distance bin centres and a list of the corresponding densities.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.run_loggers!","page":"API","title":"Molly.run_loggers!","text":"run_loggers!(system, neighbors=nothing, step_n=0)\n\nRun the loggers associated with the system.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.simulate!-Union{Tuple{S}, Tuple{D}, Tuple{System{D, false}, VelocityVerlet, Integer}} where {D, S}","page":"API","title":"Molly.simulate!","text":"simulate!(system, simulator, n_steps; parallel=true)\nsimulate!(system, simulator; parallel=true)\n\nRun a simulation on a system according to the rules of the given simulator. Custom simulators should implement this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.temperature-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}","page":"API","title":"Molly.temperature","text":"temperature(system)\n\nCalculate the temperature of a system from the kinetic energy of the atoms.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.torsion_angle-NTuple{5, Any}","page":"API","title":"Molly.torsion_angle","text":"torsion_angle(coord_i, coord_j, coord_k, coord_l, box_size)\ntorsion_angle(vec_ab, vec_bc, vec_cd)\n\nCalculate the torsion angle in radians defined by four coordinates or three vectors. The angle between the planes defined by atoms (i, j, k) and (j, k, l) is returned in the range - to .\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.total_energy","page":"API","title":"Molly.total_energy","text":"total_energy(s, neighbors=nothing)\n\nCompute the total energy of the system. If the interactions use neighbor lists, the neighbors should be computed first and passed to the function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.ustrip_vec-Tuple{Any}","page":"API","title":"Molly.ustrip_vec","text":"ustrip_vec(x)\n\nBroadcasted form of ustrip from Unitful.jl, allowing e.g. ustrip_vec.(coords).\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.vector-Tuple{Any, Any, Any}","page":"API","title":"Molly.vector","text":"vector(c1, c2, box_size)\n\nDisplacement between two coordinate values from c1 to c2, accounting for the bounding box. The minimum image convention is used, so the displacement is to the closest version of the coordinates accounting for the periodic boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.vector1D-Tuple{Any, Any, Any}","page":"API","title":"Molly.vector1D","text":"vector1D(c1, c2, side_length)\n\nDisplacement between two 1D coordinate values from c1 to c2, accounting for the bounding box. The minimum image convention is used, so the displacement is to the closest version of the coordinate accounting for the periodic boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.velocity_autocorr","page":"API","title":"Molly.velocity_autocorr","text":"velocity_autocorr(vl, first_ind, last_ind)\n\nCalculates the autocorrelation function of velocity from the velocity logger.  This helps characterize the similarity between velocities observed at different time instances.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.visualize","page":"API","title":"Molly.visualize","text":"visualize(coord_logger, box_size, out_filepath; <keyword arguments>)\n\nVisualize a simulation as an animation. This function is only available when GLMakie is imported. GLMakie v0.5 or later should be used. It can take a while to run, depending on the length and size of the simulation.\n\nArguments\n\nconnections=Tuple{Int, Int}[]: pairs of atoms indices to link with bonds.\nconnection_frames: the frames in which bonds are shown. Is a list of the   same length as the number of frames, where each item is a list of Bools of   the same length as connections. Defaults to always true.\ntrails::Integer=0: the number of preceding frames to show as transparent   trails.\nframerate::Integer=30: the frame rate of the animation.\ncolor=:purple: the color of the atoms. Can be a single color or a list of   colors of the same length as the number of atoms.\nconnection_color=:orange: the color of the bonds. Can be a single color or a   list of colors of the same length as connections.\nmarkersize=0.05: the size of the atom markers, in the units of the data.\nlinewidth=2.0: the width of the bond lines.\ntransparency=true: whether transparency is active on the plot.\nkwargs...: other keyword arguments are passed to the point plotting   function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.wrap_coords-Tuple{Any, Any}","page":"API","title":"Molly.wrap_coords","text":"wrap_coords(c, side_length)\n\nEnsure a 1D coordinate is within the simulation box and return the coordinate.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.wrap_coords_vec-Tuple{Any, Any}","page":"API","title":"Molly.wrap_coords_vec","text":"wrap_coords_vec(c, box_size)\n\nEnsure a coordinate is within the simulation box and return the coordinate.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Molly-examples","page":"Examples","title":"Molly examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The best examples for learning how the package works are in the Molly documentation section. Here we give further examples, showing what you can do with the package. Each is a self-contained block of code. Made something cool yourself? Make a PR to add it to this page.","category":"page"},{"location":"examples/#Making-and-breaking-bonds","page":"Examples","title":"Making and breaking bonds","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"There is an example of mutable atom properties in the main docs, but what if you want to make and break bonds during the simulation? In this case you can use a PairwiseInteraction to make, break and apply the bonds. The partners of the atom can be stored in the atom type. We make a logger to record when the bonds are present, allowing us to visualize them with the connection_frames keyword argument to visualize (this can take a while to plot).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Molly\nusing GLMakie\nusing LinearAlgebra\n\nstruct BondableAtom\n    i::Int\n    mass::Float64\n    ::Float64\n    系::Float64\n    partners::Set{Int}\nend\n\nMolly.mass(ba::BondableAtom) = ba.mass\n\nstruct BondableInteraction <: PairwiseInteraction\n    nl_only::Bool\n    prob_formation::Float64\n    prob_break::Float64\n    dist_formation::Float64\n    b0::Float64\n    kb::Float64\nend\n\nfunction Molly.force(inter::BondableInteraction,\n                        dr,\n                        coord_i,\n                        coord_j,\n                        atom_i,\n                        atom_j,\n                        box_size)\n    # Break bonds randomly\n    if atom_j.i in atom_i.partners && rand() < inter.prob_break\n        delete!(atom_i.partners, atom_j.i)\n        delete!(atom_j.partners, atom_j.i)\n    end\n    # Make bonds between close atoms randomly\n    r2 = sum(abs2, dr)\n    if r2 < inter.b0 * inter.dist_formation && rand() < inter.prob_formation\n        push!(atom_i.partners, atom_j.i)\n        push!(atom_j.partners, atom_j.i)\n    end\n    # Apply the force of a harmonic bond\n    if atom_j.i in atom_i.partners\n        c = inter.kb * (norm(dr) - inter.b0)\n        fdr = -c * normalize(dr)\n        return fdr\n    else\n        return zero(coord_i)\n    end\nend\n\nstruct BondLogger\n    n_steps::Int\n    bonds::Vector{BitVector}\nend\n\nfunction Molly.log_property!(logger::BondLogger, s, neighbors, step_n)\n    if step_n % logger.n_steps == 0\n        bonds = BitVector()\n        for i in 1:length(s)\n            for j in 1:(i - 1)\n                push!(bonds, j in s.atoms[i].partners)\n            end\n        end\n        push!(logger.bonds, bonds)\n    end\nend\n\nn_atoms = 200\nbox_size = SVector(10.0, 10.0)\nn_steps = 2_000\ntemp = 1.0\n\natoms = [BondableAtom(i, 1.0, 0.1, 0.02, Set([])) for i in 1:n_atoms]\ncoords = place_atoms(n_atoms, box_size, 0.1)\nvelocities = [velocity(1.0, temp; dims=2) for i in 1:n_atoms]\npairwise_inters = (\n    SoftSphere(nl_only=true),\n    BondableInteraction(true, 0.1, 0.1, 1.1, 0.1, 2.0),\n)\nneighbor_finder = DistanceNeighborFinder(\n    nb_matrix=trues(n_atoms, n_atoms),\n    n_steps=10,\n    dist_cutoff=2.0,\n)\nsimulator = VelocityVerlet(dt=0.02, coupling=AndersenThermostat(temp, 5.0))\n\nsys = System(\n    atoms=atoms,\n    pairwise_inters=pairwise_inters,\n    coords=coords,\n    velocities=velocities,\n    box_size=box_size,\n    neighbor_finder=neighbor_finder,\n    loggers=Dict(\n        \"coords\" => CoordinateLogger(Float64, 20; dims=2),\n        \"bonds\"  => BondLogger(20, []),\n    ),\n    force_units=NoUnits,\n    energy_units=NoUnits,\n)\n\nsimulate!(sys, simulator, n_steps)\n\nconnections = Tuple{Int, Int}[]\nfor i in 1:length(sys)\n    for j in 1:(i - 1)\n        push!(connections, (i, j))\n    end\nend\n\nvisualize(sys.loggers[\"coords\"],\n            box_size,\n            \"sim_mutbond.mp4\";\n            connections=connections,\n            connection_frames=sys.loggers[\"bonds\"].bonds,\n            markersize=0.1)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Mutable bond simulation)","category":"page"},{"location":"examples/#Comparing-forces-to-AD","page":"Examples","title":"Comparing forces to AD","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The force is the negative derivative of the potential energy with respect to position. MD packages, including Molly, implement the force functions directly for performance. However it is also possible to compute the forces using AD. Here we compare the two approaches for the Lennard-Jones potential and see that they give the same result.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Molly\nusing Zygote\nusing GLMakie\n\ninter = LennardJones(force_units=NoUnits, energy_units=NoUnits)\nbox_size = SVector(5.0, 5.0, 5.0)\na1, a2 = Atom(=0.3, 系=0.5), Atom(=0.3, 系=0.5)\n\nfunction force_direct(dist)\n    c1 = SVector(1.0, 1.0, 1.0)\n    c2 = SVector(dist + 1.0, 1.0, 1.0)\n    vec = vector(c1, c2, box_size)\n    F = force(inter, vec, c1, c2, a1, a2, box_size)\n    return F[1]\nend\n\nfunction force_grad(dist)\n    grad = gradient(dist) do dist\n        c1 = SVector(1.0, 1.0, 1.0)\n        c2 = SVector(dist + 1.0, 1.0, 1.0)\n        vec = vector(c1, c2, box_size)\n        potential_energy(inter, vec, c1, c2, a1, a2, box_size)\n    end\n    return -grad[1]\nend\n\ndists = collect(0.2:0.01:1.2)\nforces_direct = force_direct.(dists)\nforces_grad = force_grad.(dists)\n\nf = Figure(resolution=(600, 400))\nax = Axis(\n    f[1, 1],\n    xlabel=\"Distance / nm\",\n    ylabel=\"Force / kJ * mol^-1 * nm^-1\",\n    title=\"Comparing gradients from direct calculation and AD\",\n)\nscatter!(ax, dists, forces_direct, label=\"Direct\", markersize=8)\nscatter!(ax, dists, forces_grad  , label=\"AD\"    , markersize=8, marker='x')\nxlims!(ax, low=0)\nylims!(ax, -6.0, 10.0)\naxislegend()\nsave(\"force_comparison.png\", f)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Force comparison)","category":"page"},{"location":"differentiable/#Differentiable-simulation-with-Molly","page":"Differentiable simulation","title":"Differentiable simulation with Molly","text":"","category":"section"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"note: Note\nThere are still some rough edges when taking gradients through simulations. Please open an issue if you run into an error and remember the golden rule of AD: always check your gradients against finite differencing.","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"In the last few years, the deep learning revolution has broadened to include the paradigm of differentiable programming. The concept of using automatic differentiation (AD) to obtain exact gradients through physical simulations has many interesting applications, including parameterising force fields and training neural networks to describe atom potentials.","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"There are some projects that explore differentiable molecular simulations such as Jax, M.D., TorchMD and mdgrad. However Julia provides a strong suite of AD tools, with Zygote.jl allowing source-to-source transformations for much of the language. With Molly you can use the power of Zygote to obtain gradients through molecular simulations. Reverse and forward mode AD can be used on the CPU and the GPU. Pairwise and specific interactions work, along with neighbor lists, and the same abstractions for running simulations are used as in the main package. Differentiable simulation does not currently work with units, user-defined types and some components of the package.","category":"page"},{"location":"differentiable/#Pairwise-interactions","page":"Differentiable simulation","title":"Pairwise interactions","text":"","category":"section"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"First, we show how taking gradients through a simulation can be used to optimise an atom property in a Lennard-Jones fluid. In this type of simulation each atom has a  value that determines how close it likes to get to other atoms. We are going to find the  value that results in a desired distance of each atom to its closest neighbor. First we need a function to obtain the mean distance of each atom to its closest neighbor:","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"using Molly\n\nfunction mean_min_separation(final_coords, box_size)\n    n_atoms = length(final_coords)\n    sum_dists = 0.0\n    for i in 1:n_atoms\n        min_dist = 100.0\n        for j in 1:n_atoms\n            i == j && continue\n            dist = sqrt(sum(abs2, vector(final_coords[i], final_coords[j], box_size)))\n            min_dist = min(dist, min_dist)\n        end\n        sum_dists += min_dist\n    end\n    return sum_dists / n_atoms\nend","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"Now we can set up and run the simulation in a similar way to that described in the Molly documentation. The difference is that we wrap the simulation in a loss function. This returns a single value that we want to obtain gradients with respect to, in this case the value of the above function at the end of the simulation. The Zygote.ignore() block allows us to ignore code for the purposes of obtaining gradients; you could add the visualize function there for example.","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"using Zygote\nusing Format\n\ndist_true = 0.5\nscale__to_dist = 2 ^ (1 / 6)\ntrue = dist_true / scale__to_dist\n\nn_atoms = 50\nn_steps = 500\natom_mass = 10.0\nbox_size = SVector(3.0, 3.0, 3.0)\ntemp = 1.0\nneighbor_finder = DistanceVecNeighborFinder(\n    nb_matrix=trues(n_atoms, n_atoms),\n    n_steps=10,\n    dist_cutoff=1.5,\n)\nlj = LennardJones(nl_only=true, force_units=NoUnits, energy_units=NoUnits)\n# Currently required for speed though here it does not affect the simulation\ncrf = CoulombReactionField(dist_cutoff=1.5, nl_only=true, coulomb_const=0.0,\n                           force_units=NoUnits, energy_units=NoUnits)\npairwise_inters = (lj, crf)\ncoords = place_atoms(n_atoms, box_size, 0.7)\nvelocities = [velocity(atom_mass, temp) for i in 1:n_atoms]\nsimulator = VelocityVerlet(\n    dt=0.02,\n    coupling=RescaleThermostat(temp),\n)\n\nfunction loss()\n    atoms = [Atom(0, 0.0, atom_mass, , 0.2, false) for i in 1:n_atoms]\n    loggers = Dict(\"coords\" => CoordinateLogger(Float64, 10))\n\n    s = System(\n        atoms=atoms,\n        pairwise_inters=pairwise_inters,\n        coords=coords,\n        velocities=velocities,\n        box_size=box_size,\n        neighbor_finder=neighbor_finder,\n        loggers=loggers,\n        force_units=NoUnits,\n        energy_units=NoUnits,\n        gpu_diff_safe=true,\n    )\n\n    mms_start = mean_min_separation(s.coords, box_size)\n    simulate!(s, simulator, n_steps)\n    mms_end = mean_min_separation(s.coords, box_size)\n    loss_val = abs(mms_end - dist_true)\n\n    Zygote.ignore() do\n        printfmt(\" {:6.3f}  |  Mean min sep expected {:6.3f}  |  Mean min sep end {:6.3f}  |  Loss {:6.3f}  |  \",\n                  ,  * (2 ^ (1 / 6)), mms_end, loss_val)\n    end\n\n    return loss_val\nend","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"Currently only the combination of LennardJones and CoulombReactionField works on the GPU or fast on the CPU. Other types work but run slower on the CPU. This will change in future.","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"We can obtain the gradient of loss with respect to the atom property .","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"grad = gradient(loss, true)[1]","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"This gradient can be used in a training loop to optimise , starting from an arbitrary value.","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"function train()\n    learn = 0.60 / scale__to_dist\n    n_epochs = 15\n\n    for epoch_n in 1:n_epochs\n        printfmt(\"Epoch {:>2}  |  \", epoch_n)\n        coords = place_atoms(n_atoms, box_size, 0.7)\n        velocities = [velocity(atom_mass, temp) for i in 1:n_atoms]\n        grad = gradient(loss, learn)[1]\n        printfmt(\"Grad {:6.3f}\\n\", grad)\n        learn -= grad * 1e-2\n    end\nend\n\ntrain()","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"Epoch  1  |    0.535  |  Mean min sep expected  0.600  |  Mean min sep end  0.587  |  Loss  0.087  |  Grad  0.793\nEpoch  2  |    0.527  |  Mean min sep expected  0.591  |  Mean min sep end  0.581  |  Loss  0.081  |  Grad  1.202\nEpoch  3  |    0.515  |  Mean min sep expected  0.578  |  Mean min sep end  0.568  |  Loss  0.068  |  Grad  1.558\nEpoch  4  |    0.499  |  Mean min sep expected  0.560  |  Mean min sep end  0.551  |  Loss  0.051  |  Grad  0.766\nEpoch  5  |    0.491  |  Mean min sep expected  0.552  |  Mean min sep end  0.543  |  Loss  0.043  |  Grad  1.068\nEpoch  6  |    0.481  |  Mean min sep expected  0.540  |  Mean min sep end  0.531  |  Loss  0.031  |  Grad  0.757\nEpoch  7  |    0.473  |  Mean min sep expected  0.531  |  Mean min sep end  0.526  |  Loss  0.026  |  Grad  0.781\nEpoch  8  |    0.465  |  Mean min sep expected  0.522  |  Mean min sep end  0.518  |  Loss  0.018  |  Grad  1.549\nEpoch  9  |    0.450  |  Mean min sep expected  0.505  |  Mean min sep end  0.504  |  Loss  0.004  |  Grad  0.030\nEpoch 10  |    0.450  |  Mean min sep expected  0.505  |  Mean min sep end  0.504  |  Loss  0.004  |  Grad  0.066\nEpoch 11  |    0.449  |  Mean min sep expected  0.504  |  Mean min sep end  0.503  |  Loss  0.003  |  Grad  0.313\nEpoch 12  |    0.446  |  Mean min sep expected  0.500  |  Mean min sep end  0.501  |  Loss  0.001  |  Grad  0.636\nEpoch 13  |    0.439  |  Mean min sep expected  0.493  |  Mean min sep end  0.497  |  Loss  0.003  |  Grad -0.181\nEpoch 14  |    0.441  |  Mean min sep expected  0.495  |  Mean min sep end  0.498  |  Loss  0.002  |  Grad -0.758\nEpoch 15  |    0.449  |  Mean min sep expected  0.504  |  Mean min sep end  0.503  |  Loss  0.003  |  Grad  0.281","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"The final value we get is 0.449, close to the theoretical value of 0.445 if all atoms have a neighbor at the minimum pairwise energy distance. The RDF looks as follows, with the purple line corresponding to the desired distance to the closest neighbor. (Image: LJ RDF)","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"It is common to require a loss function formed from values throughout a simulation. In this case it is recommended to split up the simulation into a set of short simulations, each starting from the previous final coordinates and velocities. This runs the same simulation but makes the intermediate coordinates and velocities available for use in the loss function. It is recommended to have a single value to accumulate values of the loss function. For example, the RMSD could be calculated from the coordinates every 100 steps and added to a variable that is then divided by the number of chunks to get a loss value corresponding to the mean RMSD over the simulation.","category":"page"},{"location":"differentiable/#Specific-interactions","page":"Differentiable simulation","title":"Specific interactions","text":"","category":"section"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"Next we look at obtaining gradients through simulations with specific interactions, e.g. bonds or angles between specified atoms. We will simulate two triatomic molecules and search for a minimum energy bond angle that gives a desired distance between the atoms at the end of the simulation.","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"using Molly\nusing Zygote\nusing Format\nusing LinearAlgebra\n\ndist_true = 1.0\n\nn_steps = 150\natom_mass = 10.0\nbox_size = SVector(3.0, 3.0, 3.0)\ntemp = 0.05\ncoords = [\n    SVector(0.8, 0.75, 1.5), SVector(1.5, 0.70, 1.5), SVector(2.3, 0.75, 1.5),\n    SVector(0.8, 2.25, 1.5), SVector(1.5, 2.20, 1.5), SVector(2.3, 2.25, 1.5),\n]\nn_atoms = length(coords)\nvelocities = zero(coords)\nsimulator = VelocityVerlet(\n    dt=0.05,\n    coupling=BerendsenThermostat(temp, 0.5),\n)\n\nfunction loss(胃)\n    atoms = [Atom(0, 0.0, atom_mass, 0.0, 0.0, false) for i in 1:n_atoms]\n    loggers = Dict(\"coords\" => CoordinateLogger(Float64, 2))\n    specific_inter_lists = (\n        InteractionList2Atoms(\n            [1, 2, 4, 5],\n            [2, 3, 5, 6],\n            [\"\", \"\", \"\", \"\"],\n            [HarmonicBond(0.7, 100.0) for _ in 1:4],\n        ),\n        InteractionList3Atoms(\n            [1, 4],\n            [2, 5],\n            [3, 6],\n            [\"\", \"\"],\n            [HarmonicAngle(胃, 10.0), HarmonicAngle(胃, 10.0)],\n        ),\n    )\n\n    s = System(\n        atoms=atoms,\n        specific_inter_lists=specific_inter_lists,\n        coords=deepcopy(coords),\n        velocities=deepcopy(velocities),\n        box_size=box_size,\n        loggers=loggers,\n        force_units=NoUnits,\n        energy_units=NoUnits,\n        gpu_diff_safe=true,\n    )\n\n    simulate!(s, simulator, n_steps)\n\n    d1 = norm(vector(s.coords[1], s.coords[3], box_size))\n    d2 = norm(vector(s.coords[4], s.coords[6], box_size))\n    dist_end = 0.5 * (d1 + d2)\n    loss_val = abs(dist_end - dist_true)\n\n    Zygote.ignore() do\n        printfmt(\"胃 {:5.1f}掳  |  Final dist {:4.2f}  |  Loss {:5.3f}  |  \",\n                 rad2deg(胃), dist_end, loss_val)\n    end\n\n    return loss_val\nend\n\nfunction train()\n    胃learn = deg2rad(110.0)\n    n_epochs = 20\n\n    for epoch_n in 1:n_epochs\n        printfmt(\"Epoch {:>2}  |  \", epoch_n)\n        grad = gradient(loss, 胃learn)[1]\n        printfmt(\"Grad {:6.3f}\\n\", round(grad; digits=2))\n        胃learn -= grad * 0.1\n    end\nend\n\ntrain()","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"Epoch  1  |  胃 110.0掳  |  Final dist 1.16  |  Loss 0.155  |  Grad  0.410\nEpoch  2  |  胃 107.7掳  |  Final dist 1.14  |  Loss 0.138  |  Grad  0.430\nEpoch  3  |  胃 105.2掳  |  Final dist 1.12  |  Loss 0.119  |  Grad  0.450\nEpoch  4  |  胃 102.6掳  |  Final dist 1.10  |  Loss 0.099  |  Grad  0.470\nEpoch  5  |  胃 100.0掳  |  Final dist 1.08  |  Loss 0.077  |  Grad  0.490\nEpoch  6  |  胃  97.2掳  |  Final dist 1.05  |  Loss 0.049  |  Grad  0.710\nEpoch  7  |  胃  93.1掳  |  Final dist 1.01  |  Loss 0.012  |  Grad  0.520\nEpoch  8  |  胃  90.1掳  |  Final dist 0.98  |  Loss 0.015  |  Grad -0.540\nEpoch  9  |  胃  93.2掳  |  Final dist 1.01  |  Loss 0.013  |  Grad  0.520\nEpoch 10  |  胃  90.2掳  |  Final dist 0.99  |  Loss 0.015  |  Grad -0.540\nEpoch 11  |  胃  93.3掳  |  Final dist 1.01  |  Loss 0.014  |  Grad  0.520\nEpoch 12  |  胃  90.3掳  |  Final dist 0.99  |  Loss 0.014  |  Grad -0.540\nEpoch 13  |  胃  93.4掳  |  Final dist 1.01  |  Loss 0.015  |  Grad  0.520\nEpoch 14  |  胃  90.4掳  |  Final dist 0.99  |  Loss 0.013  |  Grad -0.540\nEpoch 15  |  胃  93.5掳  |  Final dist 1.02  |  Loss 0.016  |  Grad  0.520\nEpoch 16  |  胃  90.5掳  |  Final dist 0.99  |  Loss 0.012  |  Grad -0.540\nEpoch 17  |  胃  93.6掳  |  Final dist 1.02  |  Loss 0.016  |  Grad  0.520\nEpoch 18  |  胃  90.6掳  |  Final dist 0.99  |  Loss 0.011  |  Grad -0.530\nEpoch 19  |  胃  93.7掳  |  Final dist 1.02  |  Loss 0.017  |  Grad  0.520\nEpoch 20  |  胃  90.7掳  |  Final dist 0.99  |  Loss 0.010  |  Grad -0.530","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"The final value we get is 90.7掳, close to the theoretical value of 91.2掳 which is obtainable from trigonometry. The final simulation looks like this: (Image: Angle simulation) In the presence of other forces this value would not be so trivially obtainable. We can record the gradients for different values of 胃:","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"胃s = collect(0:3:180)[2:end]\ngrads = [gradient(loss, deg2rad(胃))[1] for 胃 in 胃s]","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"The plot of these shows that the gradient has the expected sign either side of the correct value. (Image: Angle gradient)","category":"page"},{"location":"differentiable/#Neural-network-potentials","page":"Differentiable simulation","title":"Neural network potentials","text":"","category":"section"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"Since gradients can be computed with Zygote, Flux models can also be incorporated into simulations. Here we show a neural network in the force function, though they can also be used in other parts of the simulation. This example also shows how gradients for multiple parameters can be obtained, in this case the parameters of the neural network. The jump from single to multiple parameters is important because single parameters can be easily optimised using other approaches, whereas differentiable simulation is well-placed to optimise many parameters simultaneously.","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"We set up three pseudo-atoms and train a network to imitate the Julia logo by moving the bottom two atoms:","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"using Molly\nusing Zygote\nusing Flux\nusing Format\nusing LinearAlgebra\n\ndist_true = 1.0f0\n\nmodel = Chain(\n    Dense(1, 5, relu),\n    Dense(5, 1, tanh),\n)\nps = params(model)\n\nstruct NNBond <: SpecificInteraction end\n\nfunction Molly.force(b::NNBond, coords_i, coords_j, box_size)\n    vec_ij = vector(coords_i, coords_j, box_size)\n    dist = norm(vec_ij)\n    f = model([dist])[1] * normalize(vec_ij)\n    return SpecificForce2Atoms(f, -f)\nend\n\nn_steps = 400\nmass = 10.0f0\nbox_size = SVector(5.0f0, 5.0f0, 5.0f0)\ntemp = 0.01f0\ncoords = [SVector(2.3f0, 2.07f0, 0.0f0), SVector(2.5f0, 2.93f0, 0.0f0), SVector(2.7f0, 2.07f0, 0.0f0)]\nn_atoms = length(coords)\nvelocities = zero(coords)\nsimulator = VelocityVerlet(dt=0.02f0, coupling=BerendsenThermostat(temp, 0.5f0))\n\nfunction loss()\n    atoms = [Atom(0, 0.0f0, mass, 0.0f0, 0.0f0, false) for i in 1:n_atoms]\n    loggers = Dict(\"coords\" => CoordinateLogger(Float32, 10))\n    specific_inter_lists = (\n        InteractionList2Atoms([1], [3], [\"\"], [NNBond()]),\n    )\n\n    s = System(\n        atoms=atoms,\n        specific_inter_lists=specific_inter_lists,\n        coords=deepcopy(coords),\n        velocities=deepcopy(velocities),\n        box_size=box_size,\n        loggers=loggers,\n        force_units=NoUnits,\n        energy_units=NoUnits,\n        gpu_diff_safe=true,\n    )\n\n    simulate!(s, simulator, n_steps)\n\n    dist_end = (norm(vector(s.coords[1], s.coords[2], box_size)) +\n                norm(vector(s.coords[2], s.coords[3], box_size)) +\n                norm(vector(s.coords[3], s.coords[1], box_size))) / 3\n    loss_val = abs(dist_end - dist_true)\n\n    Zygote.ignore() do\n        printfmt(\"Dist end {:6.3f}  |  Loss {:6.3f}\\n\", dist_end, loss_val)\n        visualize(s.loggers[\"coords\"], box_size, \"sim.mp4\")\n    end\n\n    return loss_val\nend","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"Before training the result looks like this: (Image: Logo before)","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"function train()\n    n_epochs = 20\n    opt = ADAM(0.02, (0.9, 0.999))\n\n    for epoch_n in 1:n_epochs\n        printfmt(\"Epoch {:>2}  |  \", epoch_n)\n        Flux.train!(loss, ps, ((),), opt)\n    end\nend\n\ntrain()","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"Epoch  1  |  Dist end  0.757  |  Loss  0.243\nEpoch  2  |  Dist end  0.773  |  Loss  0.227\nEpoch  3  |  Dist end  0.794  |  Loss  0.206\nEpoch  4  |  Dist end  0.817  |  Loss  0.183\nEpoch  5  |  Dist end  0.843  |  Loss  0.157\nEpoch  6  |  Dist end  0.870  |  Loss  0.130\nEpoch  7  |  Dist end  0.898  |  Loss  0.102\nEpoch  8  |  Dist end  0.927  |  Loss  0.073\nEpoch  9  |  Dist end  0.957  |  Loss  0.043\nEpoch 10  |  Dist end  0.988  |  Loss  0.012\nEpoch 11  |  Dist end  1.018  |  Loss  0.018\nEpoch 12  |  Dist end  1.038  |  Loss  0.038\nEpoch 13  |  Dist end  1.050  |  Loss  0.050\nEpoch 14  |  Dist end  1.055  |  Loss  0.055\nEpoch 15  |  Dist end  1.054  |  Loss  0.054\nEpoch 16  |  Dist end  1.049  |  Loss  0.049\nEpoch 17  |  Dist end  1.041  |  Loss  0.041\nEpoch 18  |  Dist end  1.030  |  Loss  0.030\nEpoch 19  |  Dist end  1.017  |  Loss  0.017\nEpoch 20  |  Dist end  1.003  |  Loss  0.003","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"After training it looks much better: (Image: Logo after) You could replace the simple network here with a much more complicated model and it would theoretically be able to train, even if it might prove practically difficult (see discussion below).","category":"page"},{"location":"differentiable/#Molecular-loss-functions","page":"Differentiable simulation","title":"Molecular loss functions","text":"","category":"section"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"Ultimately, you need some objective function in order to calculate the gradient for each parameter. Here are some ideas for loss functions suitable for differentiable molecular simulations:","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"The distance between atoms at the end of the simulation compared to some reference state. This loss is used in the examples given here, is physically reasonable, and has obvious bounds.\nThe distance between atoms throughout the simulation.\nThe radial distribution function of atoms.\nRMSD between atoms and a reference state - this would be suitable for macromolecules.\ndRMSD, the distance between a distance map and a reference distance map.\nThe flexibility of a set of atoms over the simulation.\nSupramolecular geometry, for example assembly of molecules into straight fibres.\nThe correlation of different velocities over the simulation.\nThe energy of the system.\nThe temperature of the system.\nSome measure of phase change or a critical point.\nA combination of the above, for example to obtain a force field relevant to both ordered and disordered proteins.","category":"page"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"Some of these are currently not possible in Molly as the loggers are ignored for gradient purposes, but this will hopefully change in future.","category":"page"},{"location":"differentiable/#Tips-and-tricks","page":"Differentiable simulation","title":"Tips and tricks","text":"","category":"section"},{"location":"differentiable/","page":"Differentiable simulation","title":"Differentiable simulation","text":"The magnitude of gradients may be less important than the sign. Consider sampling gradients across different sources of stochasticity, such as starting velocities or conformations.\nExploding gradients prove a problem when using the velocity Verlet integrator in the NVE ensemble. This is why the velocity rescaling and Berendsen thermostats were used in the above examples. It is likely that the development of suitable simulation strategies and thermostats will be necessary to unlock the potential of differentiable simulation.\nDo you really need a neural network to describe your potential? Think about learning a smaller number of physically-meaningful parameters before you put in a large neural network and expect it to learn. Whilst it is true that neural networks are universal function approximators, it does not follow that you will be able to train one by differentiating through  a long simulation. A 1000-step simulation with a 10-layer network at each step is analogous to training a 10,000 layer network (with shared weights).\nForward mode AD holds much promise for differentiable simulation, provided the number of parameters is small, because the memory requirement is constant in the number of simulation steps. However, if the code runs slower than non-differentiable alternatives then the best approach may be to use finite differencing with the simulation as a black box.","category":"page"},{"location":"#Molly.jl","page":"Home","title":"Molly.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build status) (Image: Coverage status) (Image: Latest release) (Image: License) (Image: Documentation stable) (Image: Documentation dev)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Much of science can be explained by the movement and interaction of molecules. Molecular dynamics (MD) is a computational technique used to explore these phenomena, from noble gases to biological macromolecules. Molly.jl is a pure Julia package for MD, and for the simulation of physical systems more broadly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"At the minute the package is a proof of concept for MD in Julia. It is not production ready, though it can do some cool things and is under active development. Implemented features include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Non-bonded interactions - Lennard-Jones Van der Waals/repulsion force, electrostatic Coulomb potential and reaction field, gravitational potential, soft sphere potential, Mie potential.\nBonded interactions - covalent bonds, bond angles, torsion angles.\nInterface to allow definition of new interactions, simulators, thermostats, neighbor finders, loggers etc.\nRead in OpenMM force field files and coordinate files supported by Chemfiles.jl. There is also some support for Gromacs files.\nAndersen, Berendsen and velocity rescaling thermostats.\nVelocity Verlet and St枚rmer-Verlet integration.\nPeriodic boundary conditions in a cubic box.\nVarious neighbor list implementations to speed up calculation of non-bonded forces.\nUnitful.jl compatibility so numbers have physical meaning.\nAutomatic multithreading.\nGPU acceleration on CUDA-enabled devices.\nRun with Float64 or Float32.\nSome analysis functions, e.g. RDF.\nVisualise simulations as animations.\nPhysical agent-based modelling.\nDifferentiable molecular simulation. This is a unique feature of the package and the focus of its current development.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Features not yet implemented include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simulators such as energy minimisation, Langevin dynamics and REMD.\nOther temperature or pressure coupling methods.\nProtein preparation - solvent box, add hydrogens etc.\nQuantum mechanical modelling.\nHigh test coverage.\nAPI stability.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia is required, with Julia v1.7 or later required to get the latest version of Molly. Install Molly from the Julia REPL. Enter the package mode by pressing ] and run add Molly.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Some examples are given here, see the documentation for more on how to use the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simulation of a Lennard-Jones fluid:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Molly\n\nn_atoms = 100\nbox_size = SVector(2.0, 2.0, 2.0)u\"nm\"\ntemp = 298.0u\"K\"\natom_mass = 10.0u\"u\"\n\natoms = [Atom(mass=atom_mass, =0.3u\"nm\", 系=0.2u\"kJ * mol^-1\") for i in 1:n_atoms]\ncoords = place_atoms(n_atoms, box_size, 0.3u\"nm\")\nvelocities = [velocity(atom_mass, temp) for i in 1:n_atoms]\npairwise_inters = (LennardJones(),)\nsimulator = VelocityVerlet(dt=0.002u\"ps\", coupling=AndersenThermostat(temp, 1.0u\"ps\"))\n\nsys = System(\n    atoms=atoms,\n    pairwise_inters=pairwise_inters,\n    coords=coords,\n    velocities=velocities,\n    box_size=box_size,\n    loggers=Dict(\"temp\" => TemperatureLogger(100)),\n)\n\nsimulate!(sys, simulator, 10_000)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simulation of a protein:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Molly\n\nsys = System(\n    joinpath(dirname(pathof(Molly)), \"..\", \"data\", \"5XER\", \"gmx_coords.gro\"),\n    joinpath(dirname(pathof(Molly)), \"..\", \"data\", \"5XER\", \"gmx_top_ff.top\");\n    loggers=Dict(\n        \"temp\"   => TemperatureLogger(10),\n        \"writer\" => StructureWriter(10, \"traj_5XER_1ps.pdb\"),\n    ),\n)\n\ntemp = 298.0u\"K\"\nrandom_velocities!(sys, temp)\nsimulator = VelocityVerlet(dt=0.0002u\"ps\", coupling=AndersenThermostat(temp, 1.0u\"ps\"))\n\nsimulate!(sys, simulator, 5_000)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The above 1 ps simulation looks something like this when you view it in VMD: (Image: MD simulation)","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are very welcome - see the roadmap issue for more.","category":"page"},{"location":"docs/#Molly-documentation","page":"Documentation","title":"Molly documentation","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"This documentation will first introduce the main features of the package with some examples, then will give details on each component of a simulation. There are further examples in the Molly examples section. For more information on specific types or functions, see the Molly API section or call ?function_name in Julia. The Differentiable simulation with Molly section describes taking gradients through simulations.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Molly takes a modular approach to molecular simulation. To run a simulation you create a System object and call simulate! on it. The different components of the system and simulation can be used as defined by the package, or you can define your own versions. An important principle of the package is that your custom components, particularly force functions, should be easy to define and just as performant as the built-in versions.","category":"page"},{"location":"docs/#Simulation-basics","page":"Documentation","title":"Simulation basics","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Let's look at the simulation of a fluid acting under the Lennard-Jones potential to start with. First, we'll need some atoms with the relevant parameters defined.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"using Molly\n\nn_atoms = 100\natom_mass = 10.0u\"u\"\natoms = [Atom(mass=atom_mass, =0.3u\"nm\", 系=0.2u\"kJ * mol^-1\") for i in 1:n_atoms]","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"See the Unitful.jl docs for more information on the unit annotations. Molly re-exports Unitful.jl and StaticArrays.jl since they are usually required to run simulations. Next, we'll need some starting coordinates and velocities.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"box_size = SVector(2.0, 2.0, 2.0)u\"nm\"\ncoords = place_atoms(n_atoms, box_size, 0.3u\"nm\") # Random placement without clashing\n\ntemp = 100.0u\"K\"\nvelocities = [velocity(atom_mass, temp) for i in 1:n_atoms]","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"We store the coordinates and velocities as static arrays for performance. They can be of 2 or 3 dimensions and of any number type, e.g. Float64 or Float32. Now we can define our pairwise interactions, i.e. those between most or all atom pairs. Because we have defined the relevant parameters for the atoms, we can use the built-in Lennard-Jones type.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"pairwise_inters = (LennardJones(),)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Finally, we can define the system and run the simulation. We use an Andersen thermostat to keep a constant temperature, and we log the temperature and coordinates every 10 steps. Periodic boundary conditions are used with the box we defined earlier.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"sys = System(\n    atoms=atoms,\n    pairwise_inters=pairwise_inters,\n    coords=coords,\n    velocities=velocities,\n    box_size=box_size,\n    loggers=Dict(\n        \"temp\"   => TemperatureLogger(10),\n        \"coords\" => CoordinateLogger(10),\n    ),\n)\n\nsimulator = VelocityVerlet(dt=0.002u\"ps\", coupling=AndersenThermostat(temp, 1.0u\"ps\"))\nsimulate!(sys, simulator, 1_000)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"By default the simulation is run in parallel on the number of threads available to Julia, but this can be turned off by giving the keyword argument parallel=false to simulate!. An animation of the stored coordinates using can be saved using visualize, which is available when GLMakie.jl is imported.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"using GLMakie\nvisualize(sys.loggers[\"coords\"], box_size, \"sim_lj.mp4\")","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"(Image: LJ simulation)","category":"page"},{"location":"docs/#GPU-acceleration","page":"Documentation","title":"GPU acceleration","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"To run simulations on the GPU you will need to have a CUDA-compatible device and to have CUDA.jl installed. Simulation setup is similar to above, but with the coordinates, velocities and atoms moved to the GPU. This example also shows setting up a simulation to run with Float32, which can be a good idea for GPUs.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"using Molly\nusing CUDA\n\nn_atoms = 100\natom_mass = 10.0f0u\"u\"\nbox_size = SVector(2.0f0, 2.0f0, 2.0f0)u\"nm\"\ntemp = 100.0f0u\"K\"\natoms = cu([Atom(mass=atom_mass, =0.3f0u\"nm\", 系=0.2f0u\"kJ * mol^-1\") for i in 1:n_atoms])\ncoords = cu(place_atoms(n_atoms, box_size, 0.3u\"nm\"))\nvelocities = cu([velocity(atom_mass, temp) for i in 1:n_atoms])\nsimulator = VelocityVerlet(dt=0.002f0u\"ps\")\n\nsys = System(\n    atoms=atoms,\n    pairwise_inters=(LennardJones(),),\n    coords=coords,\n    velocities=velocities,\n    box_size=box_size,\n    loggers=Dict(\n        \"temp\"   => TemperatureLogger(typeof(1.0f0u\"K\"), 10),\n        \"coords\" => CoordinateLogger(typeof(1.0f0u\"nm\"), 10),\n    ),\n)\n\nsimulate!(sys, simulator, 1_000)","category":"page"},{"location":"docs/#Simulating-diatomic-molecules","page":"Documentation","title":"Simulating diatomic molecules","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"If we want to define specific interactions between atoms, for example bonds, we can do. Using the same definitions as the first example, let's set up the coordinates so that paired atoms are 1  apart.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"coords = place_atoms(n_atoms 梅 2, box_size, 0.3u\"nm\")\nfor i in 1:length(coords)\n    push!(coords, coords[i] .+ [0.1, 0.0, 0.0]u\"nm\")\nend\n\nvelocities = [velocity(atom_mass, temp) for i in 1:n_atoms]","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Now we can use the built-in interaction list and bond types to place harmonic bonds between paired atoms.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"bonds = InteractionList2Atoms(\n    collect(1:(n_atoms 梅 2)),\n    collect((1 + n_atoms 梅 2):n_atoms),\n    repeat([\"\"], n_atoms 梅 2),\n    [HarmonicBond(b0=0.1u\"nm\", kb=300_000.0u\"kJ * mol^-1 * nm^-2\") for i in 1:(n_atoms 梅 2)],\n)\n\nspecific_inter_lists = (bonds,)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"This time, we are also going to use a neighbor list to speed up the Lennard Jones calculation. We can use the built-in distance neighbor finder. The arguments are a 2D array of eligible interacting pairs, the number of steps between each update and the cutoff to be classed as a neighbor.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"# All pairs apart from bonded pairs are eligible to interact\nnb_matrix = trues(n_atoms, n_atoms)\nfor i in 1:(n_atoms 梅 2)\n    nb_matrix[i, i + (n_atoms 梅 2)] = false\n    nb_matrix[i + (n_atoms 梅 2), i] = false\nend\n\nneighbor_finder = DistanceNeighborFinder(\n    nb_matrix=nb_matrix,\n    n_steps=10,\n    dist_cutoff=1.5u\"nm\",\n)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Now we can simulate as before.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"sys = System(\n    atoms=atoms,\n    pairwise_inters=(LennardJones(nl_only=true),),\n    specific_inter_lists=specific_inter_lists,\n    coords=coords,\n    velocities=velocities,\n    box_size=box_size,\n    neighbor_finder=neighbor_finder,\n    loggers=Dict(\n        \"temp\" => TemperatureLogger(10),\n        \"coords\" => CoordinateLogger(10),\n    ),\n)\n\nsimulator = VelocityVerlet(\n    dt=0.002u\"ps\",\n    coupling=AndersenThermostat(temp, 1.0u\"ps\"),\n)\nsimulate!(sys, simulator, 1_000)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"This time when we view the trajectory we can add lines to show the bonds.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"visualize(\n    sys.loggers[\"coords\"],\n    box_size,\n    \"sim_diatomic.mp4\";\n    connections=[(i, i + (n_atoms 梅 2)) for i in 1:(n_atoms 梅 2)],\n)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"(Image: Diatomic simulation)","category":"page"},{"location":"docs/#Simulating-gravity","page":"Documentation","title":"Simulating gravity","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Molly is geared primarily to molecular simulation, but can also be used to simulate other physical systems. Let's set up a gravitational simulation. This example also shows the use of Float32, a 2D simulation and no specified units.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"atoms = [Atom(mass=1.0f0), Atom(mass=1.0f0)]\ncoords = [SVector(0.3f0, 0.5f0), SVector(0.7f0, 0.5f0)]\nvelocities = [SVector(0.0f0, 1.0f0), SVector(0.0f0, -1.0f0)]\npairwise_inters = (Gravity(nl_only=false, G=1.5f0),)\nsimulator = VelocityVerlet(dt=0.002f0)\nbox_size = SVector(1.0f0, 1.0f0)\n\nsys = System(\n    atoms=atoms,\n    pairwise_inters=pairwise_inters,\n    coords=coords,\n    velocities=velocities,\n    box_size=box_size,\n    loggers=Dict(\"coords\" => CoordinateLogger(Float32, 10; dims=2)),\n    force_units=NoUnits,\n    energy_units=NoUnits,\n)\n\nsimulate!(sys, simulator, 2_000)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"When we view the simulation we can use some extra options:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"visualize(\n    sys.loggers[\"coords\"],\n    box_size,\n    \"sim_gravity.mp4\";\n    trails=4,\n    framerate=15,\n    color=[:orange, :lightgreen],\n)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"(Image: Gravity simulation)","category":"page"},{"location":"docs/#Simulating-a-protein","page":"Documentation","title":"Simulating a protein","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"The recommended way to simulate a macromolecular simulation is to read in a force field in OpenMM XML format and read in a coordinate file in a format supported by Chemfiles.jl. This sets up a system in the same data structures as above and is simulated in the same way. Here a StructureWriter is used to write the trajectory as a PDB file.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"ff = OpenMMForceField(\"ff99SBildn.xml\", \"tip3p_standard.xml\", \"his.xml\")\n\nsys = System(\n    \"6mrr_equil.pdb\",\n    ff;\n    loggers=Dict(\n        \"energy\" => TotalEnergyLogger(10),\n        \"writer\" => StructureWriter(10, \"traj_6mrr_1ps.pdb\", [\"HOH\"]),\n    ),\n)\n\nrandom_velocities!(sys, 298.0u\"K\")\nsimulator = VelocityVerlet(dt=0.0005u\"ps\")\n\nsimulate!(sys, simulator, 5_000; parallel=true)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"You can use an implicit solvent method by giving the implicit_solvent keyword argument to System. The options are \"obc1\" and \"obc2\", corresponding to the Onufriev-Bashford-Case GBSA model with parameter set I or II. Other options include overriding the box size in the file (box_size) and modifying the non-bonded interaction and neighbor list cutoff distances (dist_cutoff and nl_dist).","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Molly also has a rudimentary parser of Gromacs topology and coordinate files.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"sys = System(\n    joinpath(dirname(pathof(Molly)), \"..\", \"data\", \"5XER\", \"gmx_coords.gro\"),\n    joinpath(dirname(pathof(Molly)), \"..\", \"data\", \"5XER\", \"gmx_top_ff.top\");\n    loggers=Dict(\n        \"temp\"   => TemperatureLogger(10),\n        \"writer\" => StructureWriter(10, \"traj_5XER_1ps.pdb\"),\n    ),\n)\n\ntemp = 298.0u\"K\"\nrandom_velocities!(sys, temp)\nsimulator = VelocityVerlet(dt=0.0002u\"ps\", coupling=AndersenThermostat(temp, 1.0u\"ps\"))\n\nsimulate!(sys, simulator, 5_000)","category":"page"},{"location":"docs/#Agent-based-modelling","page":"Documentation","title":"Agent-based modelling","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Agent-based modelling (ABM) is conceptually similar to molecular dynamics. Julia has Agents.jl for ABM, but Molly can also be used to simulate arbitrary agent-based systems in continuous space. Here we simulate a toy SIR model for disease spread. This example shows how atom properties can be mutable, i.e. change during the simulation, and includes custom forces and loggers (see below for more).","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"@enum Status susceptible infected recovered\n\n# Custom atom type\nmutable struct Person\n    i::Int\n    status::Status\n    mass::Float64\n    ::Float64\n    系::Float64\nend\n\nMolly.mass(person::Person) = person.mass\n\n# Custom PairwiseInteraction\nstruct SIRInteraction <: PairwiseInteraction\n    nl_only::Bool\n    dist_infection::Float64\n    prob_infection::Float64\n    prob_recovery::Float64\nend\n\n# Custom force function\nfunction Molly.force(inter::SIRInteraction,\n                        vec_ij,\n                        coord_i,\n                        coord_j,\n                        atom_i,\n                        atom_j,\n                        box_size)\n    if (atom_i.status == infected && atom_j.status == susceptible) ||\n                (atom_i.status == susceptible && atom_j.status == infected)\n        # Infect close people randomly\n        r2 = sum(abs2, vec_ij)\n        if r2 < inter.dist_infection ^ 2 && rand() < inter.prob_infection\n            atom_i.status = infected\n            atom_j.status = infected\n        end\n    end\n    # Workaround to obtain a self-interaction\n    if atom_i.i == (atom_j.i + 1)\n        # Recover randomly\n        if atom_i.status == infected && rand() < inter.prob_recovery\n            atom_i.status = recovered\n        end\n    end\n    return zero(coord_i)\nend\n\n# Custom Logger\nstruct SIRLogger\n    n_steps::Int\n    fracs_sir::Vector{Vector{Float64}}\nend\n\n# Custom logging function\nfunction Molly.log_property!(logger::SIRLogger, s, neighbors, step_n)\n    if step_n % logger.n_steps == 0\n        counts_sir = [\n            count(p -> p.status == susceptible, s.atoms),\n            count(p -> p.status == infected   , s.atoms),\n            count(p -> p.status == recovered  , s.atoms)\n        ]\n        push!(logger.fracs_sir, counts_sir ./ length(s))\n    end\nend\n\ntemp = 1.0\nbox_size = SVector(10.0, 10.0)\nn_steps = 1_000\nn_people = 500\nn_starting = 2\natoms = [Person(i, i <= n_starting ? infected : susceptible, 1.0, 0.1, 0.02) for i in 1:n_people]\ncoords = place_atoms(n_people, box_size, 0.1)\nvelocities = [velocity(1.0, temp; dims=2) for i in 1:n_people]\npairwise_inters = (LennardJones=LennardJones(nl_only=true), SIR=SIRInteraction(false, 0.5, 0.06, 0.01))\nneighbor_finder = DistanceNeighborFinder(nb_matrix=trues(n_people, n_people), n_steps=10, dist_cutoff=2.0)\nsimulator = VelocityVerlet(dt=0.02, coupling=AndersenThermostat(temp, 5.0))\n\nsys = System(\n    atoms=atoms,\n    pairwise_inters=pairwise_inters,\n    coords=coords,\n    velocities=velocities,\n    box_size=box_size,\n    neighbor_finder=neighbor_finder,\n    loggers=Dict(\"coords\" => CoordinateLogger(Float64, 10; dims=2),\n                    \"SIR\" => SIRLogger(10, [])),\n    force_units=NoUnits,\n    energy_units=NoUnits,\n)\n\nsimulate!(sys, simulator, n_steps)\n\nvisualize(sys.loggers[\"coords\"], box_size, \"sim_agent.mp4\"; markersize=0.1)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"(Image: Agent simulation)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"We can use the logger to plot the fraction of people susceptible (blue), infected (orange) and recovered (green) over the course of the simulation: (Image: Fraction SIR)","category":"page"},{"location":"docs/#Units","page":"Documentation","title":"Units","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Molly is fairly opinionated about using Unitful.jl units as shown above: you don't have to use them, but it is better if you do. Whilst you occasionally may run into friction with dimension mismatches, using units has the major advantages of catching whole classes of errors and letting you physically interpret the numbers in your system. The performance overhead of using units is minimal. Units are not currently compatible with differentiable simulations.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"All your interaction types need to return the same units of force and energy or the simulation will not run. By default these are kJ * mol^-1 * nm^-1 for force and kJ * mol^-1 for energy, but this can be changed using the force_units and energy_units arguments to System. If you need to strip units for downstream analysis, use the ustrip function. It should be noted that charges are stored as dimensionless, i.e. 1.0 is an atomic charge of +1.","category":"page"},{"location":"docs/#Forces","page":"Documentation","title":"Forces","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Forces define how different parts of the system interact. The force on each particle in the system is derived from the potential corresponding to the interaction.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"vecF_i = -sum_j fracdV_ij(r_ij)dr_ijfracvecr_ijr_ij","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"In Molly there are three types of interactions:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"PairwiseInteractions are present between all or most atom pairs, and account for example for non-bonded terms.\nSpecificInteractions are present between specific atoms, and account for example for bonded terms.\nGeneral interactions are a free-form interaction type that can access the whole system and outputs forces for all atom. This is useful for neural network potentials and implicit solvent models.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"The available pairwise interactions are:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"LennardJones\nSoftSphere\nMie\nCoulomb\nCoulombReactionField\nGravity","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"The available specific interactions are:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"HarmonicBond\nHarmonicAngle\nPeriodicTorsion\nRBTorsion","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"The available general interactions are:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"ImplicitSolventOBC","category":"page"},{"location":"docs/#Pairwise-interactions","page":"Documentation","title":"Pairwise interactions","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"To define your own PairwiseInteraction, first define the struct:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"struct MyPairwiseInter <: PairwiseInteraction\n    nl_only::Bool\n    # Any other properties, e.g. constants for the interaction or cutoff parameters\nend","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"The nl_only property is required and determines whether the neighbor list is used to omit distant atoms (true) or whether all atom pairs are always considered (false). Next, you need to define the force function acting between a pair of atoms. This has a set series of arguments. For example:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"function Molly.force(inter::MyPairwiseInter,\n                        vec_ij,\n                        coord_i,\n                        coord_j,\n                        atom_i,\n                        atom_j,\n                        box_size)\n    # Replace this with your force calculation\n    # A positive force causes the atoms to move apart\n    f = 0.0\n\n    # Obtain a vector for the force\n    fdr = f * normalize(vec_ij)\n    return fdr\nend","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"vec_ij is the vector between the closest images of atoms i and j accounting for the periodic boundary conditions. Atom properties can be accessed, e.g. atom_i.. Typically the force function is where most computation time is spent during the simulation, so consider optimising this function if you want high performance.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"To use your custom force in a simulation, add it to the list of pairwise interactions:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"pairwise_inters = (MyPairwiseInter(true),)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Then create a System and simulate as above. Note that you can also use named tuples instead of tuples if you want to access interactions by name:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"pairwise_inters = (MyPairwiseInter=MyPairwiseInter(true),)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"For performance reasons it is best to avoid containers with abstract type parameters, such as Vector{PairwiseInteraction}.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"If you wish to calculate potential energies or log the energy throughout a simulation, define the potential_energy function. This has the same arguments as force and should return a single value corresponding to the potential energy.","category":"page"},{"location":"docs/#Specific-interactions","page":"Documentation","title":"Specific interactions","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"To define your own SpecificInteraction, first define the struct:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"struct MySpecificInter <: SpecificInteraction\n    # Properties, e.g. a bond distance corresponding to the energy minimum\nend","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Next, you need to define the force function. The form of this will depend whether the interaction involves 2, 3 or 4 atoms. For example in the 2 atom case:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"function Molly.force(inter::MySpecificInter, coords_i, coords_j, box_size)\n    dr = vector(coords_i, coords_j, box_size)\n\n    # Replace this with your force calculation\n    # A positive force causes the atoms to move apart\n    f = 0.0\n\n    fdr = f * normalize(dr)\n    return SpecificForce2Atoms(-fdr, fdr)\nend","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"The 3 atom case would define Molly.force(inter::MySpecificInter, coords_i, coords_j, coords_k, box_size) and return SpecificForce3Atoms(f1, f2, f3). To use your custom force, add it to the specific interaction lists along with the atom indices:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"specific_inter_lists = (\n    InteractionList2Atoms(\n        [1, 3],\n        [2, 4],\n        [\"\", \"\"],\n        [MySpecificInter(), MySpecificInter()],\n    ),\n)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"For 3 atom interactions use InteractionList3Atoms and pass 3 sets of indices. If using the GPU, the inner list of interactions should be moved to the GPU.","category":"page"},{"location":"docs/#General-interactions","page":"Documentation","title":"General interactions","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"To define your own general interaction, first define the struct:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"struct MyGeneralInter\n    # Properties, e.g. a neural network model\nend","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Next, you need to define the forces function (note this is different to the force function above).","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"function Molly.forces(inter::MyGeneralInter, sys, neighbors=nothing)\n    # Calculate the forces on all atoms using the interaction and the system\n    # The output should have the same shape as the coordinates\n    # For example, a neural network might do something like this\n    return inter.model(sys.coords, sys.atoms)\nend","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"The neighbors calculated from the neighbor list are available in this function, but may or may not be used depending on context.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"You can also define a potential_energy function that takes the same arguments and returns a single value. To use your custom force in a simulation, add it to the list of general interactions:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"general_inters = (MyGeneralInter(),)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"general_inters=general_inters can be given as a keyword argument when setting up the System.","category":"page"},{"location":"docs/#Cutoffs","page":"Documentation","title":"Cutoffs","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"The total potential energy of a system is given as a sum of the individual inter-particle potentials","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"V(vecr_1 dotsc vecr_N) = sum_ijV_ij(r_ij)","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"The forces acting on the particles are given by","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"vecF_i = -sum_j fracdV_ij(r_ij)dr_ijfracvecr_ijr_ij","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"In the case of the Lennard-Jones potential, the inter-particle potential is given by","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"V_ij(r_ij) = 4varepsilon_ij leftleft(fracsigma_ijr_ijright)^12 - left(fracsigma_ijr_ijright)^6right","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"and the forces are given by","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"beginaligned\nvecF_i = 24varepsilon_ij left(2fracsigma_ij^12r_ij^13 - fracsigma_ij^6r_ij^7right) fracvecr_ijr_ij \n= frac24varepsilon_ijr_ij^2 left2left(fracsigma_ij^6r_ij^6right)^2 -left(fracsigma_ijr_ijright)^6right vecr_ij\nendaligned","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"As the potential, and thus also the force decreases rapidly with the distance, in almost every implementation of the Lennard-Jones force calculation there is a cutoff radius beyond which the force is set to 0.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"While this is often a sensible approach, it introduces a discontinuity in the force function and it requires us to also modify the potential, as beyond the cutoff radius the force would be 0, but the derivative of the unmodified potential is not. One way to truncate the potential is to shift the potential by its cutoff value.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"beginaligned\nvecF_SP(vecr) = begincases\nvecF(vecr) r  r_c \n0 r  r_c\nendcases \nV_SP(r) = begincases\nV(r) - V(r_c) r le r_c \n0 r  r_c\nendcases\nendaligned","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"This way the potential function is continuous and the relation between forces and potentials is satisfied. This truncation method is called shifted potential cutoff.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Another option is to shift the force in order to make it continuous","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"beginaligned\nF_SF(r) = begincases\nF(r) - F(r_c) r le r_c \n0 r  r_c\nendcases \nV_SF(r) = begincases\nV(r) - (r-r_c) V(r_c) - V(r_c) r le r_c \n0 r  r_c\nendcases\nendaligned","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"This requires a more complicated change in the potential in order to satisfy the relation between them. This method is called the shifted force cutoff. The continuity of the force is desirable as it may give better energy conservation properties as shown in Toxvaerd 2011.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"There are also more complicated truncation methods that interpolate between the original potential and 0, but we will consider those two for the moment.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"The truncation approximations that we use can significantly alter the qualitative features of the simulation as shown in many articles in the molecular dynamics literature (Fitzner 2017, van der Spoel 2006 and others).","category":"page"},{"location":"docs/#Implementation","page":"Documentation","title":"Implementation","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Since the truncation algorithm is independent of the interaction for which is used, each interaction is defined without including cutoffs. The corresponding interaction struct has a cutoff field which is then used via dispatch to apply the chosen cutoff. The available cutoffs are:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"NoCutoff\nDistanceCutoff\nShiftedPotentialCutoff\nShiftedForceCutoff","category":"page"},{"location":"docs/#Simulators","page":"Documentation","title":"Simulators","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Simulators define what type of simulation is run. This could be anything from a simple energy minimisation to complicated replica exchange MD. The available simulators are:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"VelocityVerlet\nStormerVerlet","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"To define your own simulator, first define a struct:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"struct MySimulator\n    # Any properties, e.g. the time step or coupling methods\nend","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Then, define the function that carries out the simulation. This example shows some of the helper functions you can use:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"function Molly.simulate!(sys::System,\n                            sim::MySimulator,\n                            n_steps::Integer;\n                            parallel::Bool=true)\n    # Find neighbors like this\n    neighbors = find_neighbors(sys, sys.neighbor_finder; parallel=parallel)\n\n    # Show a progress bar like this, if you have imported ProgressMeter\n    @showprogress for step_n in 1:n_steps\n        # Apply the loggers like this\n        run_loggers!(sys, neighbors, step_n)\n\n        # Calculate accelerations like this\n        accels_t = accelerations(sys, neighbors; parallel=parallel)\n\n        # Ensure coordinates stay within the simulation box like this\n        for i in 1:length(sys)\n            sys.coords[i] = wrap_coords.(sys.coords[i], sys.box_size)\n        end\n\n        # Apply coupling like this\n        apply_coupling!(sys, sim, sim.coupling)\n\n        # Find new neighbors like this\n        neighbors = find_neighbors(sys, sys.neighbor_finder, neighbors, step_n;\n                                   parallel=parallel)\n    end\n\n    return sys\nend","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"To use your custom simulator, give it as the second argument when calling simulate!.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Under the hood there are two implementations for simulators: an in-place version geared towards CPUs and parallelism, and an out-of-place version geared towards GPUs and differentiable simulation. You can define different versions of a simulator for in-place and out-of-place systems by dispatching on System{D, false} or System{D, true} respectively. This also applies to coupling methods and neighbor lists. You do not have to define two versions though: you may only intend to use the simulator one way, or the out-of-place version may be performant in all cases. The above example is more similar to the in-place version; see the source code for an example of the out-of-place version.","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"The implementation to use is guessed when you call System based on whether coords is a CuArray but can be given explicitly with the gpu_diff_safe argument, for example if you want to run differentiable simulations on the CPU. is_gpu_diff_safe will retrieve this property for a System.","category":"page"},{"location":"docs/#Coupling","page":"Documentation","title":"Coupling","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Temperature and pressure coupling allows properties to be controlled during a simulation. The available couplers are:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"AndersenThermostat\nRescaleThermostat\nBerendsenThermostat","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"To define your own coupling method, first define the struct:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"struct MyCoupler\n    # Any properties, e.g. a target temperature or coupling constant\nend","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Then, define the function that implements the coupling every time step:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"function apply_coupling!(sys::System, sim, coupling::MyCoupler)\n    # Do something to the simulation, e.g. scale the velocities\n    return sys\nend","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"The functions velocity, maxwell_boltzmann and temperature may be useful here. To use your custom coupler, give it as the coupling argument to the simulator.","category":"page"},{"location":"docs/#Neighbor-finders","page":"Documentation","title":"Neighbor finders","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Neighbor finders find close atoms periodically throughout the simulation, saving on computation time by allowing the force calculation between distant atoms to be omitted. The available neighbor finders are:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"NoNeighborFinder\nCellListMapNeighborFinder\nTreeNeighborFinder\nDistanceNeighborFinder\nDistanceVecNeighborFinder","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"To define your own AbstractNeighborFinder, first define the struct:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"struct MyNeighborFinder <: AbstractNeighborFinder\n    nb_matrix::BitArray{2}\n    matrix_14::BitArray{2}\n    n_steps::Int\n    # Any other properties, e.g. a distance cutoff\nend","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Examples of three useful properties are given here: a matrix indicating atom pairs eligible for non-bonded interactions, a matrix indicating atoms in a 1-4 bonding arrangement, and a value determining how many time steps occur between each evaluation of the neighbor finder. Then, define the neighbor finding function that is called every step by the simulator:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"function find_neighbors(s::System,\n                        nf::MyNeighborFinder,\n                        current_neighbors=nothing,\n                        step_n::Integer=0;\n                        parallel::Bool=true)\n    if step_n % nf.n_steps == 0\n        if isnothing(current_neighbors)\n            neighbors = NeighborList()\n        else\n            neighbors = current_neighbors\n        end\n        empty!(neighbors)\n        # Add to neighbors, for example\n        push!(neighbors, (1, 2, false)) # atom i, atom j and whether they are in a 1-4 bonding arrangement\n        return neighbors\n    else\n        return current_neighbors\n    end\nend","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"A different setup is used for the out-of-place implementation. To use your custom neighbor finder, give it as the neighbor_finder argument when creating the System.","category":"page"},{"location":"docs/#Loggers","page":"Documentation","title":"Loggers","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Loggers record properties of the simulation to allow monitoring and analysis. The available loggers are:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"TemperatureLogger\nCoordinateLogger\nVelocityLogger\nTotalEnergyLogger\nKineticEnergyLogger\nPotentialEnergyLogger\nStructureWriter","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"To define your own logger, first define the struct:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"struct MyLogger\n    n_steps::Int\n    # Any other properties, e.g. an Array to record values during the trajectory\nend","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Then, define the logging function that is called every step by the simulator:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"function Molly.log_property!(logger::MyLogger, sys, neighbors, step_n)\n    if step_n % logger.n_steps == 0\n        # Record some property or carry out some action\n    end\nend","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"The use of n_steps is optional and is an example of how to record a property every n steps through the simulation. To use your custom logger, add it to the dictionary of loggers given when creating the System:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"loggers = Dict(\"mylogger\" => MyLogger(10))","category":"page"},{"location":"docs/#Analysis","page":"Documentation","title":"Analysis","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Molly contains some tools for analysing the results of simulations. The available analysis functions are:","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"visualize\nrdf\ndistances\ndisplacements\nvelocity_autocorr","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Julia is a language well-suited to implementing all kinds of analysis for molecular simulations.","category":"page"}]
}
