var documenterSearchIndex = {"docs":
[{"location":"api/#Molly-API","page":"API","title":"Molly API","text":"The API reference can be found here.\n\nMolly re-exports StaticArrays.jl and Unitful.jl, making the likes of SVector and 1.0u\"nm\" available when you call using Molly.\n\nPackage extensions are used in order to reduce the number of dependencies:\n\nTo use visualize, call using GLMakie.\nTo use ASECalculator, call using PythonCall.\nTo use rdf, call using KernelDensity.","category":"section"},{"location":"api/#Exported-names","page":"API","title":"Exported names","text":"Order = [:module, :type, :constant, :function, :macro]","category":"section"},{"location":"api/#Docstrings","page":"API","title":"Docstrings","text":"","category":"section"},{"location":"api/#Molly.ASECalculator","page":"API","title":"Molly.ASECalculator","text":"ASECalculator(; <keyword arguments>)\n\nA Python ASE calculator.\n\nThis calculator is only available when PythonCall is imported. It is the user's responsibility to have the required Python packages installed. This includes ASE and any packages providing the calculator.\n\nContrary to the rest of Molly, unitless quantities are assumed to have ASE units: Å for length, eV for energy, u for mass, and Å sqrt(u/eV) for time. Unitful quantities will be converted as appropriate.\n\nNot currently compatible with TriclinicBoundary. Not currently compatible with virial calculation.\n\nArguments\n\nase_calc: the ASE calculator created with PythonCall.\natoms: the atoms, or atom equivalents, in the system.\ncoords: the coordinates of the atoms in the system. Typically a   vector of SVectors of 2 or 3 dimensions.\nboundary: the bounding box in which the simulation takes place.\nelements=nothing: vector of atom elements as a string, either elements or   atoms_data (which contains element data) must be provided.\natoms_data=nothing: other data associated with the atoms.\nvelocities=nothing: the velocities of the atoms in the system, only required   if the velocities contribute to the potential energy or forces.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.AndersenThermostat","page":"API","title":"Molly.AndersenThermostat","text":"AndersenThermostat(temperature, coupling_const)\n\nThe Andersen thermostat for controlling temperature.\n\nThe velocity of each atom is randomly changed each time step with probability dt / coupling_const to a velocity drawn from the Maxwell-Boltzmann distribution. See Andersen 1980.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.AngleConstraint","page":"API","title":"Molly.AngleConstraint","text":"AngleConstraint(i, j, k, angle_ijk, dist_ij, dist_jk)\n\nConstraint between three atoms that maintains a fixed angle and two bond lengths.\n\nAtoms i and k should be connected to central atom j with fixed bond distances given by dist_ij and dist_jk, forming the angle angle_ijk in radians. Internally, an AngleConstraint is converted into 3 distance constraints. None of the atoms in this constraint should be constrained with atoms not part of this constraint.\n\nFor example, a water molecule can be defined as AngleConstraint(1, 2, 3, deg2rad(104.5), 0.9572u\"Å\", 0.9572u\"Å\") where atom 2 is oxygen and atoms 1/3 are hydrogen.\n\nLinear molecules like CO2 can not be constrained.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.AshbaughHatch","page":"API","title":"Molly.AshbaughHatch","text":"AshbaughHatch(; cutoff, use_neighbors, shortcut, ϵ_mixing, σ_mixing,\n              λ_mixing, weight_special)\n\nThe Ashbaugh-Hatch potential (V_textAH) is a modified Lennard-Jones (V_textLJ) 6-12 interaction between two atoms.\n\nThe potential energy is defined as\n\nV_textLJ(r_ij) = 4varepsilon_ij leftleft(fracsigma_ijr_ijright)^12 - left(fracsigma_ijr_ijright)^6right \n\nV_textAH(r_ij) =\n    begincases\n      V_textLJ(r_ij) +varepsilon_ij(1-λ_ij)   r_ijleq  2^16σ  \n       λ_ijV_textLJ(r_ij)    2^16σ leq r_ij\n    endcases\n\nand the force on each atom by\n\nvecF_textAH =\n    begincases\n      F_textLJ(r_ij)    r_ij leq  2^16σ  \n       λ_ijF_textLJ(r_ij)    2^16σ leq r_ij\n    endcases\n\nwhere\n\nbeginaligned\nvecF_textLJ\n= frac24varepsilon_ijr_ij^2 left2left(fracsigma_ij^6r_ij^6right)^2 -left(fracsigma_ijr_ijright)^6right  vecr_ij\nendaligned\n\nIf lambda is one this gives the standard LennardJones potential.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.Atom","page":"API","title":"Molly.Atom","text":"Atom(; <keyword arguments>)\n\nAn atom and its associated information.\n\nProperties unused in the simulation or in analysis can be left with their default values. The types used should be bits types if the GPU is going to be used.\n\nArguments\n\nindex::Int=1: the index of the atom in the system. This only needs to be set if   it is used in the interactions. The order of atoms is determined by their order   in the atom vector.\natom_type::T=1: the type of the atom. This only needs to be set if   it is used in the interactions.\nmass::M=1.0u\"g/mol\": the mass of the atom.\ncharge::C=0.0: the charge of the atom, used for electrostatic interactions.\nσ::S=0.0u\"nm\": the Lennard-Jones finite distance at which the inter-particle   potential is zero.\nϵ::E=0.0u\"kJ * mol^-1\": the Lennard-Jones depth of the potential well.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.AtomData","page":"API","title":"Molly.AtomData","text":"AtomData(; atom_type=\"?\", atom_name=\"?\", res_number=1, res_name=\"???\",\n         chain_id=\"A\", element=\"?\", hetero_atom=false)\n\nData associated with an atom.\n\nStoring this separately allows the Atom types to be bits types and hence work on the GPU.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.AverageObservableLogger","page":"API","title":"Molly.AverageObservableLogger","text":"AverageObservableLogger(observable::Function, T::DataType, n_steps::Integer;\n                        n_blocks::Integer=1024)\n\nA logger that periodically records observations of a system and keeps a running empirical average.\n\nWhile GeneralObservableLogger holds a full record of observations, AverageObservableLogger does not. In addition, calling values(logger::AverageObservableLogger; std::Bool=true) returns two values: the current running average, and an estimate of the standard deviation for this average based on the block averaging method described in Flyvbjerg and Petersen 1989.\n\nArguments\n\nobservable::Function: the observable whose mean is recorded, must support   the method observable(s::System, neighbors; n_threads::Integer).\nT::DataType: the type returned by observable.\nn_steps::Integer: number of simulation steps between observations.\nn_blocks::Integer=1024: the number of blocks used in the block averaging   method, should be an even number.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.BerendsenBarostat","page":"API","title":"Molly.BerendsenBarostat","text":"BerendsenBarostat(pressure, coupling_const;\n                  coupling_type=:isotropic,\n                  compressibility=4.6e-5u\"bar^-1\",\n                  max_scale_frac=0.1, n_steps=1)\n\nThe Berendsen barostat for controlling pressure.\n\nThe scaling factor for the box every n_steps steps is\n\nmu_ij = delta_ij - fracDelta t3 tau_p kappa_ij left(P_0ij - P_ij(t) right)\n\nwith the fractional change limited to max_scale_frac.\n\nThe scaling factor mu is a matrix and delta is a Kronecker delta, allowing non-isotropic pressure control. Available options are :isotropic, :semiisotropic and :anisotropic.\n\nThis barostat should be used with caution as it known not to properly sample isobaric ensembles and therefore can lead to simulation artifacts.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.BerendsenThermostat","page":"API","title":"Molly.BerendsenThermostat","text":"BerendsenThermostat(temperature, coupling_const)\n\nThe Berendsen thermostat for controlling temperature.\n\nThe scaling factor for the velocities each step is\n\nlambda^2 = 1 + fracdelta ttau left( fracT_0T - 1 right)\n\nThis thermostat should be used with caution as it can lead to simulation artifacts.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.Buckingham","page":"API","title":"Molly.Buckingham","text":"Buckingham(; cutoff, use_neighbors, shortcut, A_mixing, B_mixing,\n           C_mixing, weight_special)\n\nThe Buckingham interaction between two atoms.\n\nThe potential energy is defined as\n\nV(r_ij) = A_ij exp(-B_ij r_ij) - fracC_ijr_ij^6\n\nand the force on each atom by\n\nvecF_i = left( A_ij B_ij exp(-B_ij r_ij) - 6 fracC_ijr_ij^7 right) fracvecr_ijr_ij\n\nThe parameters are derived from the atom parameters according to\n\nbeginaligned\nA_ij = (A_ii A_jj)^12 \nB_ij = frac2frac1B_ii + frac1B_jj \nC_ij = (C_ii C_jj)^12\nendaligned\n\nso atoms that use this interaction should have fields A, B and C available.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.CRescaleBarostat","page":"API","title":"Molly.CRescaleBarostat","text":"CRescaleBarostat(pressure, coupling_const;\n                 coupling_type=:isotropic,\n                 compressibility=4.6e-5u\"bar^-1\",\n                 max_scale_frac=0.1, n_steps=1)\n\nThe stochastic cell rescale barostat.\n\nSee [Bernetti and Bussi 2020] (https://doi.org/10.1063/5.0020514) and [Del Tatto et al. 2022] (https://doi.org/10.3390/app12031139). In brief, this is an extension of the Berendsen barostat that includes a stochastic term to the scaling matrix. This allows proper sampling of isobaric ensembles.\n\nmu = rmexpleft frac-kappa_T cdot Delta ttau_P cdot (P(t) - P_0) + sqrtfrac2 cdot k_BT cdot kappa_T cdot dtV(t) cdot tau_P cdot dW right\n\nwhere kappa_T is the isothermal compressibility, tau_P is the barostat coupling constant and rmdW represents a Wiener process.\n\nThe scaling factor mu is a matrix, allowing non-isotropic pressure control. Available options are :isotropic, :semiisotropic and :anisotropic.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.CellListMapNeighborFinder","page":"API","title":"Molly.CellListMapNeighborFinder","text":"CellListMapNeighborFinder(; eligible, dist_cutoff, special, n_steps, x0,\n                          unit_cell, dims)\n\nFind close atoms by distance using a cell list algorithm from CellListMap.jl.\n\nThis is the recommended neighbor finder on CPU. x0 and unit_cell are optional initial coordinates and system unit cell that improve the first approximation of the cell list structure. The number of dimensions dims is inferred from unit_cell or x0, or assumed to be 3 otherwise.\n\nCan not be used if one or more dimensions has infinite boundaries.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.CosineAngle","page":"API","title":"Molly.CosineAngle","text":"CosineAngle(; k, θ0)\n\nA cosine bond angle between three atoms.\n\nθ0 is in radians. The potential energy is defined as\n\nV(theta) = k(1 + cos(theta - theta_0))\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.Coulomb","page":"API","title":"Molly.Coulomb","text":"Coulomb(; cutoff, use_neighbors, weight_special, coulomb_const)\n\nThe Coulomb electrostatic interaction between two atoms.\n\nThe potential energy is defined as\n\nV(r_ij) = fracq_i q_j4 pi varepsilon_0 r_ij\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.CoulombEwald","page":"API","title":"Molly.CoulombEwald","text":"CoulombEwald(; dist_cutoff, error_tol=0.0005, use_neighbors=false, weight_special=1,\n             coulomb_const=coulomb_const, approximate_erfc=true)\n\nThe short range Ewald electrostatic interaction between two atoms.\n\nShould be used alongside the Ewald or PME general interaction, which provide the long-range term. dist_cutoff and error_tol should match the general interaction.\n\ndist_cutoff is the cutoff distance for short range interactions. approximate_erfc determines whether to use a fast approximation to the erfc function.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.CoulombReactionField","page":"API","title":"Molly.CoulombReactionField","text":"CoulombReactionField(; dist_cutoff, solvent_dielectric, use_neighbors, weight_special,\n                        coulomb_const)\n\nThe Coulomb electrostatic interaction modified using the reaction field approximation between two atoms.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.CoulombSoftCoreBeutler","page":"API","title":"Molly.CoulombSoftCoreBeutler","text":"CoulombSoftCoreBeutler(; cutoff, α, λ, use_neighbors, σ_mixing, ϵ_mixing,\n                       weight_special, coulomb_const)\n\nThe Coulomb electrostatic interaction between two atoms with a soft core, used for the appearing and disappearing of atoms.\n\nSee Beutler et al. 1994. The potential energy is defined as\n\nV(r_ij) = frac14piepsilon_0 fracq_iq_jr_Q^16\n\nand the force on each atom by\n\nvecF_i = frac14piepsilon_0 fracq_iq_jr_ij^5r_Q^76fracvecr_ijr_ij\n\nwhere\n\nr_Q = (fracalpha(1-lambda)C^(12)C^(6))+r_ij^6)\n\nand\n\nC^(12) = 4epsilonsigma^12\nC^(6) = 4epsilonsigma^6\n\nIf lambda is 1.0, this gives the standard Coulomb potential and means the atom is fully turned on. If lambda is zero the interaction is turned off. alpha determines the strength of softening the function.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.CoulombSoftCoreGapsys","page":"API","title":"Molly.CoulombSoftCoreGapsys","text":"CoulombSoftCoreGapsys(; cutoff, α, λ, σQ, use_neighbors, weight_special, coulomb_const)\n\nThe Coulomb electrostatic interaction between two atoms with a soft core, used for the appearing and disappearing of atoms.\n\nSee Gapsys et al. 2012. The potential energy is defined as\n\nV(r_ij) = left beginarraycl\nfrac14piepsilon_0 fracq_iq_jr_ij  textif  r ge r_LJ \nfrac14piepsilon_0 (fracq_iq_jr_Q^3r_ij^2-frac3q_iq_jr_Q^2r_ij+frac3q_iq_jr_Q)  textif  r lt r_LJ \nendarray right\n\nand the force on each atom by\n\nvecF_i = left beginarraycl\nfrac14piepsilon_0 fracq_iq_jr_ij^2fracvecr_ijr_ij  textif  r ge r_LJ \nfrac14piepsilon_0 (frac-2q_iq_jr_Q^3r_ij+frac3q_iq_jr_Q^2)fracvecr_ijr_ij  textif  r lt r_LJ \nendarray right\n\nwhere\n\nr_Q = alpha(1-lambda)^16(1+σ_Qqi*qj)\n\nIf lambda is 1.0, this gives the standard Coulomb potential and means the atom is fully turned on. If lambda is zero the interaction is turned off. alpha determines the strength of softening the function.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.CubicBoundary","page":"API","title":"Molly.CubicBoundary","text":"CubicBoundary(x, y, z)\nCubicBoundary(x)\n\nCubic 3D bounding box defined by three side lengths.\n\nIf one length is given then all three sides will have that length. Setting one or more values to Inf gives no boundary in that dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.CubicSplineCutoff","page":"API","title":"Molly.CubicSplineCutoff","text":"CubicSplineCutoff(dist_activation, dist_cutoff)\n\nCutoff that interpolates between the true potential at an activation distance and zero at a cutoff distance using a cubic Hermite spline.\n\nbeginaligned\nV_c(r) = begincases\nV(r) r le r_a \n(2t^3 - 3t^2 + 1) V(r_a) + (t^3 - 2t^2 + t) (r_c - r_a) V(r_a) r_a  r le r_c \n0 r  r_c\nendcases \nF_c(r) = begincases\nF(r) r le r_a \nfrac-(6t^2 - 6t) V(r_a)r_c - r_a - (3t^2 - 4t + 1) V(r_a) r_a  r le r_c \n0 r  r_c\nendcases \nt = fracr - r_ar_c - r_a\nendaligned\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.DisplacementsLogger","page":"API","title":"Molly.DisplacementsLogger","text":"DisplacementsLogger(n_steps, coords_start; n_steps_update::Integer=10)\n\nLog the displacements of atoms in a system throughout a simulation, useful for calculating properties like mean square displacement in periodic systems.\n\nDisplacements are updated every n_steps_update steps and a copy is saved every n_steps steps. coords_start are the initial reference positions and should match the coordinate type in the system.\n\nIt is assumed that a particle does not cross half the box size in n_steps_update steps. By default n_steps_update is set to 10 to mitigate this assumption, but it can be set to a higher value to reduce cost. n_steps must be a multiple of n_steps_update.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.DistanceConstraint","page":"API","title":"Molly.DistanceConstraint","text":"DistanceConstraint(i, j, dist)\n\nConstraint between two atoms that maintains a fixed distance between the atoms.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.DistanceCutoff","page":"API","title":"Molly.DistanceCutoff","text":"DistanceCutoff(dist_cutoff)\n\nCutoff that sets the potential and force to be zero past a specified cutoff distance.\n\nbeginaligned\nV_c(r) = begincases\nV(r) r le r_c \n0 r  r_c\nendcases \nF_c(r) = begincases\nF(r) r le r_c \n0 r  r_c\nendcases\nendaligned\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.DistanceNeighborFinder","page":"API","title":"Molly.DistanceNeighborFinder","text":"DistanceNeighborFinder(; eligible, dist_cutoff, special, n_steps)\n\nFind close atoms by distance.\n\nThis is the recommended neighbor finder on non-NVIDIA GPUs.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.EnsembleSystem","page":"API","title":"Molly.EnsembleSystem","text":"EnsembleSystem(coordinate_file, trajectory_file, force_field; <keyword arguments>)\nEnsembleSystem(system, trajectory_file)\n\nAn object allowing data to be read from a trajectory or ensemble associated with a System.\n\nThe keyword arguments are the same as System setup from a file. In the case of passing a System directly, a copy of the system is made.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.Ewald","page":"API","title":"Molly.Ewald","text":"Ewald(dist_cutoff; error_tol=0.0005, eligible=nothing, special=nothing)\n\nEwald summation for long range electrostatics implemented as an AtomsCalculators.jl calculator.\n\nShould be used alongside the CoulombEwald pairwise interaction, which provide the short range term. dist_cutoff and error_tol should match CoulombEwald.\n\ndist_cutoff is the cutoff distance for short range interactions. eligible indicates pairs eligible for short range interaction, and can be a matrix like the neighbor list or nothing to indicate that all pairs are eligible. special should also be given where relevant, as these interactions are excluded from long range calculation.\n\nThis algorithm is O(N^2) and in general PME should be used instead. Only compatible with 3D systems and CubicBoundary. Runs on the CPU, even for GPU systems.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.FENEBond","page":"API","title":"Molly.FENEBond","text":"FENEBond(; k, r0, σ, ϵ)\n\nA finitely extensible non-linear elastic (FENE) bond between two atoms, see Kremer and Grest 1990.\n\nThe potential energy is defined as\n\nV(r) = -frac12 k r^2_0 ln left( 1 - left( fracrr_0 right) ^2 right) + V_textWCA(r)\n\nwhere the WCA contribution is given by\n\nV_textWCA(r) =\n    begincases\n      4varepsilon left left( fracsigmar right) ^12 - left( fracsigmar right) ^6 right + varepsilon  r  2^16sigma\n      0  r geq 2^16sigma\n    endcases\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.GPUNeighborFinder","page":"API","title":"Molly.GPUNeighborFinder","text":"GPUNeighborFinder(; eligible, dist_cutoff, special, n_steps_reorder, initialized)\n\nUse the non-bonded forces/potential energy algorithm from Eastman and Pande 2010 to avoid calculating a neighbor list.\n\nThis is the recommended neighbor finder on NVIDIA GPUs.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.GeneralObservableLogger","page":"API","title":"Molly.GeneralObservableLogger","text":"GeneralObservableLogger(observable::Function, T, n_steps)\n\nA logger which holds a record of regularly sampled observations of a system.\n\nobservable should return an object of type T and support the method observable(s::System, neighbors; n_threads::Integer)::T.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.Gravity","page":"API","title":"Molly.Gravity","text":"Gravity(; cutoff, G, use_neighbors)\n\nThe gravitational interaction between two atoms.\n\nThe potential energy is defined as\n\nV(r_ij) = -fracG m_i m_jr_ij\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.HamiltonianREMD","page":"API","title":"Molly.HamiltonianREMD","text":"HamiltonianREMD(; <keyword arguments>)\n\nA simulator for a parallel Hamiltonian replica exchange MD (H-REMD) simulation on a ReplicaSystem.\n\nThe replicas are expected to have different Hamiltonians, i.e. different interactions. When calling simulate!, the assign_velocities keyword argument determines whether to assign random velocities at the appropriate temperature for each replica.\n\nArguments\n\ndt::DT: the time step of the simulation.\ntemperature::T: the temperatures of the simulation.\nsimulators::ST: individual simulators for simulating each replica.\nexchange_time::ET: the time interval between replica exchange attempts.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.HarmonicAngle","page":"API","title":"Molly.HarmonicAngle","text":"HarmonicAngle(; k, θ0)\n\nA harmonic bond angle between three atoms.\n\nθ0 is in radians. The second atom is the middle atom. The potential energy is defined as\n\nV(theta) = frac12 k (theta - theta_0)^2\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.HarmonicBond","page":"API","title":"Molly.HarmonicBond","text":"HarmonicBond(; k, r0)\n\nA harmonic bond between two atoms.\n\nThe potential energy is defined as\n\nV(r) = frac12 k (r - r_0)^2\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.HarmonicPositionRestraint","page":"API","title":"Molly.HarmonicPositionRestraint","text":"HarmonicPositionRestraint(; k, x0)\n\nA harmonic position restraint on an atom to coordinate x0.\n\nThe potential energy is defined as\n\nV(boldsymbolx) = frac12 k boldsymbolx - boldsymbolx_0^2\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.ImmediateThermostat","page":"API","title":"Molly.ImmediateThermostat","text":"ImmediateThermostat(temperature)\n\nThe immediate velocity rescaling thermostat for controlling temperature.\n\nVelocities are immediately rescaled to match a target temperature. The scaling factor for the velocities each step is\n\nlambda = sqrtfracT_0T\n\nThis thermostat should be used with caution as it can lead to simulation artifacts.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.ImplicitSolventGBN2","page":"API","title":"Molly.ImplicitSolventGBN2","text":"ImplicitSolventGBN2(atoms, atoms_data, bonds)\n\nGBn2 solvation model implemented as an AtomsCalculators.jl calculator.\n\nShould be used along with a Coulomb interaction.\n\nNot currently compatible with virial calculation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.ImplicitSolventOBC","page":"API","title":"Molly.ImplicitSolventOBC","text":"ImplicitSolventOBC(atoms, atoms_data, bonds)\n\nOnufriev-Bashford-Case GBSA model implemented as an AtomsCalculators.jl calculator.\n\nShould be used along with a Coulomb interaction. The keyword argument use_OBC2 determines whether to use parameter set I (false, the default) or II (true).\n\nNot currently compatible with virial calculation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.InteractionList1Atoms","page":"API","title":"Molly.InteractionList1Atoms","text":"InteractionList1Atoms(is, inters)\nInteractionList1Atoms(is, inters, types)\nInteractionList1Atoms(inter_type)\n\nA list of specific interactions that involve one atom such as position restraints.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.InteractionList2Atoms","page":"API","title":"Molly.InteractionList2Atoms","text":"InteractionList2Atoms(is, js, inters)\nInteractionList2Atoms(is, js, inters, types)\nInteractionList2Atoms(inter_type)\n\nA list of specific interactions that involve two atoms such as bond potentials.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.InteractionList3Atoms","page":"API","title":"Molly.InteractionList3Atoms","text":"InteractionList3Atoms(is, js, ks, inters)\nInteractionList3Atoms(is, js, ks, inters, types)\nInteractionList3Atoms(inter_type)\n\nA list of specific interactions that involve three atoms such as bond angle potentials.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.InteractionList4Atoms","page":"API","title":"Molly.InteractionList4Atoms","text":"InteractionList4Atoms(is, js, ks, ls, inters)\nInteractionList4Atoms(is, js, ks, ls, inters, types)\nInteractionList4Atoms(inter_type)\n\nA list of specific interactions that involve four atoms such as torsion potentials.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.Langevin","page":"API","title":"Molly.Langevin","text":"Langevin(; <keyword arguments>)\n\nThe Langevin integrator, based on the Langevin Middle Integrator in OpenMM.\n\nSee Zhang et al. 2019. This is a leapfrog integrator, so the velocities are offset by half a time step behind the positions.\n\nArguments\n\ndt::S: the time step of the simulation.\ntemperature::K: the equilibrium temperature of the simulation.\nfriction::F: the friction coefficient of the simulation.\ncoupling::C=NoCoupling(): the coupling which applies during the simulation.\nremove_CM_motion=1: remove the center of mass motion every this number of steps,   set to false or 0 to not remove center of mass motion.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.LangevinSplitting","page":"API","title":"Molly.LangevinSplitting","text":"LangevinSplitting(; <keyword arguments>)\n\nThe Langevin simulator using a general splitting scheme.\n\nThis consists of a succession of A, B and O steps, corresponding respectively to updates in position, velocity for the potential part, and velocity for the thermal fluctuation-dissipation part. The Langevin and VelocityVerlet simulators without coupling correspond to the BAOA and BAB schemes respectively. For more information on the sampling properties of splitting schemes, see Fass et al. 2018.\n\nNot currently compatible with constraints, will print a warning and continue without applying constraints.\n\nArguments\n\ndt::S: the time step of the simulation.\ntemperature::K: the equilibrium temperature of the simulation.\nfriction::F: the friction coefficient. If units are used, it should have a   dimensionality of mass per time.\nsplitting::W: the splitting specifier. Should be a string consisting of the   characters A, B and O. Strings with no Os reduce to deterministic   symplectic schemes.\nremove_CM_motion=1: remove the center of mass motion every this number of steps,   set to false or 0 to not remove center of mass motion.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.LennardJones","page":"API","title":"Molly.LennardJones","text":"LennardJones(; cutoff, use_neighbors, shortcut, σ_mixing, ϵ_mixing, weight_special)\n\nThe Lennard-Jones 6-12 interaction between two atoms.\n\nThe potential energy is defined as\n\nV(r_ij) = 4varepsilon_ij leftleft(fracsigma_ijr_ijright)^12 - left(fracsigma_ijr_ijright)^6right\n\nand the force on each atom by\n\nbeginaligned\nvecF_i = 24varepsilon_ij left(2fracsigma_ij^12r_ij^13 - fracsigma_ij^6r_ij^7right) fracvecr_ijr_ij \n= frac24varepsilon_ijr_ij^2 left2left(fracsigma_ij^6r_ij^6right)^2 -left(fracsigma_ijr_ijright)^6right vecr_ij\nendaligned\n\nThe potential energy does not include the long range dispersion correction present in some other implementations that approximately represents contributions from beyond the cutoff distance.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.LennardJonesSoftCoreBeutler","page":"API","title":"Molly.LennardJonesSoftCoreBeutler","text":"LennardJonesSoftCoreBeutler(; cutoff, α, λ, use_neighbors, shortcut, σ_mixing,\n                            ϵ_mixing, weight_special)\n\nThe Lennard-Jones 6-12 interaction between two atoms with a soft core, used for the appearing and disappearing of atoms.\n\nSee Beutler et al. 1994. The potential energy is defined as\n\nV(r_ij) = fracC^(12)r_LJ^12 - fracC^(6)r_LJ^6\n\nand the force on each atom by\n\nvecF_i = ((frac12C^(12)r_LJ^13 - frac6C^(6)r_LJ^7)(fracr_ijr_LJ)^5) fracvecr_ijr_ij\n\nwhere\n\nr_LJ = (fracalpha(1-lambda)C^(12)C^(6)+r^6)^16\n\nand\n\nC^(12) = 4epsilonsigma^12\nC^(6) = 4epsilonsigma^6\n\nIf lambda is 1.0, this gives the standard LennardJones potential and means the atom is fully turned on. If lambda is zero the interaction is turned off. alpha determines the strength of softening the function.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.LennardJonesSoftCoreGapsys","page":"API","title":"Molly.LennardJonesSoftCoreGapsys","text":"LennardJonesSoftCoreGapsys(; cutoff, α, λ, use_neighbors, shortcut, σ_mixing,\n                           ϵ_mixing, weight_special)\n\nThe Lennard-Jones 6-12 interaction between two atoms with a soft core potential, used for the appearing and disappearing of atoms.\n\nSee Gapsys et al. 2012. The potential energy is defined as\n\nV(r_ij) = left beginarraycl\nfracC^(12)r_ij^12 - fracC^(6)r_ij^6  textif  r ge r_LJ \n(frac78C^(12)r_LJ^14-frac21C^(6)r_LJ^8)r_ij^2 - (frac168C^(12)r_LJ^13-frac48C^(6)r_LJ^7)r_ij + frac91C^(12)r_LJ^12-frac28C^(6)r_LJ^6  textif  r lt r_LJ \nendarray right\n\nand the force on each atom by\n\nvecF_i = left beginarraycl\n(frac12C^(12)r_ij^13 - frac6C^(6)r_ij^7)fracvecr_ijr_ij  textif  r ge r_LJ \n((frac-156C^(12)r_LJ^14+frac42C^(6)r_LJ^8)r_ij - (frac168C^(12)r_LJ^13-frac48C^(6)r_LJ^7))fracvecr_ijr_ij  textif  r lt r_LJ \nendarray right\n\nwhere\n\nr_LJ = alpha(frac26C^(12)(1-lambda)7C^(6))^frac16\n\nand\n\nC^(12) = 4epsilonsigma^12\nC^(6) = 4epsilonsigma^6\n\nIf lambda is 1.0, this gives the standard LennardJones potential and means the atom is fully turned on. If lambda is zero the interaction is turned off. alpha determines the strength of softening the function.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.MetropolisMonteCarlo","page":"API","title":"Molly.MetropolisMonteCarlo","text":"MetropolisMonteCarlo(; <keyword arguments>)\n\nA Monte Carlo simulator that uses the Metropolis algorithm to sample the configuration space.\n\nArguments\n\ntemperature::T: the temperature of the system.\ntrial_moves::M: a function that performs the trial moves.\ntrial_args::Dict: a dictionary of arguments to be passed to the trial move function.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.Mie","page":"API","title":"Molly.Mie","text":"Mie(; m, n, cutoff, use_neighbors, shortcut, σ_mixing, ϵ_mixing, weight_special)\n\nThe Mie generalized interaction between two atoms.\n\nWhen m equals 6 and n equals 12 this is equivalent to the Lennard-Jones interaction. The potential energy is defined as\n\nV(r_ij) = C varepsilon_ij leftleft(fracsigma_ijr_ijright)^n - left(fracsigma_ijr_ijright)^mright\n\nwhere\n\nC = fracnn - m left( fracnm right) ^fracmn - m\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.MolecularForceField","page":"API","title":"Molly.MolecularForceField","text":"MolecularForceField(ff_files...; units=true, custom_residue_templates = nothing, custom_renaming_scheme = nothing)\nMolecularForceField(T, ff_files...; units=true)\nMolecularForceField(atom_types, residue_types, bond_types, angle_types,\n                    torsion_types, torsion_order, weight_14_coulomb,\n                    weight_14_lj, attributes_from_residue,\n                    residue_name_replacements, atom_name_replacements,\n                    standard_bonds)\n\nA molecular force field. \n\nRead one or more OpenMM force field XML files by passing them to the constructor.\n\nIn order to  assign force field parameters to the atoms in the simulation, the residues determined from a structure file are matched to templates provided by the force field file, as well as a template dictionary in .xml format, which defines the standard topology (bonds) of the residues to be found in the simulation. At the moment, Molly provides a dictionary for all standard aminoacids, nucleic acids and water for this purpose. If the system to be simulated contains other molecules, their template topologies must be defined either through CONNECT records in the .pdb file  or by prviding an extra custom template file with the custom_residue_templates keyword.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.MolecularTopology","page":"API","title":"Molly.MolecularTopology","text":"MolecularTopology(bond_is, bond_js, n_atoms)\nMolecularTopology(atom_molecule_inds, molecule_atom_counts, bonded_atoms=[])\n\nTopology information for a system.\n\nStores the index of the molecule each atom belongs to, the number of atoms in each molecule and the list of bonded atom pairs.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.MollyCalculator","page":"API","title":"Molly.MollyCalculator","text":"MollyCalculator(; <keyword arguments>)\n\nA calculator for use with the AtomsCalculators.jl interface.\n\nneighbors can optionally be given as a keyword argument when calling the calculation functions to save on computation when the neighbors are the same for multiple calls. In a similar way, n_threads can be given to determine the number of threads to use when running the calculation function. Note that this calculator is designed for using Molly in other contexts; if you want to use another calculator in Molly it can be given as general_inters when creating a System.\n\nNot currently compatible with virial calculation. Not currently compatible with using atom properties such as σ and ϵ.\n\nArguments\n\npairwise_inters::PI=(): the pairwise interactions in the system, i.e.   interactions between all or most atom pairs such as electrostatics.   Should be a Tuple or NamedTuple of PairwiseInteractions.\nspecific_inter_lists::SI=(): the specific interactions in the system,   i.e. interactions between specific atoms such as bonds or angles.   Should be a Tuple or NamedTuple.\ngeneral_inters::GI=(): the general interactions in the system,   i.e. interactions involving all atoms such as implicit solvent. Each should   implement the AtomsCalculators.jl interface. Should be a Tuple or NamedTuple.\nneighbor_finder::NF=NoNeighborFinder(): the neighbor finder used to find   close atoms and save on computation.\nforce_units::F=u\"kJ * mol^-1 * nm^-1\": the units of force of the system.   Should be set to NoUnits if units are not being used.\nenergy_units::E=u\"kJ * mol^-1\": the units of energy of the system. Should   be set to NoUnits if units are not being used.\nk::K=Unitful.k or Unitful.k * Unitful.Na: the Boltzmann constant, which may be   modified in some simulations. k is chosen based on the energy_units given.\ndims::Integer=3: the number of dimensions in the system.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.MonteCarloBarostat","page":"API","title":"Molly.MonteCarloBarostat","text":"MonteCarloBarostat(pressure, temperature, boundary; coupling_type=:isotropic,\n                   n_steps=30, n_iterations=1,\n                   scale_factor=0.01, scale_increment=1.1, max_volume_frac=0.3,\n                   trial_find_neighbors=false)\n\nThe Monte Carlo barostat for controlling pressure.\n\nSee Chow and Ferguson 1995, Åqvist et al. 2004 and the OpenMM source code. At regular intervals a Monte Carlo step is attempted by scaling the coordinates and the bounding box by a randomly chosen amount. The step is accepted or rejected based on\n\nDelta G = Delta E + Delta W - N k_B T ln left( fracV + Delta VV right)\n\nwhere ΔE is the change in potential energy, ΔV is the change in volume, N is the number of molecules in the system, T is the equilibrium temperature and V is the system volume. ΔW is the work done by scaling the simulation box and its specific form changes depending on the type of scaling applied. In general and in the absence of shear stress:\n\nDelta W = (V + Delta V) cdot sum w_i cdot  P_ii cdot ln left ( fracV + Delta VV right )\n\nwhere w_i is the proportional scaling along a specific box axis.\n\nIf ΔG ≤ 0 the step is always accepted, if ΔG > 0 the step is accepted with probability exp(-ΔG/kT).\n\nThe scale factor is modified over time to maintain an acceptance rate of around half. If the topology of the system is set then molecules are moved as a unit so properties such as bond lengths do not change.\n\nThe barostat assumes that the simulation is being run at a constant temperature but does not actively control the temperature. It should be used alongside a temperature coupling method such as the Langevin simulator or AndersenThermostat coupling. The neighbor list is not updated when making trial moves or after accepted moves. Note that the barostat can change the bounding box of the system. Does not currently work with shear stresses, the anisotropic variant only applies independent linear scaling of the box vectors. If shear deformation is required the BerendsenBarostat or, preferrably, the CRescaleBarostat should be used instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.MonteCarloLogger","page":"API","title":"Molly.MonteCarloLogger","text":"MonteCarloLogger()\nMonteCarloLogger(T)\n\nA logger that records acceptances in a Monte Carlo simulation.\n\nThe logged quantities include the number of new selections (n_select), the number of successful acceptances (n_accept), an array named energy_rates which stores the value of fracEk_B T i.e. the argument of the Boltzmann factor for the states, and a BitVector named state_changed that stores whether a new state was accepted for the logged step.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.MorseBond","page":"API","title":"Molly.MorseBond","text":"MorseBond(; D, a, r0)\n\nA Morse potential bond between two atoms.\n\nThe potential energy is defined as\n\nV(r) = D(1 - e^-a(r - r_0))^2\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.MullerBrown","page":"API","title":"Molly.MullerBrown","text":"MullerBrown(; A, a, b, c, x0, y0, force_units, energy_units)\n\nThe Müller-Brown potential energy surface implemented as an AtomsCalculators.jl calculator.\n\nThe potential energy is defined as\n\nV(xy) = sum_n=1^4 A_k expa_k(x-x_k^0)^2 + b_k(x-x_k^0)(y-y_k^0) + c_k(y-y_k^0)^2\n\nwhere A, a, b, c, x0, y0 are 4-element SVectors with standard defaults.\n\nThis potential is only compatible with 2D systems. It is often used for testing algorithms that find transition states or explore minimum energy pathways. There are 3 minima and 2 saddle points with the default parameters.\n\nNot currently compatible with virial calculation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.NeighborList","page":"API","title":"Molly.NeighborList","text":"NeighborList(n, list)\nNeighborList()\n\nStructure to contain neighbor lists.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.NoCoupling","page":"API","title":"Molly.NoCoupling","text":"NoCoupling()\n\nPlaceholder coupler that does nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.NoCutoff","page":"API","title":"Molly.NoCutoff","text":"NoCutoff()\n\nPlaceholder cutoff that does not alter the potential or force.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.NoNeighborFinder","page":"API","title":"Molly.NoNeighborFinder","text":"NoNeighborFinder()\n\nPlaceholder neighbor finder that returns no neighbors.\n\nWhen using this neighbor finder, ensure that use_neighbors for the interactions returns false.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.NoseHoover","page":"API","title":"Molly.NoseHoover","text":"NoseHoover(; <keyword arguments>)\n\nThe Nosé-Hoover integrator, a NVT simulator that extends velocity Verlet to control the temperature of the system.\n\nSee Evans and Holian 1985. The current implementation is limited to ergodic systems.\n\nNot currently compatible with constraints, will print a warning and continue without applying constraints.\n\nArguments\n\ndt::T: the time step of the simulation.\ntemperature::K: the equilibrium temperature of the simulation.\ndamping::D=100*dt: the temperature damping time scale.\ncoupling::C=NoCoupling(): the coupling which applies during the simulation.\nremove_CM_motion=1: remove the center of mass motion every this number of steps,   set to false or 0 to not remove center of mass motion.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.OverdampedLangevin","page":"API","title":"Molly.OverdampedLangevin","text":"OverdampedLangevin(; <keyword arguments>)\n\nSimulates the overdamped Langevin equation using the Euler-Maruyama method.\n\nNot currently compatible with constraints, will print a warning and continue without applying constraints.\n\nArguments\n\ndt::S: the time step of the simulation.\ntemperature::K: the equilibrium temperature of the simulation.\nfriction::F: the friction coefficient of the simulation.\nremove_CM_motion=1: remove the center of mass motion every this number of steps,   set to false or 0 to not remove center of mass motion.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.PME","page":"API","title":"Molly.PME","text":"PME(dist_cutoff, atoms, boundary; error_tol=0.0005, order=5,\n    ϵr=1.0, fixed_charges=true, eligible=nothing, special=nothing,\n    grad_safe=false, n_threads=Threads.nthreads())\n\nParticle mesh Ewald summation for long range electrostatics implemented as an AtomsCalculators.jl calculator.\n\nShould be used alongside the CoulombEwald pairwise interaction, which provide the short range term. dist_cutoff and error_tol should match CoulombEwald.\n\ndist_cutoff is the cutoff distance for short range interactions. eligible indicates pairs eligible for short range interaction, and can be a matrix like the neighbor list or nothing to indicate that all pairs are eligible. special should also be given where relevant, as these interactions are excluded from long range calculation. fixed_charges should be set to false if the partial charges can change, for example when using a polarizable force field. grad_safe should be set to true if gradients are going to be calculated with Enzyme.jl. n_threads is used to pre-allocate memory on CPU.\n\nThis implementation is based on the implementation in OpenMM, which is based on the smooth PME algorithm from Essmann et al. 1995.\n\nOnly compatible with 3D systems.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.PairwiseInteraction","page":"API","title":"Molly.PairwiseInteraction","text":"Base type for pairwise interactions.\n\nAn alias for NBodyInteraction{2}. Custom pairwise interactions should subtype this.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.PeriodicTorsion","page":"API","title":"Molly.PeriodicTorsion","text":"PeriodicTorsion(; periodicities, phases, ks, proper)\n\nA periodic torsion angle between four atoms.\n\nphases are in radians. The potential energy is defined as\n\nV(phi) = sum_n=1^N k_n (1 + cos(n phi - phi_sn))\n\nOnly compatible with 3D systems.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.RBTorsion","page":"API","title":"Molly.RBTorsion","text":"RBTorsion(; f1, f2, f3, f4)\n\nA Ryckaert-Bellemans torsion angle between four atoms.\n\nOnly compatible with 3D systems.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.RectangularBoundary","page":"API","title":"Molly.RectangularBoundary","text":"RectangularBoundary(x, y)\nRectangularBoundary(x)\n\nRectangular 2D bounding box defined by two side lengths.\n\nIf one length is given then both sides will have that length. Setting one or more values to Inf gives no boundary in that dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.ReplicaExchangeLogger","page":"API","title":"Molly.ReplicaExchangeLogger","text":"ReplicaExchangeLogger(n_replicas)\nReplicaExchangeLogger(T, n_replicas)\n\nA logger that records exchanges in a replica exchange simulation.\n\nThe logged quantities include the number of exchange attempts (n_attempts), number of successful exchanges (n_exchanges), exchanged replica indices (indices), exchange steps (steps) and the value of Δ i.e. the argument of Metropolis rate for the exchanges (deltas).\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.ReplicaSystem","page":"API","title":"Molly.ReplicaSystem","text":"ReplicaSystem(; <keyword arguments>)\n\nA wrapper for replicas in a replica exchange simulation.\n\nEach individual replica is a System. Properties unused in the simulation or in analysis can be left with their default values. The minimal required arguments are atoms, replica_coords, boundary and n_replicas. atoms and the elements in replica_coords should have the same length, along with atoms_data and the elements in replica_velocities if these are provided. The number of elements in replica_coords, replica_boundaries, replica_velocities, replica_loggers and the interaction arguments replica_pairwise_inters, replica_specific_inter_lists, replica_general_inters and replica_constraints should be equal to n_replicas if used. This is a sub-type of AbstractSystem from AtomsBase.jl and implements the interface described there.\n\nWhen using ReplicaSystem with CellListMapNeighborFinder, the number of threads used for both the simulation of replicas and the neighbor finder should be set to be the same. This can be done by passing nbatches=(min(n, 8), n) to CellListMapNeighborFinder during construction where n is the number of threads to be used per replica.\n\nArguments\n\natoms::A: the atoms, or atom equivalents, in the system. Can be   of any type but should be a bits type if the GPU is used.\nreplica_coords: the coordinates of the atoms in each replica.\nn_replicas::Integer: the number of replicas of the system.\nboundary=nothing: the bounding box in which the simulation takes place. This is only   used if no value is passed to the argument replica_pairwise_inters.\nreplica_boundaries=nothing: the bounding box for each replica.\nreplica_velocities=[zero(replica_coords[1]) * u\"ps^-1\" for _ in 1:n_replicas]:   the velocities of the atoms in each replica.\natoms_data::AD: other data associated with the atoms, allowing the atoms to   be bits types and hence work on the GPU.\ntopology::TO=nothing: topological information about the system such as which   atoms are in the same molecule (to be used if the same for all replicas).   This is only used if no value is passed to the argument replica_topology.\nreplica_topology=[nothing for _ in 1:n_replicas]: the topological information for   each replica.\npairwise_inters=(): the pairwise interactions in the system, i.e. interactions   between all or most atom pairs such as electrostatics (to be used if the same for all replicas).   Should be a Tuple or NamedTuple of PairwiseInteractions. This is only used if no   value is passed to the argument replica_pairwise_inters.\nreplica_pairwise_inters=[() for _ in 1:n_replicas]: the pairwise interactions for   each replica.\nspecific_inter_lists=(): the specific interactions in the system, i.e. interactions   between specific atoms such as bonds or angles (to be used if the same for all replicas).   Should be a Tuple or NamedTuple. This is only used if no value is passed to the argument   replica_specific_inter_lists.\nreplica_specific_inter_lists=[() for _ in 1:n_replicas]: the specific interactions in   each replica.\ngeneral_inters=(): the general interactions in the system, i.e. interactions involving   all atoms such as implicit solvent (to be used if the same for all replicas). Each should   implement the AtomsCalculators.jl interface. Should be a Tuple or NamedTuple. This is   only used if no value is passed to the argument replica_general_inters.\nreplica_general_inters=[() for _ in 1:n_replicas]: the general interactions for   each replica.\nconstraints::CN=(): the constraints for bonds and angles in the system (to be used if the same   for all replicas). Should be a Tuple or NamedTuple. This is only used if no value is   passed to the argument replica_constraints.\nreplica_constraints=[() for _ in 1:n_replicas]: the constraints for bonds and angles in each   replica.\nneighbor_finder::NF=NoNeighborFinder(): the neighbor finder used to find   close atoms and save on computation. It is duplicated for each replica.\nreplica_loggers=[() for _ in 1:n_replicas]: the loggers for each replica   that record properties of interest during a simulation.\nexchange_logger::EL=ReplicaExchangeLogger(n_replicas): the logger used to record   the exchange of replicas.\nforce_units::F=u\"kJ * mol^-1 * nm^-1\": the units of force of the system.   Should be set to NoUnits if units are not being used.\nenergy_units::E=u\"kJ * mol^-1\": the units of energy of the system. Should   be set to NoUnits if units are not being used.\nk::K=Unitful.k or Unitful.k * Unitful.Na: the Boltzmann constant, which may be   modified in some simulations. k is chosen based on the energy_units given.\ndata::DA=nothing: arbitrary data associated with the replica system.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.SHAKE_RATTLE","page":"API","title":"Molly.SHAKE_RATTLE","text":"SHAKE_RATTLE(n_atoms, dist_tolerance=1e-8u\"nm\", vel_tolerance=1e-8u\"nm^2 * ps^-1\";\n             dist_constraints=nothing, angle_constraints=nothing,\n             gpu_block_size=128, max_iters=25)\n\nConstrain distances during a simulation using the SHAKE and RATTLE algorithms. Either or both of dist_constraints and angle_constraints must be given.\n\nVelocity constraints will be imposed for simulators that integrate velocities such as VelocityVerlet. See Ryckaert et al. 1977 for SHAKE, Andersen 1983 for RATTLE, Elber et al. 2011 for a derivation of the linear system solved to satisfy the RATTLE algorithm, and Krautler et al. 2000 for the M-SHAKE algorithm.\n\nArguments\n\nn_atoms: number of atoms in the system.\ndist_tolerance=1e-8u\"nm\": the tolerance used to end the iterative procedure when calculating   position constraints, should have the same units as the coordinates.\nvel_tolerance=1e-8u\"nm^2 * ps^-1\": the tolerance used to end the iterative procedure when   calculating velocity constraints, should have the same units as the velocities times the   coordinates.\ndist_constraints=nothing: a vector of DistanceConstraint objects that define the   distance constraints to be applied. If nothing, no distance constraints are applied.\nangle_constraints=nothing: a vector of AngleConstraint objects that define the   angle constraints to be applied. If nothing, no angle constraints are applied.\ngpu_block_size=128: the number of threads per block to use for GPU calculations.\nmax_iters=25: the maximum number of iterations to perform when doing SHAKE. If this   number if iterations is reached, some constraints may not be satisfied.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.ShiftedForceCutoff","page":"API","title":"Molly.ShiftedForceCutoff","text":"ShiftedForceCutoff(dist_cutoff)\n\nCutoff that shifts the force to be continuous at a specified cutoff distance.\n\nbeginaligned\nV_c(r) = begincases\nV(r) - (r-r_c) V(r_c) - V(r_c) r le r_c \n0 r  r_c\nendcases \nF_c(r) = begincases\nF(r) - F(r_c) r le r_c \n0 r  r_c\nendcases\nendaligned\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.ShiftedPotentialCutoff","page":"API","title":"Molly.ShiftedPotentialCutoff","text":"ShiftedPotentialCutoff(dist_cutoff)\n\nCutoff that shifts the potential to be continuous at a specified cutoff distance.\n\nbeginaligned\nV_c(r) = begincases\nV(r) - V(r_c) r le r_c \n0 r  r_c\nendcases \nF_c(r) = begincases\nF(r) r le r_c \n0 r  r_c\nendcases\nendaligned\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.SoftSphere","page":"API","title":"Molly.SoftSphere","text":"SoftSphere(; cutoff, use_neighbors, shortcut, σ_mixing, ϵ_mixing)\n\nThe soft-sphere potential.\n\nThe potential energy is defined as\n\nV(r_ij) = 4varepsilon_ij left(fracsigma_ijr_ijright)^12\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.SpecificForce1Atoms","page":"API","title":"Molly.SpecificForce1Atoms","text":"SpecificForce1Atoms(f1)\n\nForce on one atom arising from an interaction such as a position restraint.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.SpecificForce2Atoms","page":"API","title":"Molly.SpecificForce2Atoms","text":"SpecificForce2Atoms(f1, f2)\n\nForces on two atoms arising from an interaction such as a bond potential.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.SpecificForce3Atoms","page":"API","title":"Molly.SpecificForce3Atoms","text":"SpecificForce3Atoms(f1, f2, f3)\n\nForces on three atoms arising from an interaction such as a bond angle potential.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.SpecificForce4Atoms","page":"API","title":"Molly.SpecificForce4Atoms","text":"SpecificForce4Atoms(f1, f2, f3, f4)\n\nForces on four atoms arising from an interaction such as a torsion potential.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.SteepestDescentMinimizer","page":"API","title":"Molly.SteepestDescentMinimizer","text":"SteepestDescentMinimizer(; <keyword arguments>)\n\nSteepest descent energy minimization.\n\nArguments\n\nstep_size::D=0.01u\"nm\": the initial maximum displacement.\nmax_steps::Int=1000: the maximum number of steps.\ntol::F=1000.0u\"kJ * mol^-1 * nm^-1\": the maximum force below which to   finish minimization.\nlog_stream::L=devnull: stream to print minimization progress to.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.StormerVerlet","page":"API","title":"Molly.StormerVerlet","text":"StormerVerlet(; <keyword arguments>)\n\nThe Störmer-Verlet integrator.\n\nThe velocity calculation is accurate to O(dt).\n\nDoes not currently work with coupling methods that alter the velocity. Does not currently remove the center of mass motion.\n\nArguments\n\ndt::T: the time step of the simulation.\ncoupling::C=NoCoupling(): the coupling which applies during the simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.System","page":"API","title":"Molly.System","text":"System(; <keyword arguments>)\n\nA physical system to be simulated.\n\nProperties unused in the simulation or in analysis can be left with their default values. The minimal required arguments are atoms, coords and boundary. atoms and coords should have the same length, along with velocities and atoms_data if these are provided. This is a sub-type of AbstractSystem from AtomsBase.jl and implements the interface described there.\n\nArguments\n\natoms::A: the atoms, or atom equivalents, in the system. Can be   of any type but should be a bits type if the GPU is used.\ncoords::C: the coordinates of the atoms in the system. Typically a   vector of SVectors of 2 or 3 dimensions.\nboundary::B: the bounding box in which the simulation takes place.\nvelocities::V=zero(coords) * u\"ps^-1\": the velocities of the atoms in the   system.\natoms_data::AD=[]: other data associated with the atoms, allowing the atoms to   be bits types and hence work on the GPU.\ntopology::TO=nothing: topological information about the system such as which   atoms are in the same molecule.\npairwise_inters::PI=(): the pairwise interactions in the system, i.e.   interactions between all or most atom pairs such as electrostatics.   Should be a Tuple or NamedTuple of PairwiseInteractions.\nspecific_inter_lists::SI=(): the specific interactions in the system,   i.e. interactions between specific atoms such as bonds or angles.   Should be a Tuple or NamedTuple.\ngeneral_inters::GI=(): the general interactions in the system,   i.e. interactions involving all atoms such as implicit solvent. Each should   implement the AtomsCalculators.jl interface. Should be a Tuple or NamedTuple.\nconstraints::CN=(): the constraints for bonds and angles in the system.   Should be a Tuple or NamedTuple.\nneighbor_finder::NF=NoNeighborFinder(): the neighbor finder used to find   close atoms and save on computation.\nloggers::L=(): the loggers that record properties of interest during a   simulation.\nforce_units::F=u\"kJ * mol^-1 * nm^-1\": the units of force of the system.   Should be set to NoUnits if units are not being used.\nenergy_units::E=u\"kJ * mol^-1\": the units of energy of the system. Should   be set to NoUnits if units are not being used.\nk::K=Unitful.k or Unitful.k * Unitful.Na: the Boltzmann constant, which may be   modified in some simulations. k is chosen based on the energy_units given.\ndata::DA=nothing: arbitrary data associated with the system.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.System-Tuple{System}","page":"API","title":"Molly.System","text":"System(sys; <keyword arguments>)\n\nConvenience constructor for changing properties in a System.\n\nThe System is returned with the provided keyword arguments modified. Give deepcopy(sys) as the argument to make a new copy of the system.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.System-Union{Tuple{AT}, Tuple{AbstractString, MolecularForceField}} where AT<:AbstractArray","page":"API","title":"Molly.System","text":"System(coordinate_file, force_field; <keyword arguments>)\n\nRead a coordinate file in a file format readable by Chemfiles and apply a force field to it.\n\nAtom names should exactly match residue templates - no searching of residue templates is carried out.\n\nSystem(coordinate_file, topology_file; <keyword arguments>)\nSystem(T, coordinate_file, topology_file; <keyword arguments>)\n\nRead a Gromacs coordinate file and a Gromacs topology file with all includes collapsed into one file.\n\nGromacs file reading should be considered experimental.\n\nArguments\n\nboundary=nothing: the bounding box used for simulation, read from the   file by default.\nvelocities=nothing: the velocities of the atoms in the system, set to   zero by default.\nloggers=(): the loggers that record properties of interest during a   simulation.\nunits::Bool=true: whether to use Unitful quantities.\narray_type=Array: the array type for the simulation, for example   use CuArray or ROCArray for GPU support.\ndist_cutoff=1.0u\"nm\": cutoff distance for long-range interactions.\ndist_buffer=0.2u\"nm\": distance added to dist_cutoff when calculating   neighbors every few steps. Not relevant if GPUNeighborFinder is   used since the neighbors are calculated each step.\nconstraints=:none: which constraints to apply during the simulation, options   are :none, :hbonds (bonds involving hydrogen), :allbonds and :hangles   (all bonds plus H-X-H and H-O-X angles). Note that not all options may be   supported depending on the bonding topology.\nrigid_water=false: whether to constrain the bonds and angle in water   molecules. Applied on top of constraints, so constraints=:hangles and   rigid_water=false gives rigid water.\nnonbonded_method=:none: method for long range interaction summation,   options are :none (short range only), :cutoff (reaction field method),   :pme (particle mesh Ewald summation) and :ewald (Ewald summation, slow).\newald_error_tol=0.0005: the error tolerance for Ewald summation, used when   nonbonded_method is :pme or :ewald.\napproximate_pme=true: whether to use a fast approximation to the erfc   function, used when nonbonded_method is :pme.\ncenter_coords::Bool=true: whether to center the coordinates in the   simulation box.\nneighbor_finder_type: which neighbor finder to use, default is   CellListMapNeighborFinder on CPU, GPUNeighborFinder   on CUDA compatible GPUs and DistanceNeighborFinder on non-CUDA   compatible GPUs.\ndata=nothing: arbitrary data associated with the system.\nimplicit_solvent=:none: the implicit solvent model to use, options are   :none, :obc1, :obc2 and :gbn2.\nkappa=0.0u\"nm^-1\": the kappa value for the implicit solvent model if one   is used.\ndisulfide_bonds=true: wether or not to look for disulfide bonds between CYS   residues in the structure file and add them to the topology. Uses geometric   constraints to define them.\ngrad_safe=false: should be set to true if the system is going to be used   with Enzyme.jl and nonbonded_method is :pme.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.System-Union{Tuple{AtomsBase.AbstractSystem{D}}, Tuple{D}} where D","page":"API","title":"Molly.System","text":"System(abstract_system; <keyword arguments>)\n\nConvert an AtomsBase AbstractSystem to a Molly System.\n\nThe keyword arguments force_units and energy_units should be set as appropriate. Other keyword arguments are the same as for the main System constructor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.System-Union{Tuple{SimpleCrystals.Crystal{D, A, B} where {A, B<:(AbstractVector{<:SimpleCrystals.Atom{D}})}}, Tuple{D}} where D","page":"API","title":"Molly.System","text":"System(crystal; <keyword arguments>)\n\nConstruct a System from a SimpleCrystals.jl Crystal struct.\n\nProperties unused in the simulation or in analysis can be left with their default values. atoms, atoms_data, coords and boundary are automatically calculated from the Crystal struct. Extra atom paramaters like σ have to be added manually after construction using the convenience constructor System(sys; <keyword arguments>).\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.TemperatureREMD","page":"API","title":"Molly.TemperatureREMD","text":"TemperatureREMD(; <keyword arguments>)\n\nA simulator for a parallel temperature replica exchange MD (T-REMD) simulation on a ReplicaSystem.\n\nSee Sugita and Okamoto 1999. The corresponding ReplicaSystem should have the same number of replicas as the number of temperatures in the simulator. When calling simulate!, the assign_velocities keyword argument determines whether to assign random velocities at the appropriate temperature for each replica.\n\nArguments\n\ndt::DT: the time step of the simulation.\ntemperatures::TP: the temperatures corresponding to the replicas.\nsimulators::ST: individual simulators for simulating each replica.\nexchange_time::ET: the time interval between replica exchange attempts.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.ThermoState","page":"API","title":"Molly.ThermoState","text":"ThermoState(name::AbstractString, β, p, system)\nThermoState(system::System, β, p; name::Union{Nothing, AbstractString}=nothing)\n\nThermodynamic state wrapper carrying inverse temperature β = 1/kBT, pressure p, and the System used to evaluate energies.\n\nFields:\n\nname::String - label for the state.\nβ - inverse temperature with units compatible with 1/system.energy_units.\np - pressure Quantity or nothing.\nsystem::System - simulation system used to compute potential energy.\n\nThe second constructor checks unit consistency for β and p and sets a default name when not provided.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.TimeCorrelationLogger","page":"API","title":"Molly.TimeCorrelationLogger","text":"TimeCorrelationLogger(observableA::Function, observableB::Function,\n                        TA::DataType, TB::DataType,\n                        observable_length::Integer, n_correlation::Integer)\n\nA time correlation logger.\n\nEstimates statistical correlations of normalized form\n\nC(t)=fraclangle A_tcdot B_0rangle -langle Aranglecdot langle Branglesqrtlangle A^2ranglelangle B^2rangle\n\nor unnormalized form\n\nC(t)=langle A_tcdot B_0rangle -langle A ranglecdot langle Brangle\n\nThese can be used to estimate statistical error, or to compute transport coefficients from Green-Kubo type formulas. A and B are observables, functions of the form observable(sys::System, neighbors; n_threads::Integer). The return values of A and B can be of scalar or vector type (including Vector{SVector{...}}, like positions or velocities) and must implement dot.\n\nn_correlation should typically be chosen so that dt * n_correlation > t_corr, where dt is the simulation timestep and t_corr is the decorrelation time for the considered system and observables. For the purpose of numerical stability, the logger internally records sums instead of running averages. The normalized and unnormalized form of the correlation function can be retrieved through values(logger::TimeCorrelationLogger; normalize::Bool).\n\nArguments\n\nobservableA::Function: the function corresponding to observable A.\nobservableB::Function: the function corresponding to observable B.\nTA::DataType: the type returned by observableA, supporting zero(TA).\nTB::DataType: the type returned by observableB, supporting zero(TB).\nobservable_length::Integer: the length of the observables if they are   vectors, or 1 if they are scalar-valued.\nn_correlation::Integer: the length of the computed correlation vector.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.TrajectoryWriter","page":"API","title":"Molly.TrajectoryWriter","text":"TrajectoryWriter(n_steps, filepath; format=\"\", correction=:pbc, atom_inds=[],\n                 excluded_res=String[], write_velocities=false, write_boundary=true)\n\nWrite 3D structures to a file throughout a simulation.\n\nUses Chemfiles.jl to write to one of a variety of formats including DCD, XTC, PDB, CIF, MOL2, SDF, TRR and XYZ. The full list of file formats can be found in the Chemfiles docs. By default the format is guessed from the file extension but it can also be given as a string, e.g. format=\"DCD\". BioStructures.jl is used to write to the PDB format.\n\nThe atom indices to be written can be given as a list or range to atom_inds, with all atoms being written by default. Residue names to be excluded can be given as excluded_res. Velocities can be written in addition to coordinates by setting write_velocities=true. Chemfiles does not support writing velocities to all file formats. The correction to be applied to the molecules is chosen with correction. :pbc, the default, keeps molecules whole, whereas :wrap wraps all atoms inside the simulation box regardless of connectivity.\n\nThe System should have atoms_data defined, and topology if bonding information is required. The file will be appended to, so should be deleted before simulation if it already exists.\n\nNot compatible with 2D systems. For the PDB format, the box size for the CRYST1 record is taken from the first snapshot; different box sizes at later snapshots will not be recorded. The CRYST1 record is not written for infinite boundaries.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.TreeNeighborFinder","page":"API","title":"Molly.TreeNeighborFinder","text":"TreeNeighborFinder(; eligible, dist_cutoff, special, n_steps)\n\nFind close atoms by distance using a tree search.\n\nCan not be used if one or more dimensions has infinite boundaries. Can not be used with TriclinicBoundary.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.TriclinicBoundary","page":"API","title":"Molly.TriclinicBoundary","text":"TriclinicBoundary(v1, v2, v3; approx_images=true)\nTriclinicBoundary(SVector(v1, v2, v3); approx_images=true)\nTriclinicBoundary(SVector(l1, l2, l3), SVector(α, β, γ); approx_images=true)\nTriclinicBoundary(arr; approx_images=true)\n\nTriclinic 3D bounding box defined by 3 SVector{3} basis vectors or basis vector lengths and angles α/β/γ in radians.\n\nThe first basis vector must point along the x-axis and the second must lie in the xy plane. An approximation is used to find the closest periodic image when using the minimum image convention. The approximation is correct for distances shorter than half the shortest box height/width. Setting the keyword argument approx_images to false means the exact closest image is found, which is slower.\n\nNot currently compatible with infinite boundaries.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.UreyBradley","page":"API","title":"Molly.UreyBradley","text":"UreyBradley(; kangle, θ0, kbond, r0)\n\nAn interaction between three atoms consisting of a harmonic bond angle and a harmonic bond between the outer atoms.\n\nθ0 is in radians. The second atom is the middle atom. The potential energy is defined as\n\nV(theta r) = frac12 k_a (theta - theta_0)^2 + frac12 k_b (r - r_0)^2\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.VelocityRescaleThermostat","page":"API","title":"Molly.VelocityRescaleThermostat","text":"VelocityRescaleThermostat(temperature, coupling_const; n_steps=1)\n\nThe stochastic velocity rescaling thermostat.\n\nSee Bussi et al. 2007. In brief, acts like the BerendsenThermostat but adds an stochastic term, allowing correct sampling of isothermal ensembles.\n\nLet Δt be the simulation timestep, Nf the kinetic DOFs used to calculate the instantaneous temperature of the system. Then, K = frac12 cdot sum m cdot v^2 is the current kinetic energy, and K̄ = frac12 Nf k_B T_0 is the target kinetic energy for a reference temperature T_0.\n\nDefine c = e^-Δtτ. Draw R sim 𝒩(01) and S sim chi^2_Nf-1. Then\n\nlambda^2 = c + (1-c) cdot fracbar KN_f K cdot (R^2 + S)+\n            2 cdot sqrtc(1-c) fracbar KN_f K cdot R\nqquad v = lambdav \n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.VelocityVerlet","page":"API","title":"Molly.VelocityVerlet","text":"VelocityVerlet(; <keyword arguments>)\n\nThe velocity Verlet integrator.\n\nArguments\n\ndt::T: the time step of the simulation.\ncoupling::C=NoCoupling(): the coupling which applies during the simulation.\nremove_CM_motion=1: remove the center of mass motion every this number of steps,   set to false or 0 to not remove center of mass motion.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.Verlet","page":"API","title":"Molly.Verlet","text":"Verlet(; <keyword arguments>)\n\nThe leapfrog Verlet integrator.\n\nThis is a leapfrog integrator, so the velocities are offset by half a time step behind the positions.\n\nArguments\n\ndt::T: the time step of the simulation.\ncoupling::C=NoCoupling(): the coupling which applies during the simulation.\nremove_CM_motion=1: remove the center of mass motion every this number of steps,   set to false or 0 to not remove center of mass motion.\n\n\n\n\n\n","category":"type"},{"location":"api/#Molly.Yukawa","page":"API","title":"Molly.Yukawa","text":"Yukawa(; cutoff, use_neighbors, weight_special, coulomb_const, kappa)\n\nThe Yukawa electrostatic interaction between two atoms.\n\nThe potential energy is defined as\n\nV(r_ij) = fracq_i q_j4 pi varepsilon_0 r_ij exp(-kappa r_ij)\n\nand the force on each atom by\n\nF(r_ij) = fracq_i q_j4 pi varepsilon_0 r_ij^2 exp(-kappa r_ij)left(kappa r_ij + 1right) vecr_ij\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.values-Tuple{GeneralObservableLogger}","page":"API","title":"Base.values","text":"values(logger)\nvalues(logger::TimeCorrelationLogger; normalize::Bool=true)\nvalues(logger::AverageObservableLogger; std::Bool=true)\n\nAccess the stored observations in a logger.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.AutoCorrelationLogger-Tuple{Any, Any, Integer, Integer}","page":"API","title":"Molly.AutoCorrelationLogger","text":"AutoCorrelationLogger(observable::Function, TA::DataType,\n                        observable_length::Integer, n_correlation::Integer)\n\nAn autocorrelation logger, equivalent to a TimeCorrelationLogger in the case that observableA == observableB.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.CoordinatesLogger-Tuple{Any, Integer}","page":"API","title":"Molly.CoordinatesLogger","text":"CoordinatesLogger(n_steps; dims=3)\nCoordinatesLogger(T, n_steps; dims=3)\n\nLog the coordinates throughout a simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.DensityLogger-Tuple{Type, Integer}","page":"API","title":"Molly.DensityLogger","text":"DensityLogger(n_steps)\nDensityLogger(T, n_steps)\n\nLog the density of a system throughout a simulation.\n\nNot compatible with infinite boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.ForcesLogger-Tuple{Any, Integer}","page":"API","title":"Molly.ForcesLogger","text":"ForcesLogger(n_steps; dims=3)\nForcesLogger(T, n_steps; dims=3)\n\nLog the forces throughout a simulation.\n\nThe forces are those from the interactions and do not include forces applied by stochastic simulators such as Langevin.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.KineticEnergyLogger-Tuple{Type, Integer}","page":"API","title":"Molly.KineticEnergyLogger","text":"KineticEnergyLogger(n_steps)\nKineticEnergyLogger(T, n_steps)\n\nLog the kinetic_energy of a system throughout a simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.PotentialEnergyLogger-Tuple{Type, Integer}","page":"API","title":"Molly.PotentialEnergyLogger","text":"PotentialEnergyLogger(n_steps)\nPotentialEnergyLogger(T, n_steps)\n\nLog the potential_energy of a system throughout a simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.PressureLogger-Tuple{Type, Integer}","page":"API","title":"Molly.PressureLogger","text":"PressureLogger(n_steps)\nPressureLogger(T, n_steps)\n\nLog the pressure tensor of a system throughout a simulation.\n\nThis should only be used on 3-dimensional systems.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.ScalarPressureLogger-Tuple{Type, Integer}","page":"API","title":"Molly.ScalarPressureLogger","text":"ScalarPressureLogger(n_steps)\nScalarPressureLogger(T, n_steps)\n\nLog the scalar_pressure of a system throughout a simulation.\n\nThis should only be used on 3-dimensional systems.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.ScalarVirialLogger-Tuple{Type, Integer}","page":"API","title":"Molly.ScalarVirialLogger","text":"ScalarVirialLogger(n_steps)\nScalarVirialLogger(T, n_steps)\n\nLog the scalar_virial tensor of a system throughout a simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.TemperatureLogger-Tuple{DataType, Integer}","page":"API","title":"Molly.TemperatureLogger","text":"TemperatureLogger(n_steps)\nTemperatureLogger(T, n_steps)\n\nLog the temperature throughout a simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.TotalEnergyLogger-Tuple{DataType, Any}","page":"API","title":"Molly.TotalEnergyLogger","text":"TotalEnergyLogger(n_steps)\nTotalEnergyLogger(T, n_steps)\n\nLog the total_energy of a system throughout a simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.VelocitiesLogger-Tuple{Any, Integer}","page":"API","title":"Molly.VelocitiesLogger","text":"VelocitiesLogger(n_steps; dims=3)\nVelocitiesLogger(T, n_steps; dims=3)\n\nLog the velocities throughout a simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.VirialLogger-Tuple{Type, Integer}","page":"API","title":"Molly.VirialLogger","text":"VirialLogger(n_steps)\nVirialLogger(T, n_steps)\n\nLog the virial tensor of a system throughout a simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.VolumeLogger-Tuple{Type, Integer}","page":"API","title":"Molly.VolumeLogger","text":"VolumeLogger(n_steps)\nVolumeLogger(T, n_steps)\n\nLog the volume of a system throughout a simulation.\n\nNot compatible with infinite boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.accelerations-Tuple{Any}","page":"API","title":"Molly.accelerations","text":"accelerations(system, neighbors=find_neighbors(system), step_n=0;\n              n_threads=Threads.nthreads())\n\nCalculate the accelerations of all atoms in a system using the pairwise, specific and general interactions and Newton's second law of motion.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.add_position_restraints-Union{Tuple{AT}, Tuple{System{<:Any, AT}, Any}} where AT","page":"API","title":"Molly.add_position_restraints","text":"add_position_restraints(sys, k; atom_selector=is_any_atom, restrain_coords=sys.coords)\n\nReturn a copy of a System with HarmonicPositionRestraints added to restrain the atoms.\n\nThe force constant k can be a single value or an array of equal length to the number of atoms in the system. The atom_selector function takes in each atom and atom data and determines whether to restrain that atom. For example, is_heavy_atom means non-hydrogen atoms are restrained.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.apply_coupling!-Tuple{Any, Any, Union{Tuple, NamedTuple}, Any, Any, Any}","page":"API","title":"Molly.apply_coupling!","text":"apply_coupling!(system, buffers, coupling, simulator, neighbors=nothing, step_n=0;\n                n_threads=Threads.nthreads(), rng=Random.default_rng())\n\nApply a coupler to modify a simulation.\n\nReturns whether the coupling has invalidated the currently stored forces, for example by changing the coordinates. This information is useful for some simulators. If coupling is a tuple or named tuple then each coupler will be applied in turn. Custom couplers should implement this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.apply_loggers!","page":"API","title":"Molly.apply_loggers!","text":"apply_loggers!(system, buffers, neighbors=nothing, step_n=0, run_loggers=true;\n               n_threads=Threads.nthreads(), kwargs...)\n\nRun the loggers associated with a system.\n\nrun_loggers can be true, false or :skipzero, in which case the loggers are not run before the first step. Additional keyword arguments can be passed to the loggers if required. Ignored for gradient calculation during automatic differentiation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.apply_position_constraints!-Tuple{Any, Any}","page":"API","title":"Molly.apply_position_constraints!","text":"apply_position_constraints!(sys, coord_storage)\napply_position_constraints!(sys, coord_storage, vel_storage, dt)\n\nApply the coordinate constraints to the system.\n\nIf vel_storage and dt are provided then velocity constraints are applied as well.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.apply_velocity_constraints!-Tuple{Any}","page":"API","title":"Molly.apply_velocity_constraints!","text":"apply_velocity_constraints!(sys)\n\nApply the velocity constraints to the system.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.array_type-Tuple{AT} where AT","page":"API","title":"Molly.array_type","text":"array_type(sys)\narray_type(arr)\n\nThe array type of a System, ReplicaSystem or array, for example Array for systems on CPU or CuArray for systems on a NVIDIA GPU.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.assemble_mbar_inputs-Union{Tuple{T}, Tuple{AT}, Tuple{D}, Tuple{Any, Any, Vector{ThermoState}}} where {D, AT, T}","page":"API","title":"Molly.assemble_mbar_inputs","text":"assemble_mbar_inputs(coords_k, boundaries_k, states;\n                     target_state=nothing, shift=false)\n\nAssemble the reduced potentials matrix u (size N×K) for MBAR from per-window coordinates and boundaries.\n\nArguments\n\ncoords_k::Vector{<:Vector} - subsampled coordinates for each window k.\nboundaries_k::Vector{<:Vector} - subsampled boundaries for each window k (same lengths as coords_k[k]).\nstates::Vector{ThermoState} - thermodynamic states for each window.\n\nKeyword arguments\n\ntarget_state::Union{Nothing, ThermoState} - if set, also compute u_target for that state.\nshift::Bool=false - if true, subtract per-frame row minima from u and return the shifts.\n\nReturns\n\nMBARInput with:\n\nu::Matrix{Float64} - N×K reduced potentials.\nu_target::Union{Vector{Float64}, Nothing} - reduced potential at target_state or nothing.\nN::Vector{Int} - sample counts per window.\nwin_of::Vector{Int} - window index for each frame.\nshifts::Union{Vector{Float64},Nothing} - per-frame shifts when shift=true, else nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.bond_angle-NTuple{4, Any}","page":"API","title":"Molly.bond_angle","text":"bond_angle(coord_i, coord_j, coord_k, boundary)\nbond_angle(vec_ji, vec_jk)\n\nCalculate the bond or pseudo-bond angle in radians between three coordinates or two vectors.\n\nThe angle between j→i and j→k is returned in the range 0 to π.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.box_center-Tuple{Union{CubicBoundary, RectangularBoundary}}","page":"API","title":"Molly.box_center","text":"box_center(boundary)\n\nCalculate the center of a bounding box.\n\nDimensions with infinite length return zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.charge-Tuple{Any}","page":"API","title":"Molly.charge","text":"charge(atom)\n\nThe partial charge of an Atom.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.charges-Tuple{Union{ReplicaSystem, System}}","page":"API","title":"Molly.charges","text":"charges(sys)\n\nThe partial charges of the atoms in a System or ReplicaSystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.check_constraints-Tuple{Any}","page":"API","title":"Molly.check_constraints","text":"check_constraints(sys)\ncheck_constraints(sys, constraints)\n\nCheck whether the coordinates and velocities of a system satisfy the coordinate and velocity constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.check_position_constraints-Tuple{Any}","page":"API","title":"Molly.check_position_constraints","text":"check_position_constraints(sys)\ncheck_position_constraints(sys, constraints)\n\nCheck whether the coordinates of a system satisfy the position constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.check_velocity_constraints-Tuple{Any}","page":"API","title":"Molly.check_velocity_constraints","text":"check_velocity_constraints(sys)\ncheck_velocity_constraints(sys, constraints)\n\nCheck whether the velocities of a system satisfy the velocity constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.density-Tuple{Any}","page":"API","title":"Molly.density","text":"density(sys)\n\nThe density of a System.\n\nReturns zero density for infinite boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.dipole_moment-Tuple{Any}","page":"API","title":"Molly.dipole_moment","text":"dipole_moment(sys)\n\nThe dipole moment μ of a system.\n\nRequires the charges on the atoms to be set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.displacements-Tuple{Any, Any}","page":"API","title":"Molly.displacements","text":"displacements(coords, boundary)\n\nCalculate the pairwise vector displacements of a set of coordinates, accounting for the periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.distances-Tuple{Any, Any}","page":"API","title":"Molly.distances","text":"distances(coords, boundary)\n\nCalculate the pairwise distances of a set of coordinates, accounting for the periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.find_neighbors-Tuple{System}","page":"API","title":"Molly.find_neighbors","text":"find_neighbors(system; n_threads=Threads.nthreads())\nfind_neighbors(system, neighbor_finder, current_neighbors=nothing, step_n=0,\n               force_recompute=false; n_threads=Threads.nthreads())\n\nObtain a list of close atoms in a System.\n\nCustom neighbor finders should implement this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.float_type-Union{Tuple{Union{ReplicaSystem{D, AT, T}, System{D, AT, T}}}, Tuple{T}, Tuple{AT}, Tuple{D}} where {D, AT, T}","page":"API","title":"Molly.float_type","text":"float_type(sys)\nfloat_type(boundary)\n\nThe float type a System, ReplicaSystem or bounding box uses.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.force","page":"API","title":"Molly.force","text":"force(inter, vec_ij, atom_i, atom_j, force_units, special, coord_i, coord_j,\n      boundary, velocity_i, velocity_j, step_n)\nforce(inter, coord_i, boundary, atom_i, force_units, velocity_i, step_n)\nforce(inter, coord_i, coord_j, boundary, atom_i, atom_j, force_units, velocity_i,\n      velocity_j, step_n)\nforce(inter, coord_i, coord_j, coord_k, boundary, atom_i, atom_j, atom_k,\n      force_units, velocity_i, velocity_j, velocity_k, step_n)\nforce(inter, coord_i, coord_j, coord_k, coord_l, boundary, atom_i, atom_j, atom_k,\n      atom_l, force_units, velocity_i, velocity_j, velocity_k, velocity_l, step_n)\n\nCalculate the force between atoms due to a given interaction type.\n\nFor pairwise interactions returns a single force vector and for specific interactions returns a type such as SpecificForce2Atoms. Custom pairwise and specific interaction types should implement this function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.forces-Tuple{Any}","page":"API","title":"Molly.forces","text":"forces(system, neighbors=find_neighbors(system), step_n=0;\n       n_threads=Threads.nthreads())\n\nCalculate the forces on all atoms in a system using the pairwise, specific and general interactions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.forces_virial-Tuple{Any}","page":"API","title":"Molly.forces_virial","text":"forces_virial(system, neighbors=find_neighbors(system), step_n=0;\n              n_threads=Threads.nthreads())\n\nCalculate the forces on all atoms in a system and the virial using the pairwise, specific and general interactions.\n\nReturns a tuple of the forces and the virial. This is faster than calling forces and virial separately.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.hydrodynamic_radius-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{SVector{D, T}}, Any}} where {D, T}","page":"API","title":"Molly.hydrodynamic_radius","text":"hydrodynamic_radius(coords, boundary)\n\nCalculate the hydrodynamic radius of a set of coordinates.\n\nR_hyd is defined by\n\nfrac1R_hyd = frac12N^2sum_i neq j frac1r_ij\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.is_any_atom-Tuple{Any, Any}","page":"API","title":"Molly.is_any_atom","text":"is_any_atom(at, at_data)\n\nPlaceholder function that returns true, used to select any Atom.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.is_heavy_atom-Tuple{Any, Any}","page":"API","title":"Molly.is_heavy_atom","text":"is_heavy_atom(at, at_data)\n\nDetermines whether an Atom is a heavy atom, i.e. any element other than hydrogen.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.is_on_gpu-Union{Tuple{Union{ReplicaSystem{D, AT}, System{D, AT}, AT}}, Tuple{AT}, Tuple{D}} where {D, AT}","page":"API","title":"Molly.is_on_gpu","text":"is_on_gpu(sys)\nis_on_gpu(arr)\n\nWhether a System, ReplicaSystem or array type is on the GPU.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.iterate_mbar-Tuple{Any, Any, Any}","page":"API","title":"Molly.iterate_mbar","text":"iterate_mbar(u, win_of, N_counts; rtol=1e-8, max_iter=10_000)\n\nSolve the MBAR self-consistent equations, see Shirts and Chodera 2008 Eq C3.\n\nArguments\n\nu::AbstractMatrix - N×K reduced potentials (rows = frames, cols = states).\nwin_of::AbstractVector - length-N vector giving the generating state index per frame.\nN_counts::AbstractVector - length-K sample counts per state.\n\nKeyword arguments\n\nrtol::Float64=1e-8 - relative convergence tolerance.\nmax_iter::Int=10_000 - maximum iterations.\n\nReturns\n\nf::Vector{Float64} - relative free energies per state (gauge-fixed to f[1]=0).\nlogN::Vector{Float64} - log.(N_counts) for reuse downstream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.kinetic_energy-Tuple{Any}","page":"API","title":"Molly.kinetic_energy","text":"kinetic_energy(system; kin_tensor=nothing)\n\nCalculate the kinetic energy of a system.\n\nThe scalar kinetic energy is defined as\n\nK = rmTrleft bfK right\n\nwhere bfK is the kinetic energy tensor:\n\nbfK = frac12 sum_i m_i bfv_i otimes bfv_i\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.kinetic_energy_tensor-Union{Tuple{System{D}}, Tuple{D}} where D","page":"API","title":"Molly.kinetic_energy_tensor","text":"kinetic_energy_tensor(system; kin_tensor=nothing)\n\nCalculate the kinetic energy of a system in its tensorial form.\n\nThe kinetic energy tensor is defined as\n\nbfK = frac12 sum_i m_i bfv_i otimes bfv_i\n\nwhere m_i is the mass and bfv_i is the velocity vector of atom i.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.log_property!","page":"API","title":"Molly.log_property!","text":"log_property!(logger, system, buffers, neighbors=nothing, step_n=0;\n              n_threads=Threads.nthreads(), kwargs...)\n\nLog a property of a system throughout a simulation.\n\nCustom loggers should implement this function. Additional keyword arguments can be passed to the logger if required.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.mass-Tuple{Any}","page":"API","title":"Molly.mass","text":"mass(atom)\n\nThe mass of an Atom.\n\nCustom atom types should implement this function unless they have a mass field defined, which the function accesses by default.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.masses-Tuple{System}","page":"API","title":"Molly.masses","text":"masses(sys)\n\nThe masses of the atoms in a System or ReplicaSystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.maxwell_boltzmann","page":"API","title":"Molly.maxwell_boltzmann","text":"maxwell_boltzmann(atom_mass::Unitful.Mass, temp::Unitful.Temperature,\n                  k::BoltzmannConstUnits=Unitful.k; rng=Random.default_rng())\nmaxwell_boltzmann(atom_mass::MolarMass, temp::Unitful.Temperature,\n                  k_molar::MolarBoltzmannConstUnits=(Unitful.k * Unitful.Na);\n                  rng=Random.default_rng())\nmaxwell_boltzmann(atom_mass::Real, temperature::Real,\n                  k::Real=ustrip(u\"u * nm^2 * ps^-2 * K^-1\", Unitful.k);\n                  rng=Random.default_rng())\n\nGenerate a random velocity along one dimension from the Maxwell-Boltzmann distribution, with optional custom Boltzmann constant.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.mbar_weights-Tuple{AbstractMatrix, Vararg{AbstractVector, 4}}","page":"API","title":"Molly.mbar_weights","text":"mbar_weights(u, u_target, f, N_counts, logN; shifts=nothing, check=true)\n\nCompute MBAR weights for sampled states and for a target state, see Shirts and Chodera 2008 Eq 13.\n\nArguments\n\nu::AbstractMatrix - N×K reduced potentials for sampled states.\nu_target::AbstractVector - length-N reduced potential for the target state.\nf::AbstractVector - length-K relative free energies.\nN_counts::AbstractVector - length-K sample counts per state.\nlogN::AbstractVector - log.(N_counts).\n\nKeyword arguments\n\nshifts::Union{Nothing, AbstractVector}=nothing - per-frame shifts previously   subtracted from u, if any.\ncheck::Bool=true - perform basic normalization checks.\n\nReturns\n\nW::Matrix{Float64} - N×K sampled-state weights.\nw_target::Vector{Float64} - length-N target-state weights.\nlogD::Vector{Float64} - length-N log normalizers used in the weights.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.mbar_weights-Tuple{Molly.MBARInput}","page":"API","title":"Molly.mbar_weights","text":"mbar_weights(mbar_generator::MBARInput)\n\nHigh-level MBAR wrapper that computes free energies and reweighting weights from a pre-assembled MBARInput struct.\n\nArguments\n\nmbar_generator::MBARInput - result from assemble_mbar_inputs containing:\n\nu::AbstractMatrix - reduced potentials (N×K).\nu_target::Union{AbstractVector, Nothing} - reduced potentials at the target state.\nN::AbstractVector - sample counts per state.\nwin_of::AbstractVector - window index for each frame.\nshifts::Union{AbstractVector,Nothing} - per-frame energy shifts (optional).\n\nReturns\n\n(W, w_target, logD) where:\n\nW::Matrix{Float64} - N×K sampled-state weights.\nw_target::Vector{Float64} - target-state weights.\nlogD::Vector{Float64} - per-frame log normalizers.\n\nThis routine runs iterate_mbar to obtain relative free energies F_k and then calls the lower-level mbar_weights(u, u_target, f, N_counts, logN) using the contents of mbar_generator. All internal consistency checks are disabled for speed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.pairwise_force","page":"API","title":"Molly.pairwise_force","text":"pairwise_force(inter, r, params)\n\nCalculate the force magnitude between two atoms separated by distance r due to a pairwise interaction.\n\nThis function is used in force to apply cutoff strategies by calculating the force at different values of r. Consequently, the parameters params should not include terms that depend on distance.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.pairwise_pe","page":"API","title":"Molly.pairwise_pe","text":"pairwise_pe(inter, r, params)\n\nCalculate the potential energy between two atoms separated by distance r due to a pairwise interaction.\n\nThis function is used in potential_energy to apply cutoff strategies by calculating the potential energy at different values of r. Consequently, the parameters params should not include terms that depend on distance.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.place_atoms-Tuple{Integer, Any}","page":"API","title":"Molly.place_atoms","text":"place_atoms(n_atoms, boundary; min_dist=nothing, max_attempts=100, rng=Random.default_rng())\n\nGenerate random coordinates.\n\nObtain n_atoms coordinates in bounding box boundary where no two points are closer than min_dist, accounting for periodic boundary conditions. The keyword argument max_attempts determines the number of failed tries after which to stop placing atoms. Can not be used if one or more dimensions has infinite boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.place_diatomics-Tuple{Integer, Any, Any}","page":"API","title":"Molly.place_diatomics","text":"place_diatomics(n_molecules, boundary, bond_length; min_dist=nothing,\n                max_attempts=100, aligned=false, rng=Random.default_rng())\n\nGenerate random diatomic molecule coordinates.\n\nObtain coordinates for n_molecules diatomics in bounding box boundary where no two points are closer than min_dist and the bond length is bond_length, accounting for periodic boundary conditions. The keyword argument max_attempts determines the number of failed tries after which to stop placing atoms. The keyword argument aligned determines whether the bonds all point the same direction (true) or random directions (false). Can not be used if one or more dimensions has infinite boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.pmf_with_uncertainty-Tuple{AbstractMatrix, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Vector}","page":"API","title":"Molly.pmf_with_uncertainty","text":"pmf_with_uncertainty(u, u_target, f, N_counts, logN, R_k;\n                     shifts=nothing, nbins=nothing, edges=nothing, kBT=nothing,\n                     zero=:min, rmin=nothing, rmax=nothing)\n\nEstimate a 1D PMF along a scalar CV and its large-sample uncertainty using MBAR, see Shirts and Chodera 2008 Eq D8.\n\nArguments\n\nu::AbstractMatrix - N×K reduced potentials.\nu_target::AbstractVector - length-N reduced potentials at the target state.\nf::AbstractVector - length-K relative free energies.\nN_counts::AbstractVector - length-K sample counts.\nlogN::AbstractVector - log.(N_counts).\nR_k::Vector{<:AbstractVector} - CV values per window, concatenating to length N.\n\nKeyword arguments\n\nshifts=nothing - per-frame shifts used on u, if any.\nnbins=nothing, edges=nothing - bin count or explicit bin edges.\nrmin=nothing, rmax=nothing - bounds when edges is omitted.\nzero=:min - PMF gauge: :min or :last.\nkBT=nothing - if set, also return dimensional F_energy = F*kBT.\n\nReturns\n\nPMF struct with:\n\ncenters - the center of the histogram bins used to sample the CV.\nwidths - the width of the histogram bins used to sample the CV.\nedges - the edges of the histogram bins used to sample the CV.\nF - PMF in kBT units.\nF_energy - PMF in energy units, if provided.\nsigma_F - uncertainty of the PMF in kBT units.\nsigma_F_energy - uncertainty of the PMF in energy units, if provided.\np - probability density along the CV.\nvar_p - variance of the probability density along the CV.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.pmf_with_uncertainty-Tuple{AbstractVector, AbstractVector, Vector{ThermoState}, ThermoState, AbstractVector}","page":"API","title":"Molly.pmf_with_uncertainty","text":"pmf_with_uncertainty(coords_k, boundaries_k, states, target_state, CV;\n                     shift=false)\n\nHigh-level PMF wrapper that builds MBAR inputs from trajectories, solves MBAR, and computes the PMF along CV.\n\nArguments\n\ncoords_k::AbstractVector - coordinates per window.\nboundaries_k::AbstractVector - boundaries per window.\nstates::Vector{ThermoState} - thermodynamic states per window.\ntarget_state::ThermoState - state to reweight to.\nCV::AbstractVector - CV values per window.\n\nKeyword arguments\n\nshift::Bool=false - subtract per-frame minima from u for stability.\n\nReturns\n\nSame PMF struct as the lower-level pmf_with_uncertainty.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.potential_energy-Tuple{Any}","page":"API","title":"Molly.potential_energy","text":"potential_energy(system, neighbors=find_neighbors(system), step_n=0;\n                 n_threads=Threads.nthreads())\n\nCalculate the potential energy of a system using the pairwise, specific and general interactions.\n\npotential_energy(inter, vec_ij, atom_i, atom_j, energy_units, special, coord_i, coord_j,\n                 boundary, velocity_i, velocity_j, step_n)\npotential_energy(inter, coord_i, boundary, atom_i, energy_units, velocity_i, step_n)\npotential_energy(inter, coord_i, coord_j, boundary, atom_i, atom_j, energy_units,\n                 velocity_i, velocity_j, step_n)\npotential_energy(inter, coord_i, coord_j, coord_k, boundary, atom_i, atom_j, atom_k,\n                 energy_units, velocity_i, velocity_j, velocity_k, step_n)\npotential_energy(inter, coord_i, coord_j, coord_k, coord_l, boundary, atom_i, atom_j,\n                 atom_k, atom_l, energy_units, velocity_i, velocity_j, velocity_k,\n                 velocity_l, step_n)\n\nCalculate the potential energy due to a given interaction type.\n\nCustom interaction types should implement this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.pressure-Tuple{Any}","page":"API","title":"Molly.pressure","text":"pressure(system, neighbors=find_neighbors(system), step_n=0, buffers=nothing;\n         recompute=true, n_threads=Threads.nthreads())\n\nCalculate the pressure tensor of the system.\n\nThe pressure is defined as\n\nbfP = frac 2 cdot bfK + bfW V\n\nwhere V is the system volume, bfK is the kinetic energy tensor and bfW is the virial tensor.\n\nTo calculate the scalar pressure, see scalar_pressure.\n\nNot compatible with infinite boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.radius_gyration-Tuple{Any, Any}","page":"API","title":"Molly.radius_gyration","text":"radius_gyration(coords, atoms)\n\nCalculate the radius of gyration of a set of coordinates.\n\nAssumes the coordinates do not cross the bounding box, i.e. all coordinates correspond to the same periodic image.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.random_coord-Union{Tuple{CubicBoundary{3, T}}, Tuple{T}} where T","page":"API","title":"Molly.random_coord","text":"random_coord(boundary; rng=Random.default_rng())\n\nGenerate a random coordinate uniformly distributed within a bounding box.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.random_normal_translation!-Union{Tuple{System{D, <:Any, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"API","title":"Molly.random_normal_translation!","text":"random_normal_translation!(sys::System; shift_size=oneunit(eltype(eltype(sys.coords))),\n                           rng=Random.default_rng())\n\nPerforms a random translation of the coordinates of a randomly selected atom in a System.\n\nThe translation is generated using a uniformly chosen direction and length selected from the standard normal distribution i.e. with mean 0 and standard deviation 1, scaled by shift_size which should have appropriate length units.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.random_uniform_translation!-Union{Tuple{System{D, <:Any, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"API","title":"Molly.random_uniform_translation!","text":"random_uniform_translation!(sys::System; shift_size=oneunit(eltype(eltype(sys.coords))),\n                            rng=Random.default_rng())\n\nPerforms a random translation of the coordinates of a randomly selected atom in a System.\n\nThe translation is generated using a uniformly selected direction and uniformly selected length in range [0, 1) scaled by shift_size which should have appropriate length units.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.random_velocities!-Tuple{Any, Any}","page":"API","title":"Molly.random_velocities!","text":"random_velocities!(sys, temp; rng=Random.default_rng())\nrandom_velocities!(vels, sys, temp; rng=Random.default_rng())\n\nSet the velocities of a System, or a vector, to random velocities generated from the Maxwell-Boltzmann distribution.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.random_velocities-Tuple{AtomsBase.AbstractSystem{3}, Any}","page":"API","title":"Molly.random_velocities","text":"random_velocities(sys, temp; rng=Random.default_rng())\n\nGenerate random velocities from the Maxwell-Boltzmann distribution for a System.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.random_velocity-Tuple{Union{Level{L, S, Quantity{T, 𝐌, U}} where {T, U, L, S}, Level{L, S, Quantity{T, 𝐌 𝐍^-1, U}} where {T, U, L, S}, Quantity{T, 𝐌} where T, Quantity{T, 𝐌 𝐍^-1} where T}, Union{Quantity{T, 𝚯, U}, Level{L, S, Quantity{T, 𝚯, U}} where {L, S}} where {T, U}}","page":"API","title":"Molly.random_velocity","text":"random_velocity(atom_mass::Union{Unitful.Mass, MolarMass}, temp::Unitful.Temperature;\n                dims=3, rng=Random.default_rng())\nrandom_velocity(atom_mass::Union{Unitful.Mass, MolarMass}, temp::Unitful.Temperature,\n                k::Union{BoltzmannConstUnits, MolarBoltzmannConstUnits};\n                dims=3, rng=Random.default_rng())\nrandom_velocity(atom_mass::Real, temp::Real, k::Real=ustrip(u\"u * nm^2 * ps^-2 * K^-1\", Unitful.k);\n                dims=3, rng=Random.default_rng())\n\nGenerate a random velocity from the Maxwell-Boltzmann distribution, with optional custom Boltzmann constant.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.rdf","page":"API","title":"Molly.rdf","text":"rdf(coords, boundary; npoints=200)\n\nCalculate the radial distribution function of a set of coordinates.\n\nThis function is only available when KernelDensity is imported. This describes how density varies as a function of distance from each atom. Returns a list of distance bin centers and a list of the corresponding densities.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.read_frame!-Union{Tuple{T}, Tuple{AT}, Tuple{D}, Tuple{EnsembleSystem{<:System{D, AT, T}}, Integer}} where {D, AT, T}","page":"API","title":"Molly.read_frame!","text":"read_frame!(ens_sys::EnsembleSystem, frame_idx::Integer)\n\nRead a frame from an EnsembleSystem and return a System representing the frame.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.remd_exchange!-Tuple{ReplicaSystem, TemperatureREMD, Integer, Integer}","page":"API","title":"Molly.remd_exchange!","text":"remd_exchange!(sys, sim, n, m; n_threads=Threads.nthreads(), rng=Random.default_rng())\n\nAttempt an exchange of replicas n and m in a ReplicaSystem during a REMD simulation.\n\nSuccessful exchanges should exchange coordinates and velocities as appropriate. Returns acceptance quantity Δ and a Bool indicating whether the exchange was successful.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.remove_CM_motion!-Tuple{Any}","page":"API","title":"Molly.remove_CM_motion!","text":"remove_CM_motion!(system)\n\nRemove the center of mass motion from a System.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.rmsd-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{SVector{D, T}}, AbstractArray{SVector{D, T}}}} where {D, T}","page":"API","title":"Molly.rmsd","text":"rmsd(coords_1, coords_2)\n\nCalculate the root-mean-square deviation (RMSD) of two sets of 3D coordinates after superimposition by the Kabsch algorithm.\n\nAssumes the coordinates do not cross the bounding box, i.e. all coordinates in each set correspond to the same periodic image.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.scalar_pressure-Tuple{Any}","page":"API","title":"Molly.scalar_pressure","text":"scalar_pressure(system, neighbors=find_neighbors(system), step_n=0, buffers=nothing;\n                recompute=true, n_threads=Threads.nthreads())\n\nCalculate the pressure of the system as a scalar.\n\nThis is the trace of the pressure tensor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.scalar_virial-Tuple{Any}","page":"API","title":"Molly.scalar_virial","text":"scalar_virial(system, neighbors=find_neighbors(system), step_n=0;\n              n_threads=Threads.nthreads())\n\nCalculate the virial of the system as a scalar.\n\nThis is the trace of the virial tensor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.scale_boundary-Tuple{CubicBoundary, Any}","page":"API","title":"Molly.scale_boundary","text":"scale_boundary(boundary, scale_factor)\n\nScale the sides of a bounding box by a scaling factor.\n\nThe scaling factor can be a single number or a SVector of the appropriate number of dimensions corresponding to the scaling factor for each axis. For a 3D bounding box the volume scales as the cube of the scaling factor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.scale_coords!-Union{Tuple{D}, Tuple{AT}, Tuple{System{<:Any, AT}, SMatrix{D, D}}} where {AT, D}","page":"API","title":"Molly.scale_coords!","text":"scale_coords!(sys::System{<:Any, AT}, μ::SMatrix{D,D};\n              rotate::Bool=true,\n              ignore_molecules::Bool=false,\n              scale_velocities::Bool=false)\n\nRigid-molecular barostat update with optional rotation.\n\nBox:        B′ = μ * B\nPositions:  r′ = μ * r  (implemented via COM affine + optional rotation of internal offsets)\nVelocities: v′ = μ⁻¹ * v  (applied when scale_velocities=true)\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.simulate!-Tuple{Any, SteepestDescentMinimizer}","page":"API","title":"Molly.simulate!","text":"simulate!(system, simulator, n_steps; <keyword arguments>)\nsimulate!(system, simulator; <keyword arguments>)\n\nRun a simulation on a system according to the rules of the given simulator.\n\nCustom simulators should implement this function. Constraints are applied during minimization, which can lead to issues.\n\nArguments\n\nn_threads=Threads.nthreads(): the number of threads to run the simulation on, only   relevant when running on CPU.\nrun_loggers: whether to run the loggers during the simulation. Can be true, false   or :skipzero, in which case the loggers are not run before the first step. run_loggers   is true by default except for SteepestDescentMinimizer, where it is false.\nrng=Random.default_rng(): the random number generator used for the simulation. Setting   this allows reproducible stochastic simulations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.simulate_remd!-Tuple{ReplicaSystem, Any, Integer}","page":"API","title":"Molly.simulate_remd!","text":"simulate_remd!(sys, remd_sim, n_steps; n_threads=Threads.nthreads(),\n               run_loggers=true, rng=Random.default_rng())\n\nRun a REMD simulation on a ReplicaSystem using a REMD simulator.\n\nNot currently compatible with interactions that depend on step number.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.statistical_inefficiency-Tuple{AbstractVector}","page":"API","title":"Molly.statistical_inefficiency","text":"statistical_inefficiency(series::AbstractVector; maxlag::Union{Nothing, Int}=nothing)\n\nIntegrated autocorrelation time estimator with IPS truncation and finite-sample taper.\n\nReturns a StatisticalInefficiency struct with:\n\ninefficiency: statistical inefficiency\nstride: ceil(Int, g)\ninput_length: input length\neffective_size: floor(N / stride)\nlag: truncation lag used\n\nNotes:\n\nUses initial positive sequence (IPS) on paired lags to choose L.\nUses normalized ACF of the mean-removed series.\nIncludes the (1 - τ/N) taper in the sum.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.temperature-Union{Tuple{System{D}}, Tuple{D}} where D","page":"API","title":"Molly.temperature","text":"temperature(system; kin_tensor=nothing, recompute=true)\n\nCalculate the temperature of a system from the kinetic energy of the atoms.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.torsion_angle-NTuple{5, Any}","page":"API","title":"Molly.torsion_angle","text":"torsion_angle(coord_i, coord_j, coord_k, coord_l, boundary)\ntorsion_angle(vec_ij, vec_jk, vec_kl)\n\nCalculate the torsion angle in radians defined by four coordinates or three vectors.\n\nThe angle between the planes defined by atoms (i, j, k) and (j, k, l) is returned in the range -π to π.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.total_energy-Tuple{Any}","page":"API","title":"Molly.total_energy","text":"total_energy(system, neighbors=find_neighbors(sys); n_threads=Threads.nthreads())\n\nCalculate the total energy of a system as the sum of the kinetic_energy and the potential_energy.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.use_neighbors-Tuple{Any}","page":"API","title":"Molly.use_neighbors","text":"use_neighbors(inter)\n\nWhether a pairwise interaction uses the neighbor list, default false.\n\nCustom pairwise interactions can define a method for this function. For built-in interactions such as LennardJones this function accesses the use_neighbors field of the struct.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.ustrip_vec-Tuple","page":"API","title":"Molly.ustrip_vec","text":"ustrip_vec(x)\nustrip_vec(u, x)\n\nBroadcasted form of ustrip from Unitful.jl, allowing e.g. ustrip_vec.(coords).\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.vector-Tuple{Any, Any, CubicBoundary}","page":"API","title":"Molly.vector","text":"vector(c1, c2, boundary)\n\nDisplacement between two coordinate values from c1 to c2, accounting for periodic boundary conditions.\n\nThe minimum image convention is used, so the displacement is to the closest version of the coordinates accounting for the periodic boundaries. For the TriclinicBoundary an approximation is used to find the closest version by default.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.vector_1D-Tuple{Any, Any, Any}","page":"API","title":"Molly.vector_1D","text":"vector_1D(c1, c2, side_length)\n\nDisplacement between two 1D coordinate values from c1 to c2, accounting for periodic boundary conditions in a CubicBoundary or RectangularBoundary.\n\nThe minimum image convention is used, so the displacement is to the closest version of the coordinate accounting for the periodic boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.virial-Tuple{Any}","page":"API","title":"Molly.virial","text":"virial(system, neighbors=find_neighbors(system), step_n=0;\n       n_threads=Threads.nthreads())\n\nCalculate the virial tensor of the system.\n\nThe virial, in its most general form, is defined as:\n\nbfW = sum_i bfr_i otimes bff_i\n\nwhere bfr_i and bff_i are the position and force vectors, respectively, acting on the i^th atom. In Molly.jl, we implement the virial definition used in LAMMPS, and take into account pairwise and specific interactions, as well as the K-space contribution of the Ewald and PME methods, computed as indicated in the Essmann et al. 1995. Contributions from constraints are ignored.\n\nTo calculate the scalar virial, see scalar_virial.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.visualize","page":"API","title":"Molly.visualize","text":"visualize(coord_logger, boundary, out_filepath; <keyword arguments>)\n\nVisualize a simulation as an animation.\n\nThis function is only available when GLMakie is imported. It can take a while to run, depending on the length of the simulation and the number of atoms.\n\nArguments\n\nconnections=Tuple{Int, Int}[]: pairs of atoms indices to link with bonds.\nconnection_frames: the frames in which bonds are shown. Should be a list of   the same length as the number of frames, where each item is a list of   Bools of the same length as connections. Defaults to always true.\ntrails::Integer=0: the number of preceding frames to show as transparent   trails.\nframerate::Integer=30: the frame rate of the animation.\ncolor=:purple: the color of the atoms. Can be a single color or a list of   colors of the same length as the number of atoms.\nconnection_color=:orange: the color of the bonds. Can be a single color or a   list of colors of the same length as connections.\nmarkersize=0.05: the size of the atom markers, in the units of the data.\nlinewidth=2.0: the width of the bond lines.\ntransparency=true: whether transparency is active on the plot.\nshow_boundary::Bool=true: whether to show the bounding box as lines.\nboundary_linewidth=2.0: the width of the boundary lines.\nboundary_color=:black: the color of the boundary lines.\nkwargs...: other keyword arguments are passed to the point plotting   function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Molly.volume-Tuple{Any}","page":"API","title":"Molly.volume","text":"volume(sys)\nvolume(boundary)\n\nCalculate the volume (3D) or area (2D) of a System or bounding box.\n\nReturns infinite volume for infinite boundaries.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.wrap_coord_1D-Tuple{Any, Any}","page":"API","title":"Molly.wrap_coord_1D","text":"wrap_coord_1D(c, side_length)\n\nEnsure a 1D coordinate is within the bounding box and return the coordinate.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.wrap_coords-Tuple{Any, Union{CubicBoundary, RectangularBoundary}}","page":"API","title":"Molly.wrap_coords","text":"wrap_coords(c, boundary)\n\nEnsure a coordinate is within the bounding box and return the coordinate.\n\n\n\n\n\n","category":"method"},{"location":"api/#Molly.write_structure-Tuple{Any, Any}","page":"API","title":"Molly.write_structure","text":"write_structure(filepath, sys; format=\"\", correction=:pbc, atom_inds=[],\n                excluded_res=String[], write_velocities=false, write_boundary=true)\n\nWrite the 3D structure of a system to a file.\n\nUses Chemfiles.jl to write to one of a variety of formats including DCD, XTC, PDB, CIF, MOL2, SDF, TRR and XYZ. The full list of file formats can be found in the Chemfiles docs. By default the format is guessed from the file extension but it can also be given as a string, e.g. format=\"DCD\". BioStructures.jl is used to write to the PDB format.\n\nThe atom indices to be written can be given as a list or range to atom_inds, with all atoms being written by default. Residue names to be excluded can be given as excluded_res. Velocities can be written in addition to coordinates by setting write_velocities=true. Chemfiles does not support writing velocities to all file formats. The correction to be applied to the molecules is chosen with correction. :pbc, the default, keeps molecules whole, whereas :wrap wraps all atoms inside the simulation box regardless of connectivity.\n\nThe System should have atoms_data defined, and topology if bonding information is required. The file will be overwritten if it already exists.\n\nNot compatible with 2D systems. The CRYST1 record is not written for infinite boundaries.\n\n\n\n\n\n","category":"method"},{"location":"publications/#Publications","page":"Publications","title":"Publications","text":"If you use Molly, please cite the following paper (bib entry here):\n\nGreener JG. Differentiable simulation to develop molecular dynamics force fields for disordered proteins, Chemical Science 15, 4897-4909 (2024)\n\nA paper involving more contributors with further details on the software will be written at some point.\n\nOther papers that use, contribute to or are compatible with Molly are listed below:\n\nMartínez L. CellListMap.jl: Efficient and customizable cell list implementation for calculation of pairwise particle properties within a cutoff, Comput Phys Commun 279, 108452 (2022)\nWitt WC et al. ACEpotentials.jl: A Julia implementation of the atomic cluster expansion, J Chem Phys 159, 164101 (2023)\nBlassel N and Stoltz G. Fixing the Flux: A Dual Approach to Computing Transport Coefficients, Journal of Statistical Physics 191, 17 (2024)\nSpacek R, Monmarché P and Stoltz G. Transient Subtraction: A Control Variate Method for Computing Transport Coefficients, Journal of Statistical Physics 192, 53 (2025)\nWu X, Shang X. Stochastic Norton Dynamics: An Alternative Approach for the Computation of Transport Coefficients in Dissipative Particle Dynamics, arXiv (2025)\nGreener JG. Reversible molecular simulation for training classical and machine learning force field, Proceedings of the National Academy of Sciences 122(22), e2426058122 (2025)","category":"section"},{"location":"related/#Related-software","page":"Related software","title":"Related software","text":"There are many mature packages for molecular simulation. Of particular note here are OpenMM and GROMACS, both of which influenced the implementation of Molly. Molly can be thought of as similar to OpenMM in that it exposes simulation internals in a high-level language, though it is written in one language all the way down. It also aims to be differentiable and work just as well with non-molecular physical simulations, though how much this impacts the ability to reach high simulation speeds remains to be seen.\n\nFor differentiable simulations there are a number of related packages:\n\nJax, M.D.\nTorchMD\nmdgrad\nDMFF\nTime Machine\nDiffTaichi\nDIMOS\n\nIn Julia there are a number of packages related to atomic simulation, some of which are involved with the JuliaMolSim organisation:\n\nAtomsBase.jl\nJuLIP.jl\nCellListMap.jl\nDFTK.jl\nACE.jl\nAtomicGraphNets.jl\nInteratomicPotentials.jl, Atomistic.jl and PotentialLearning.jl from the CESMIX project at MIT\nNBodySimulator.jl, DiffEqPhysics.jl and the SciML ecosystem more broadly","category":"section"},{"location":"development/#Development-documentation","page":"Development","title":"Development documentation","text":"","category":"section"},{"location":"development/#Running-tests","page":"Development","title":"Running tests","text":"The tests will automatically include multithreading and/or GPU tests if multiple threads and/or a CUDA-enabled GPU are available. Errors appearing at the start of the test run due to unavailable backends is expected. test/runtests.jl does not include all the tests, see the test directory for more, though these extra tests do not need to be run for every change. Various environmental variables can be set to modify the tests:\n\nVISTESTS determines whether to run the GLMakie.jl plotting tests which will error on remote systems where a display is not available, default VISTESTS=1.\nGPUTESTS determines whether to run the GPU tests, default GPUTESTS=1.\nDEVICE determines which GPU to run the GPU tests on, default DEVICE=0.\nGROUP can be used to run a subset of the tests, options All/Protein/Gradients/NotGradients, default GROUP=All.\n\nThe CI run does not carry out all tests - for example the GPU tests are not run - and this is reflected in the code coverage.","category":"section"},{"location":"development/#Benchmarks","page":"Development","title":"Benchmarks","text":"The benchmark directory contains some benchmarks for the package.","category":"section"},{"location":"examples/#Molly-examples","page":"Examples","title":"Molly examples","text":"The best examples for learning how the package works are in the Molly documentation section. Here we give further examples showing what you can do with the package. Each is a self-contained block of code. Made something cool yourself? Make a PR to add it to this page.","category":"section"},{"location":"examples/#Simulated-annealing","page":"Examples","title":"Simulated annealing","text":"You can change the thermostat temperature of a simulation by changing the simulator. Here we reduce the temperature of a simulation in stages from 300 K to 0 K.\n\nusing Molly\nusing GLMakie\n\ndata_dir = joinpath(dirname(pathof(Molly)), \"..\", \"data\")\nff = MolecularForceField(\n    joinpath(data_dir, \"force_fields\", \"ff99SBildn.xml\"),\n    joinpath(data_dir, \"force_fields\", \"tip3p_standard.xml\"),\n    joinpath(data_dir, \"force_fields\", \"his.xml\"),\n)\n\nsys = System(\n    joinpath(data_dir, \"6mrr_equil.pdb\"),\n    ff;\n    nonbonded_method=:cutoff,\n    loggers=(temp=TemperatureLogger(100),),\n)\n\nminimizer = SteepestDescentMinimizer()\nsimulate!(sys, minimizer)\n\ntemps = [300.0, 200.0, 100.0, 0.0]u\"K\"\nrandom_velocities!(sys, temps[1])\n\nfor temp in temps\n    simulator = Langevin(\n        dt=0.001u\"ps\",\n        temperature=temp,\n        friction=1.0u\"ps^-1\",\n    )\n    simulate!(sys, simulator, 5_000; run_loggers=:skipzero)\nend\n\nf = Figure(size=(600, 400))\nax = Axis(\n    f[1, 1],\n    xlabel=\"Step\",\n    ylabel=\"Temperature\",\n    title=\"Temperature change during simulated annealing\",\n)\nfor (i, temp) in enumerate(temps)\n    lines!(\n        ax,\n        [5000 * i - 5000, 5000 * i],\n        [ustrip(temp), ustrip(temp)],\n        linestyle=\"--\",\n        color=:orange,\n    )\nend\nscatter!(\n    ax,\n    100 .* (1:length(values(sys.loggers.temp))),\n    ustrip.(values(sys.loggers.temp)),\n    markersize=5,\n)\nsave(\"annealing.png\", f)\n\n(Image: Annealing)","category":"section"},{"location":"examples/#Solar-system","page":"Examples","title":"Solar system","text":"Orbits of the four closest planets to the sun can be simulated.\n\nusing Molly\nusing GLMakie\n\n# Using get_body_barycentric_posvel from Astropy\ncoords = [\n    SVector(-1336052.8665050615,  294465.0896030796 ,  158690.88781384667)u\"km\",\n    SVector(-58249418.70233503 , -26940630.286818042, -8491250.752464907 )u\"km\",\n    SVector( 58624128.321813114, -81162437.2641475  , -40287143.05760552 )u\"km\",\n    SVector(-99397467.7302648  , -105119583.06486066, -45537506.29775053 )u\"km\",\n    SVector( 131714235.34070954, -144249196.60814604, -69730238.5084304  )u\"km\",\n]\n\nvelocities = [\n    SVector(-303.86327859262457, -1229.6540090943934, -513.791218405548  )u\"km * d^-1\",\n    SVector( 1012486.9596885007, -3134222.279236384 , -1779128.5093088674)u\"km * d^-1\",\n    SVector( 2504563.6403826815,  1567163.5923297722,  546718.234192132  )u\"km * d^-1\",\n    SVector( 1915792.9709661514, -1542400.0057833872, -668579.962254351  )u\"km * d^-1\",\n    SVector( 1690083.43357355  ,  1393597.7855017239,  593655.0037930267 )u\"km * d^-1\",\n]\n\nbody_masses = [\n    1.989e30u\"kg\",\n    0.330e24u\"kg\",\n    4.87e24u\"kg\" ,\n    5.97e24u\"kg\" ,\n    0.642e24u\"kg\",\n]\n\nboundary = CubicBoundary(1e9u\"km\")\n\n# Convert the gravitational constant to the appropriate units\ninter = Gravity(G=convert(typeof(1.0u\"km^3 * kg^-1 * d^-2\"), Unitful.G))\n\nsys = System(\n    atoms=[Atom(mass=m) for m in body_masses],\n    coords=coords .+ (SVector(5e8, 5e8, 5e8)u\"km\",),\n    boundary=boundary,\n    velocities=velocities,\n    pairwise_inters=(inter,),\n    loggers=(coords=CoordinatesLogger(typeof(1.0u\"km\"), 10),),\n    force_units=u\"kg * km * d^-2\",\n    energy_units=u\"kg * km^2 * d^-2\",\n)\n\nsimulator = Verlet(\n    dt=0.1u\"d\",\n    remove_CM_motion=false,\n)\n\nsimulate!(sys, simulator, 3650) # 1 year\n\nvisualize(\n    sys.loggers.coords,\n    boundary,\n    \"sim_planets.mp4\";\n    trails=5,\n    color=[:yellow, :grey, :orange, :blue, :red],\n    markersize=[0.25, 0.08, 0.08, 0.08, 0.08],\n    transparency=false,\n)\n\n(Image: Planet simulation)","category":"section"},{"location":"examples/#Agent-based-modelling","page":"Examples","title":"Agent-based modelling","text":"Agent-based modelling (ABM) is conceptually similar to molecular dynamics. Julia has Agents.jl for ABM, but Molly can also be used to simulate arbitrary agent-based systems in continuous space. Here we simulate a toy SIR model for disease spread. This example shows how atom properties can be mutable, i.e. change during the simulation, and includes custom forces and loggers (see below for more info).\n\nusing Molly\nusing GLMakie\n\n@enum Status susceptible infected recovered\n\n# Custom atom type\nmutable struct Person\n    i::Int\n    status::Status\n    mass::Float64\n    σ::Float64\n    ϵ::Float64\nend\n\n# Custom pairwise interaction\nstruct SIRInteraction <: PairwiseInteraction\n    dist_infection::Float64\n    prob_infection::Float64\n    prob_recovery::Float64\nend\n\n# Custom force function\nfunction Molly.force(inter::SIRInteraction,\n                        vec_ij,\n                        atom_i,\n                        atom_j,\n                        args...)\n    if (atom_i.status == infected && atom_j.status == susceptible) ||\n                (atom_i.status == susceptible && atom_j.status == infected)\n        # Infect close people randomly\n        r2 = sum(abs2, vec_ij)\n        if r2 < inter.dist_infection^2 && rand() < inter.prob_infection\n            atom_i.status = infected\n            atom_j.status = infected\n        end\n    end\n    # Workaround to obtain a self-interaction\n    if atom_i.i == (atom_j.i - 1)\n        # Recover randomly\n        if atom_i.status == infected && rand() < inter.prob_recovery\n            atom_i.status = recovered\n        end\n    end\n    return zero(vec_ij)\nend\n\n# Custom logger\nfunction fracs_SIR(s::System, args...;  kwargs...)\n    counts_sir = [\n        count(p -> p.status == susceptible, s.atoms),\n        count(p -> p.status == infected   , s.atoms),\n        count(p -> p.status == recovered  , s.atoms)\n    ]\n    return counts_sir ./ length(s)\nend\n\nSIRLogger(n_steps) = GeneralObservableLogger(fracs_SIR, Vector{Float64}, n_steps)\n\ntemp = 1.0\nboundary = RectangularBoundary(10.0)\nn_steps = 1_000\nn_people = 500\nn_starting = 2\natoms = [Person(i, i <= n_starting ? infected : susceptible, 1.0, 0.1, 0.02) for i in 1:n_people]\ncoords = place_atoms(n_people, boundary; min_dist=0.1)\nvelocities = [random_velocity(1.0, temp; dims=2) for i in 1:n_people]\n\nlj = LennardJones(cutoff=DistanceCutoff(1.6), use_neighbors=true)\nsir = SIRInteraction(0.5, 0.06, 0.01) # Does not use the neighbor list\npairwise_inters = (LennardJones=lj, SIR=sir)\nneighbor_finder = DistanceNeighborFinder(\n    eligible=trues(n_people, n_people),\n    n_steps=10,\n    dist_cutoff=2.0,\n)\nsimulator = VelocityVerlet(\n    dt=0.02,\n    coupling=AndersenThermostat(temp, 5.0),\n)\n\nsys = System(\n    atoms=atoms,\n    coords=coords,\n    boundary=boundary,\n    velocities=velocities,\n    pairwise_inters=pairwise_inters,\n    neighbor_finder=neighbor_finder,\n    loggers=(\n        coords=CoordinatesLogger(Float64, 10; dims=2),\n        SIR=SIRLogger(10),\n    ),\n    force_units=NoUnits,\n    energy_units=NoUnits,\n)\n\nsimulate!(sys, simulator, n_steps)\n\nvisualize(sys.loggers.coords, boundary, \"sim_agent.mp4\"; markersize=0.1)\n\n(Image: Agent simulation)\n\nWe can use the logger to plot the fraction of people susceptible, infected and recovered over the course of the simulation:\n\nusing GLMakie\n\nf = Figure()\nax = Axis(f[1, 1], xlabel=\"Snapshot\", ylabel=\"Fraction\")\n\nlines!([l[1] for l in values(sys.loggers.SIR)], label=\"Susceptible\")\nlines!([l[2] for l in values(sys.loggers.SIR)], label=\"Infected\")\nlines!([l[3] for l in values(sys.loggers.SIR)], label=\"Recovered\")\naxislegend()\n\n(Image: Fraction SIR)","category":"section"},{"location":"examples/#Polymer-melt","page":"Examples","title":"Polymer melt","text":"Here we use FENEBond, CosineAngle and LennardJones to simulate interacting polymers. We also analyse the end-to-end polymer distances and chain angles across the trajectory.\n\nusing Molly\nusing GLMakie\nusing Colors\nusing LinearAlgebra\n\n# Simulate 10 polymers each consisting of 6 monomers\nn_polymers = 10\nn_monomers = 6\nn_atoms = n_monomers * n_polymers\nn_bonds_mon = n_monomers - 1\nn_bonds_tot = n_bonds_mon * n_polymers\nn_angles_mon = n_monomers - 2\nn_angles_tot = n_angles_mon * n_polymers\n\nstarting_length = 1.1u\"nm\"\nboundary = CubicBoundary(20.0u\"nm\")\n\n# Random placement of polymer centers at the start\nstart_coords = place_atoms(n_polymers, boundary; min_dist=6.0u\"nm\")\n\n# Polymers start almost completely extended\ncoords = []\nfor pol_i in 1:n_polymers\n    for mon_i in 1:n_monomers\n        push!(coords, start_coords[pol_i] .+ SVector(\n            starting_length * (mon_i - 1 - n_monomers / 2),\n            rand() * 0.1u\"nm\",\n            rand() * 0.1u\"nm\",\n        ))\n    end\nend\ncoords = [coords...] # Ensure the array is concretely typed\n\n# Create FENEBonds between adjacent monomers\nbond_is, bond_js = Int[], Int[]\nfor pol_i in 1:n_polymers\n    for bi in 1:n_bonds_mon\n        push!(bond_is, (pol_i - 1) * n_monomers + bi    )\n        push!(bond_js, (pol_i - 1) * n_monomers + bi + 1)\n    end\nend\n\nfene_k = 250.0u\"kJ * mol^-1 * nm^-2\"\nfene_r0 = 1.6u\"nm\"\nbonds = InteractionList2Atoms(\n    bond_is,\n    bond_js,\n    [FENEBond(k=fene_k, r0=fene_r0, σ=1.0u\"nm\", ϵ=2.5u\"kJ * mol^-1\") for _ in 1:n_bonds_tot],\n)\n\n# Create CosineAngles between adjacent monomers\nangle_is, angle_js, angle_ks = Int[], Int[], Int[]\nfor pol_i in 1:n_polymers\n    for bi in 1:n_angles_mon\n        push!(angle_is, (pol_i - 1) * n_monomers + bi    )\n        push!(angle_js, (pol_i - 1) * n_monomers + bi + 1)\n        push!(angle_ks, (pol_i - 1) * n_monomers + bi + 2)\n    end\nend\n\nangles = InteractionList3Atoms(\n    angle_is,\n    angle_js,\n    angle_ks,\n    [CosineAngle(k=2.0u\"kJ * mol^-1\", θ0=0.0) for _ in 1:n_angles_tot],\n)\n\natoms = [Atom(mass=10.0u\"g/mol\", σ=1.0u\"nm\", ϵ=0.5u\"kJ * mol^-1\") for _ in 1:n_atoms]\n\n# Since we are using a generic pairwise Lennard-Jones potential too we need to\n#   exclude adjacent monomers from the neighbor list\neligible = trues(n_atoms, n_atoms)\nfor pol_i in 1:n_polymers\n    for mon_i in 1:n_bonds_mon\n        i = (pol_i - 1) * n_monomers + mon_i\n        j = (pol_i - 1) * n_monomers + mon_i + 1\n        eligible[i, j] = false\n        eligible[j, i] = false\n    end\nend\n\nlj = LennardJones(\n    cutoff=DistanceCutoff(5.0u\"nm\"),\n    use_neighbors=true,\n)\nneighbor_finder = DistanceNeighborFinder(\n    eligible=eligible,\n    n_steps=10,\n    dist_cutoff=5.5u\"nm\",\n)\n\nsys = System(\n    atoms=atoms,\n    coords=coords,\n    boundary=boundary,\n    pairwise_inters=(lj,),\n    specific_inter_lists=(bonds, angles),\n    neighbor_finder=neighbor_finder,\n    loggers=(coords=CoordinatesLogger(200),),\n)\n\nsim = Langevin(dt=0.002u\"ps\", temperature=300.0u\"K\", friction=1.0u\"ps^-1\")\n\nsimulate!(sys, sim, 100_000)\n\ncolors = distinguishable_colors(n_polymers, [RGB(1, 1, 1), RGB(0, 0, 0)]; dropseed=true)\n\nvisualize(\n    sys.loggers.coords,\n    boundary,\n    \"sim_polymer.gif\";\n    connections=zip(bond_is, bond_js),\n    color=repeat(colors; inner=n_monomers),\n    connection_color=repeat(colors; inner=n_bonds_mon),\n)\n\n(Image: Polymer simulation)\n\nlogged_coords = values(sys.loggers.coords)\nn_frames = length(logged_coords)\n\n# Calculate end-to-end polymer distances for second half of trajectory\nend_to_end_dists = Float64[]\nfor traj_coords in logged_coords[(n_frames ÷ 2):end]\n    for pol_i in 1:n_polymers\n        start_i = (pol_i - 1) * n_monomers + 1\n        end_i = pol_i * n_monomers\n        dist = norm(vector(traj_coords[start_i], traj_coords[end_i], boundary))\n        push!(end_to_end_dists, ustrip(dist))\n    end\nend\n\nf = Figure(size=(600, 400))\nax = Axis(\n    f[1, 1],\n    xlabel=\"End-to-end distance / nm\",\n    ylabel=\"Density\",\n    title=\"End-to-end polymer distance over the trajectory\",\n)\nhist!(ax, end_to_end_dists, normalization=:pdf)\nxlims!(ax, low=0)\nylims!(ax, low=0)\nsave(\"polymer_dist.png\", f)\n\n(Image: Polymer distances)\n\n# Calculate angles to adjacent monomers for second half of trajectory\nchain_angles = Float64[]\nfor traj_coords in logged_coords[(n_frames ÷ 2):end]\n    for pol_i in 1:n_polymers\n        for mon_i in 2:(n_monomers - 1)\n            ang = bond_angle(\n                traj_coords[(pol_i - 1) * n_monomers + mon_i - 1],\n                traj_coords[(pol_i - 1) * n_monomers + mon_i    ],\n                traj_coords[(pol_i - 1) * n_monomers + mon_i + 1],\n                boundary,\n            )\n            push!(chain_angles, rad2deg(ang))\n        end\n    end\nend\n\nf = Figure(size=(600, 400))\nax = Axis(\n    f[1, 1],\n    xlabel=\"Angle with adjacent monomers / degrees\",\n    ylabel=\"Density\",\n    title=\"Chain angles over the trajectory\",\n)\nhist!(ax, chain_angles, normalization=:pdf)\nxlims!(ax, 0, 180)\nylims!(ax, low=0)\nsave(\"polymer_angle.png\", f)\n\n(Image: Polymer angles)","category":"section"},{"location":"examples/#ACE-potentials","page":"Examples","title":"ACE potentials","text":"There is an example of using ACE potentials in Molly via ACEmd.jl.","category":"section"},{"location":"examples/#Python-ASE-calculator","page":"Examples","title":"Python ASE calculator","text":"ASECalculator can be used along with PythonCall.jl to use a Python ASE calculator with Molly. Here we simulate a dipeptide molecule in a vacuum with MACE-OFF23:\n\nusing Molly\nusing PythonCall # Python packages ase and mace need to be installed beforehand\nusing Downloads\n\nDownloads.download(\n    \"https://raw.githubusercontent.com/noeblassel/SINEQSummerSchool2023/main/notebooks/dipeptide_nowater.pdb\",\n    \"dipeptide_nowater.pdb\",\n)\n\ndata_dir = joinpath(dirname(pathof(Molly)), \"..\", \"data\")\nff = MolecularForceField(joinpath(data_dir, \"force_fields\", \"ff99SBildn.xml\"))\nsys = System(\"dipeptide_nowater.pdb\", ff; rename_terminal_res=false)\n\nmc = pyimport(\"mace.calculators\")\nase_calc = mc.mace_off(model=\"medium\", device=\"cuda\")\n\ncalc = ASECalculator(\n    ase_calc=ase_calc,\n    atoms=sys.atoms,\n    coords=sys.coords,\n    boundary=sys.boundary,\n    atoms_data=sys.atoms_data,\n)\n\nsys = System(\n    sys;\n    general_inters=(calc,),\n    loggers=(TrajectoryWriter(20, \"mace_dipeptide.pdb\"),) # Every 10 fs\n)\npotential_energy(sys)\n\nminimizer = SteepestDescentMinimizer(log_stream=stdout)\nsimulate!(sys, minimizer)\n\ntemp = 298.0u\"K\"\nrandom_velocities!(sys, temp)\nsimulator = Langevin(\n    dt=0.0005u\"ps\", # 0.5 fs\n    temperature=temp,\n    friction=1.0u\"ps^-1\",\n)\n\nsimulate!(deepcopy(sys), simulator, 5; run_loggers=false)\n@time simulate!(sys, simulator, 2000)\n\nAnother example using psi4 to get the potential energy of a water molecule:\n\nusing Molly\nusing PythonCall # Python packages ase and psi4 need to be installed beforehand\n\nbuild = pyimport(\"ase.build\")\npsi4 = pyimport(\"ase.calculators.psi4\")\n\npy_atoms = build.molecule(\"H2O\")\nase_calc = psi4.Psi4(\n    atoms=py_atoms,\n    method=\"b3lyp\",\n    basis=\"6-311g_d_p_\",\n)\n\natoms = [Atom(mass=16.0u\"u\"), Atom(mass=1.0u\"u\"), Atom(mass=1.0u\"u\")]\ncoords = SVector{3, Float64}.(eachrow(pyconvert(Matrix, py_atoms.get_positions()))) * u\"Å\"\nboundary = CubicBoundary(100.0u\"Å\")\n\ncalc = ASECalculator(\n    ase_calc=ase_calc,\n    atoms=atoms,\n    coords=coords,\n    boundary=boundary,\n    elements=[\"O\", \"H\", \"H\"],\n)\n\nsys = System(\n    atoms=atoms,\n    coords=coords,\n    boundary=boundary,\n    general_inters=(calc,),\n    energy_units=u\"eV\",\n    force_units=u\"eV/Å\",\n)\n\npotential_energy(sys) # -2080.2391023908813 eV","category":"section"},{"location":"examples/#Density-functional-theory","page":"Examples","title":"Density functional theory","text":"DFTK.jl can be used to calculate forces using density functional theory (DFT), allowing the simulation of quantum systems in Molly. This example uses the DFTK.jl tutorial to simulate two silicon atoms with atomic units. A general interaction is used since the whole force calculation is offloaded to DFTK.jl.\n\nusing Molly\nusing DFTK\nimport AtomsCalculators\n\nstruct DFTKInteraction{L, A}\n    lattice::L\n    atoms::A\nend\n\n# Define lattice and atomic positions\na = 5.431u\"Å\"                 # Silicon lattice constant\nlattice = a / 2 * [[0 1 1.];  # Silicon lattice vectors\n                   [1 0 1.];  # specified column by column\n                   [1 1 0.]];\n\n# Load HGH pseudopotential for Silicon\nSi = ElementPsp(:Si, psp=load_psp(\"hgh/lda/Si-q4\"))\n\n# Specify type of atoms\natoms_dftk = [Si, Si]\n\ndftk_interaction = DFTKInteraction(lattice, atoms_dftk)\n\nfunction AtomsCalculators.forces!(fs, sys, inter::DFTKInteraction; kwargs...)\n    # Select model and basis\n    model = model_LDA(inter.lattice, inter.atoms, sys.coords)\n    kgrid = [4, 4, 4]     # k-point grid (Regular Monkhorst-Pack grid)\n    Ecut = 7              # kinetic energy cutoff\n    basis = PlaneWaveBasis(model; Ecut=Ecut, kgrid=kgrid)\n\n    # Run the SCF procedure to obtain the ground state\n    scfres = self_consistent_field(basis; tol=1e-5)\n\n    fs .+= compute_forces_cart(scfres)\n    return fs\nend\n\natoms = fill(Atom(mass=28.0), 2)\ncoords = [SVector(1/8, 1/8, 1/8), SVector(-1/8, -1/8, -1/8)]\nvelocities = [randn(SVector{3, Float64}) * 0.1 for _ in 1:2]\nboundary = CubicBoundary(Inf)\nloggers = (coords=CoordinatesLogger(Float64, 1),)\n\nsys = System(\n    atoms=atoms,\n    coords=coords,\n    boundary=boundary,\n    velocities=velocities,\n    general_inters=(dftk_interaction,),\n    loggers=loggers,\n    force_units=NoUnits,\n    energy_units=NoUnits,\n)\n\nsimulator = Verlet(dt=0.0005, remove_CM_motion=false)\n\nsimulate!(sys, simulator, 100)\n\nvalues(sys.loggers.coords)[end]\n# 2-element Vector{SVector{3, Float64}}:\n#  [0.12060853912863925, 0.12292128337998731, 0.13100409788691614]\n#  [-0.13352575661477334, -0.11473039463130282, -0.13189544838731393]","category":"section"},{"location":"examples/#Making-and-breaking-bonds","page":"Examples","title":"Making and breaking bonds","text":"There is an example of mutable atom properties in the main documentation, but what if you want to make and break bonds during the simulation? In this case you can use a pairwise interaction to make, break and apply the bonds. The partners of the atom can be stored in the atom type. We make a logger to record when the bonds are present, allowing us to visualize them with the connection_frames keyword argument to visualize (this can take a while to plot).\n\nusing Molly\nusing GLMakie\nusing LinearAlgebra\n\nstruct BondableAtom\n    i::Int\n    mass::Float64\n    σ::Float64\n    ϵ::Float64\n    partners::Set{Int}\nend\n\nstruct BondableInteraction <: PairwiseInteraction\n    prob_formation::Float64\n    prob_break::Float64\n    dist_formation::Float64\n    k::Float64\n    r0::Float64\nend\n\nMolly.use_neighbors(::BondableInteraction) = true\n\nfunction Molly.force(inter::BondableInteraction,\n                        dr,\n                        atom_i,\n                        atom_j,\n                        args...)\n    # Break bonds randomly\n    if atom_j.i in atom_i.partners && rand() < inter.prob_break\n        delete!(atom_i.partners, atom_j.i)\n        delete!(atom_j.partners, atom_i.i)\n    end\n    # Make bonds between close atoms randomly\n    r2 = sum(abs2, dr)\n    if r2 < inter.r0 * inter.dist_formation && rand() < inter.prob_formation\n        push!(atom_i.partners, atom_j.i)\n        push!(atom_j.partners, atom_i.i)\n    end\n    # Apply the force of a harmonic bond\n    if atom_j.i in atom_i.partners\n        c = inter.k * (norm(dr) - inter.r0)\n        fdr = -c * normalize(dr)\n        return fdr\n    else\n        return zero(dr)\n    end\nend\n\nfunction bonds(sys::System, args...; kwargs...)\n    bonds = BitVector()\n    for i in 1:length(sys)\n        for j in 1:(i - 1)\n            push!(bonds, j in sys.atoms[i].partners)\n        end\n    end\n    return bonds\nend\n\nBondLogger(n_steps) = GeneralObservableLogger(bonds, BitVector, n_steps)\n\nn_atoms = 200\nboundary = RectangularBoundary(10.0)\nn_steps = 2_000\ntemp = 1.0\n\natoms = [BondableAtom(i, 1.0, 0.1, 0.02, Set([])) for i in 1:n_atoms]\ncoords = place_atoms(n_atoms, boundary; min_dist=0.1)\nvelocities = [random_velocity(1.0, temp; dims=2) for i in 1:n_atoms]\npairwise_inters = (\n    SoftSphere(cutoff=DistanceCutoff(2.0), use_neighbors=true),\n    BondableInteraction(0.1, 0.1, 1.1, 2.0, 0.1),\n)\nneighbor_finder = DistanceNeighborFinder(\n    eligible=trues(n_atoms, n_atoms),\n    n_steps=10,\n    dist_cutoff=2.2,\n)\nsimulator = VelocityVerlet(\n    dt=0.02,\n    coupling=AndersenThermostat(temp, 5.0),\n)\n\nsys = System(\n    atoms=atoms,\n    coords=coords,\n    boundary=boundary,\n    velocities=velocities,\n    pairwise_inters=pairwise_inters,\n    neighbor_finder=neighbor_finder,\n    loggers=(\n        coords=CoordinatesLogger(Float64, 20; dims=2),\n        bonds=BondLogger(20),\n    ),\n    force_units=NoUnits,\n    energy_units=NoUnits,\n)\n\nsimulate!(sys, simulator, n_steps; n_threads=1) # One thread to ensure thread safety\n\nconnections = Tuple{Int, Int}[]\nfor i in 1:length(sys)\n    for j in 1:(i - 1)\n        push!(connections, (i, j))\n    end\nend\n\nvisualize(\n    sys.loggers.coords,\n    boundary,\n    \"sim_mutbond.mp4\";\n    connections=connections,\n    connection_frames=values(sys.loggers.bonds),\n    markersize=0.1,\n)\n\n(Image: Mutable bond simulation)","category":"section"},{"location":"examples/#Comparing-forces-to-AD","page":"Examples","title":"Comparing forces to AD","text":"The force is the negative derivative of the potential energy with respect to position. MD packages, including Molly, implement the force functions directly for performance. However it is also possible to compute the forces using AD. Here we compare the two approaches for the Lennard-Jones potential and see that they give the same result.\n\nusing Molly\nusing Zygote\nusing GLMakie\n\ninter = LennardJones()\nboundary = CubicBoundary(5.0)\na1, a2 = Atom(σ=0.3, ϵ=0.5), Atom(σ=0.3, ϵ=0.5)\n\nfunction force_direct(dist)\n    c1 = SVector(1.0, 1.0, 1.0)\n    c2 = SVector(dist + 1.0, 1.0, 1.0)\n    vec = vector(c1, c2, boundary)\n    F = force(inter, vec, a1, a2, NoUnits)\n    return F[1]\nend\n\nfunction force_grad(dist)\n    grad = gradient(dist) do dist\n        c1 = SVector(1.0, 1.0, 1.0)\n        c2 = SVector(dist + 1.0, 1.0, 1.0)\n        vec = vector(c1, c2, boundary)\n        potential_energy(inter, vec, a1, a2, NoUnits)\n    end\n    return -grad[1]\nend\n\ndists = collect(0.2:0.01:1.2)\nforces_direct = force_direct.(dists)\nforces_grad = force_grad.(dists)\n\nf = Figure(size=(600, 400))\nax = Axis(\n    f[1, 1],\n    xlabel=\"Distance / nm\",\n    ylabel=\"Force / kJ * mol^-1 * nm^-1\",\n    title=\"Comparing gradients from direct calculation and AD\",\n)\nscatter!(ax, dists, forces_direct, label=\"Direct\", markersize=8)\nscatter!(ax, dists, forces_grad  , label=\"AD\"    , markersize=8, marker='x')\nxlims!(ax, low=0)\nylims!(ax, -6.0, 10.0)\naxislegend()\nsave(\"force_comparison.png\", f)\n\n(Image: Force comparison)","category":"section"},{"location":"examples/#AtomsCalculators.jl-compatibility","page":"Examples","title":"AtomsCalculators.jl compatibility","text":"The AtomsCalculators.jl package provides a consistent interface that allows forces, energies etc. to be calculated with different packages. Calculators can be used with a Molly System by giving them as general_inters during system setup. It is also possible to use a MollyCalculator to calculate properties on AtomsBase.jl systems:\n\nusing Molly\nimport AtomsBase\nusing AtomsBaseTesting\nusing AtomsCalculators\n\nab_sys = AtomsBase.AbstractSystem(\n    make_test_system().system;\n    cell_vectors = [[1.54732, 0.0      , 0.0      ],\n                    [0.0    , 1.4654985, 0.0      ],\n                    [0.0    , 0.0      , 1.7928950]]u\"Å\",\n)\n\ncoul = Coulomb(coulomb_const=2.307e-21u\"kJ*Å\")\ncalc = MollyCalculator(pairwise_inters=(coul,), force_units=u\"kJ/Å\", energy_units=u\"kJ\")\n\nAtomsCalculators.potential_energy(ab_sys, calc)\n\n9.112207692184968e-21 kJ\n\nAtomsCalculators.forces(ab_sys, calc)\n\n5-element Vector{SVector{3, Quantity{Float64, 𝐋 𝐌 𝐓^-2, Unitful.FreeUnits{(Å^-1, kJ), 𝐋 𝐌 𝐓^-2, nothing}}}}:\n [5.052086904272771e-21 kJ Å^-1, 1.0837307191961731e-20 kJ Å^-1, -5.366866699852613e-21 kJ Å^-1]\n [5.252901001053284e-22 kJ Å^-1, -2.3267009382813732e-21 kJ Å^-1, 9.276115314848821e-21 kJ Å^-1]\n [-8.613462805775053e-21 kJ Å^-1, 5.726650141840073e-21 kJ Å^-1, -2.072868074170469e-20 kJ Å^-1]\n [3.0360858013969523e-21 kJ Å^-1, -1.423725639552043e-20 kJ Å^-1, 1.681943212670848e-20 kJ Å^-1]\n [0.0 kJ Å^-1, 0.0 kJ Å^-1, 0.0 kJ Å^-1]\n\nWe can also convert the AtomsBase.jl system to a Molly System:\n\nSystem(ab_sys; force_units=u\"kJ/Å\", energy_units=u\"kJ\")\n\nSystem with 5 atoms, boundary CubicBoundary{Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}}(Quantity{Float64, 𝐋, Unitful.FreeUnits{(Å,), 𝐋, nothing}}[1.54732 Å, 1.4654985 Å, 1.792895 Å])","category":"section"},{"location":"examples/#Testing-GPU-memory-limits","page":"Examples","title":"Testing GPU memory limits","text":"How many atoms can fit on one GPU?\n\nusing Molly\nusing CUDA\n\nfunction check_sim(n_atoms)\n    AT = CuArray\n    atoms = AT([Atom(mass=10.0f0u\"g/mol\", charge=0.0f0, σ=0.001f0u\"nm\", ϵ=0.1f0u\"kJ * mol^-1\")\n                for i in 1:n_atoms])\n    V = n_atoms * 0.013f0u\"nm^3\" # Sensible density\n    box_side = cbrt(V)\n    boundary = CubicBoundary(box_side)\n    coords = AT(rand(SVector{3, Float32}, n_atoms) .* box_side)\n    velocities = zero(coords) * u\"ps^-1\"\n    neighbor_finder = GPUNeighborFinder(\n        eligible=AT(trues(n_atoms, n_atoms)),\n        dist_cutoff=1.0f0u\"nm\",\n    )\n    pis = (LennardJones(cutoff=DistanceCutoff(1.0f0u\"nm\"), use_neighbors=true),)\n    sys = System(\n        atoms=atoms,\n        coords=coords,\n        boundary=boundary,\n        velocities=velocities,\n        pairwise_inters=pis,\n        neighbor_finder=neighbor_finder,\n    )\n    simulator = VelocityVerlet(dt=0.0001f0u\"ps\", remove_CM_motion=false)\n    return simulate!(sys, simulator, 100)\nend\n\nfunction test_natoms()\n    n_atoms = 40_000\n    while true\n        fs = check_sim(n_atoms)\n        println(n_atoms, \" atoms okay\")\n        n_atoms += 20_000\n    end\nend\n\ntest_natoms()\n\nThe results before running out of memory on different GPUs are:\n\n60,000 on NVIDIA GeForce RTX 2080 Ti (11 GB).\n140,000 on NVIDIA RTX A6000 (48 GB).\n120,000 on NVIDIA GeForce RTX 5090 (32 GB).","category":"section"},{"location":"examples/#Variations-of-the-Morse-potential","page":"Examples","title":"Variations of the Morse potential","text":"The Morse potential for bonds has a parameter a that determines the width of the potential. It can also be compared to the harmonic bond potential.\n\nusing Molly\nusing GLMakie\n\nboundary = CubicBoundary(5.0)\ndists = collect(0.12:0.005:2.0)\n\nfunction energies(inter)\n    return map(dists) do dist\n        c1 = SVector(1.0, 1.0, 1.0)\n        c2 = SVector(dist + 1.0, 1.0, 1.0)\n        potential_energy(inter, c1, c2, boundary)\n    end\nend\n\nf = Figure(size=(600, 400))\nax = Axis(\n    f[1, 1],\n    xlabel=\"Distance / nm\",\n    ylabel=\"Potential energy / kJ * mol^-1\",\n    title=\"Variations of the Morse potential\",\n)\nlines!(\n    ax,\n    dists,\n    energies(HarmonicBond(k=20_000.0, r0=0.2)),\n    label=\"Harmonic\",\n)\nfor a in [2.5, 5.0, 10.0]\n    lines!(\n        ax,\n        dists,\n        energies(MorseBond(D=100.0, a=a, r0=0.2)),\n        label=\"Morse a=$a nm^-1\",\n    )\nend\nylims!(ax, 0.0, 120.0)\naxislegend(position=:rb)\nsave(\"morse.png\", f)\n\n(Image: Morse)","category":"section"},{"location":"examples/#Variations-of-the-Mie-potential","page":"Examples","title":"Variations of the Mie potential","text":"The Mie potential is parameterised by m describing the attraction and n describing the repulsion. When m=6 and n=12 this is equivalent to the Lennard-Jones potential.\n\nusing Molly\nusing GLMakie\n\nboundary = CubicBoundary(5.0)\na1, a2 = Atom(σ=0.3, ϵ=0.5), Atom(σ=0.3, ϵ=0.5)\ndists = collect(0.2:0.005:0.8)\n\nfunction energies(m, n)\n    inter = Mie(m=m, n=n)\n    return map(dists) do dist\n        c1 = SVector(1.0, 1.0, 1.0)\n        c2 = SVector(dist + 1.0, 1.0, 1.0)\n        vec = vector(c1, c2, boundary)\n        potential_energy(inter, vec, a1, a2, NoUnits)\n    end\nend\n\nf = Figure(size=(600, 400))\nax = Axis(\n    f[1, 1],\n    xlabel=\"Distance / nm\",\n    ylabel=\"Potential energy / kJ * mol^-1\",\n    title=\"Variations of the Mie potential\",\n)\nfor m in [4, 6]\n    for n in [10, 12]\n        lines!(\n            ax,\n            dists,\n            energies(Float64(m), Float64(n)),\n            label=\"m=$m, n=$n\",\n        )\n    end\nend\nxlims!(ax, low=0.2)\nylims!(ax, -0.6, 0.3)\naxislegend(position=:rb)\nsave(\"mie.png\", f)\n\n(Image: Mie)","category":"section"},{"location":"examples/#Different-soft-core-potentials","page":"Examples","title":"Different soft-core potentials","text":"The soft-core Lennard-Jones and Coulomb potentials are parameterised by alpha and lambda, in addition to the standard potential parameters. The soft-core potential proposed by Gapsys et al. 2012 includes an additional parameter sigma_Q.\n\nThese parameters shift the value of r_ij to (fracalpha(1-lambda)C^(12)C^(6)+r^6)^16 for the Beutler et al. 1994 soft-core potential, which prevents the potential from diverging as r_ij rightarrow 0. In the case of the Gapsys et al. 2012 soft-core potentials, the transition from a hard-core to a soft-core potential occurs at a specific distance. The forces are linearized at the transition point, and this switching distance depends on the value of lambda.\n\nusing Molly\nusing GLMakie\n\nboundary = CubicBoundary(5.0u\"nm\")\na1 = Atom(charge=0.5, σ=0.3u\"nm\", ϵ=0.5u\"kJ * mol^-1\")\na2 = Atom(charge=-0.5, σ=0.3u\"nm\", ϵ=0.5u\"kJ * mol^-1\")\ndists = 0.01:0.005:0.8\n\nenergies(inter) = map(dists) do dist\n    c1 = SVector(1.0, 1.0, 1.0)u\"nm\"\n    c2 = SVector(dist + 1.0, 1.0, 1.0)u\"nm\"\n    vec = vector(c1, c2, boundary)\n    potential_energy(inter, vec, a1, a2, NoUnits)\nend\n\nfunction plot_interactions(ax, title, xlabel, ylabel, data, ylims_range)\n    ax.title = title\n    ax.xlabel = xlabel\n    ax.ylabel = ylabel\n    for (label, inter) in data\n        lines!(ax, dists, ustrip.(energies(inter)), label=label)\n    end\n    ylims!(ax, ylims_range)\n    axislegend(ax, position=:rt)\nend\n\nf = Figure(size=(1200, 800))\nax1, ax2, ax3, ax4 = Axis(f[1, 1]), Axis(f[1, 2]), Axis(f[2, 1]), Axis(f[2, 2])\n\nLJ = Dict(\n    \"LJ\" => LennardJones(),\n    \"LJ-Beutler\" => LennardJonesSoftCoreBeutler(α=0.3, λ=0.5),\n    \"LJ-Gapsys\" => LennardJonesSoftCoreGapsys(α=0.85, λ=0.5),\n)\nplot_interactions(\n    ax1,\n    \"Soft-core Lennard-Jones potentials \\nin comparison to standard LJ for λ=0.5\",\n    \"Distance / nm\",\n    \"Potential Energy / kJ * mol^-1\",\n    sort(LJ),\n    (-5, 400),\n)\n\nCou = Dict(\n    \"Coulomb\" => Coulomb(),\n    \"Coulomb-Beutler\" => CoulombSoftCoreBeutler(α=0.3, λ=0.5),\n    \"Coulomb-Gapsys\" => CoulombSoftCoreGapsys(α=0.3, λ=0.5, σQ=1u\"nm\"),\n)\nplot_interactions(\n    ax2,\n    \"Soft-core Coulomb potentials \\nin comparison to standard Coulomb for λ=0.5\",\n    \"Distance / nm\",\n    \"Potential Energy / kJ * mol^-1\",\n    sort(Cou),\n    (-400, 0),\n)\n\nplot_interactions(\n    ax3,\n    \"Effect of λ on soft-core Lennard-Jones potential (Beutler et al.)\",\n    \"Distance / nm\",\n    \"Potential Energy / kJ * mol^-1\",\n    [(string(\"λ=$λ\"), LennardJonesSoftCoreBeutler(α=0.3, λ=λ)) for λ in [0.1, 0.3, 0.5, 0.8, 1.0]],\n    (-5, 400),\n)\n\nplot_interactions(\n    ax4,\n    \"Effect of λ on soft-core Coulomb potential (Gapsys et al.)\",\n    \"Distance / nm\",\n    \"Potential Energy / kJ * mol^-1\",\n    [(string(\"λ=$λ\"), LennardJonesSoftCoreGapsys(α=0.85, λ=λ)) for λ in [0.1, 0.3, 0.5, 0.8, 1.0]],\n    (-5, 400),\n)\n\nsave(\"softcore_potentials.png\", f)\n\n(Image: Lennard-Jones Softcore)","category":"section"},{"location":"examples/#Crystal-structures","page":"Examples","title":"Crystal structures","text":"Molly can make use of SimpleCrystals.jl to generate crystal structures for simulation. All 3D Bravais lattices and most 2D Bravais lattices are supported as well as user-defined crystals through the SimpleCrystals API. The only unsupported crystal types are those with a triclinic 2D simulation domain or crystals with lattice angles larger than 90°.\n\nMolly provides a constructor for System that takes in a Crystal struct:\n\nusing Molly\nimport SimpleCrystals\n\na = 0.52468u\"nm\" # Lattice parameter for FCC Argon at 10 K\natom_mass = 39.948u\"g/mol\"\ntemp = 10.0u\"K\"\nfcc_crystal = SimpleCrystals.FCC(a, atom_mass, SVector(4, 4, 4))\n\nn_atoms = length(fcc_crystal)\nvelocities = [random_velocity(atom_mass, temp) for i in 1:n_atoms]\n\nr_cut = 0.85u\"nm\"\nsys = System(\n    fcc_crystal;\n    velocities=velocities,\n    pairwise_inters=(LennardJones(cutoff=ShiftedForceCutoff(r_cut)),),\n    loggers=(\n        kinetic_eng=KineticEnergyLogger(100),\n        pot_eng=PotentialEnergyLogger(100),\n    ),\n    energy_units=u\"kJ * mol^-1\",\n    force_units=u\"kJ * mol^-1 * nm^-1\",\n)\n\nCertain potentials such as LennardJones and Buckingham require extra atomic paramaters (e.g. σ) that are not implemented by the SimpleCrystals API. These paramaters must be added to the System manually by making use of the copy constructor:\n\nσ = 0.34u\"nm\"\nϵ = (4.184 * 0.24037)u\"kJ * mol^-1\"\nupdated_atoms = []\n\nfor i in eachindex(sys)\n    push!(updated_atoms, Atom(index=sys.atoms[i].index, atom_type=sys.atoms[i].atom_type,\n                              mass=sys.atoms[i].mass, charge=sys.atoms[i].charge,\n                              σ=σ, ϵ=ϵ))\nend\n\nsys = System(sys; atoms=[updated_atoms...])\n\nNow the system can be simulated using any of the available simulators:\n\nsimulator = Langevin(\n    dt=2.0u\"fs\",\n    temperature=temp,\n    friction=1.0u\"ps^-1\",\n)\nsimulate!(sys, simulator, 200_000)","category":"section"},{"location":"examples/#Constrained-dynamics","page":"Examples","title":"Constrained dynamics","text":"Molly supports the SHAKE and RATTLE constraint algorithms. The code below shows an example where molecules of hydrogen are randomly placed in a box and constrained during a simulation.\n\nusing Molly\nusing Test\n\nr_cut = 8.5u\"Å\"\ntemp = 300.0u\"K\"\natom_mass = 1.00794u\"g/mol\"\n\nn_atoms_half = 200\natoms = [Atom(index=i, mass=atom_mass, σ=2.8279u\"Å\", ϵ=0.074u\"kcal* mol^-1\")\n         for i in 1:n_atoms_half]\nmax_coord = 200.0u\"Å\"\ncoords = max_coord .* rand(SVector{3, Float64}, n_atoms_half)\nboundary = CubicBoundary(200.0u\"Å\")\nlj = LennardJones(cutoff=ShiftedPotentialCutoff(r_cut), use_neighbors=true)\n\n# Add bonded atoms\nbond_length = 0.74u\"Å\" # Hydrogen bond length\nconstraints = []\nfor j in 1:n_atoms_half\n    push!(atoms, Atom(index=(j + n_atoms_half), mass=atom_mass, σ=2.8279u\"Å\", ϵ=0.074u\"kcal* mol^-1\"))\n    push!(coords, coords[j] .+ SVector(bond_length, 0.0u\"Å\", 0.0u\"Å\"))\n    push!(constraints, DistanceConstraint(j, j + n_atoms_half, bond_length))\nend\n\nshake = SHAKE_RATTLE(\n    length(atoms),\n    1e-8u\"Å\",\n    1e-8u\"Å^2 * ps^-1\";\n    dist_constraints=[constraints...],\n)\n\nneighbor_finder = DistanceNeighborFinder(\n    eligible=trues(length(atoms), length(atoms)),\n    dist_cutoff=1.5*r_cut,\n)\n\nsys = System(\n    atoms=atoms,\n    coords=coords,\n    boundary=boundary,\n    pairwise_inters=(lj,),\n    neighbor_finder=neighbor_finder,\n    constraints=(shake,),\n    energy_units=u\"kcal * mol^-1\",\n    force_units=u\"kcal * mol^-1 * Å^-1\",\n)\n\nrandom_velocities!(sys, temp)\n\nsimulator = VelocityVerlet(dt=0.001u\"ps\")\n\nsimulate!(sys, simulator, 10_000)\n\n# Check that the constraints are satisfied at the end of the simulation\n@test check_position_constraints(sys, shake)\n@test check_velocity_constraints(sys, shake)","category":"section"},{"location":"examples/#KIM-portable-models","page":"Examples","title":"KIM portable models","text":"KIM_API.jl connects Molly to the KIM API, giving direct access to the large model catalog on OpenKIM, including classical, machine-learned, and hybrid potentials that are distributed as portable models. Once configured, any simulator in Molly can evaluate those models via the standard general interaction interface.","category":"section"},{"location":"examples/#Installation","page":"Examples","title":"Installation","text":"Install the KIM API and make the shared library discoverable:  bash  conda create -n kim-api kim-api=2.4 -c conda-forge  conda activate kim-api  export KIM_API_LIB=${CONDA_PREFIX}/lib/libkim-api.so\nInstall the required OpenKIM model:  ```bash  $ kim-api-collections-management install user SWStillingerWeber1985Si__MO405512056662006  Downloading.............. SWStillingerWeber1985SiMO405512056662006  Found installed driver... SWMD335816936951005  [100%] Built target SWStillingerWeber1985Si__MO405512056662006  Install the project...  – Install configuration: \"Debug\"  – Installing: /.kim-api/2.4.1+v2.4.1.dirty.GNU.GNU.GNU.2022-07-29-16-25-35/portable-models-dir/SWStillingerWeber1985SiMO405512056662006/libkim-api-portable-model.so  – Set runtime path of \"/.kim-api/2.4.1+v2.4.1.dirty.GNU.GNU.GNU.2022-07-29-16-25-35/portable-models-dir/SWStillingerWeber1985_SiMO405512056662006/libkim-api-portable-model.so\" to \"\"\nSuccess!  ```\nAdd the package to your Julia environment:  julia  using Pkg  Pkg.add(\"KIM_API\")","category":"section"},{"location":"examples/#Stillinger-Weber-silicon-supercell","page":"Examples","title":"Stillinger-Weber silicon supercell","text":"The example below shows how to run a 5 times 5 times 5 silicon supercell in Molly using the portable Stillinger–Weber potential hosted on OpenKIM. Every other portable model, including neural-network and Gaussian-process potentials, can be swapped in by changing the model identifier passed to the calculator.\n\nusing Molly\nusing KIM_API\nusing StaticArrays\nusing Unitful: Å, ustrip\nusing UnitfulAtomic\n\na0 = 5.431u\"Å\"\nrepeats = (5, 5, 5)\n\ndiamond_basis = [\n    SVector(0.0, 0.0, 0.0),\n    SVector(0.5, 0.5, 0.0),\n    SVector(0.5, 0.0, 0.5),\n    SVector(0.0, 0.5, 0.5),\n    SVector(0.25, 0.25, 0.25),\n    SVector(0.75, 0.75, 0.25),\n    SVector(0.75, 0.25, 0.75),\n    SVector(0.25, 0.75, 0.75),\n]\n\natoms = Atom[]\ncoords = SVector{3, typeof(1.0u\"Å\")}[]\na0_val = ustrip(Å, a0)\n\nfor (ix, iy, iz) in Iterators.product(0:repeats[1]-1, 0:repeats[2]-1, 0:repeats[3]-1)\n    shift = SVector(ix, iy, iz)\n    for basis in diamond_basis\n        push!(atoms, Atom(atom_type=\"Si\", mass=28.0855u\"u\"))\n        cart = SVector((basis .+ shift) .* a0_val) * Å\n        push!(coords, cart)\n    end\nend\n\nvelocities = zero(coords) .* (1.0u\"ps\"^-1)\nboundary = CubicBoundary(repeats[1] * a0)\n\n# Uses :metal units = Å, eV, e, K, ps\ncalc = KIM_API.KIMCalculator(\n    \"SW_StillingerWeber_1985_Si__MO_405512056662_006\";\n    units=:metal,\n)\n\nloggers = (\n    temp=TemperatureLogger(10),\n    coords=CoordinatesLogger(10),\n)\n\nsys = System(\n    atoms=atoms,\n    coords=coords,\n    boundary=boundary,\n    velocities=velocities,\n    general_inters=(kim=calc,),\n    force_units=u\"eV/Å\",\n    energy_units=u\"eV\",\n    loggers=loggers,\n)\n\ntemp = 298.0u\"K\"\nsimulator = VelocityVerlet(\n    dt=0.002u\"ps\",\n    coupling=AndersenThermostat(temp, 1.0u\"ps\"),\n)\n\nsimulate!(sys, simulator, 10_000)\n\nusing GLMakie\nvisualize(sys.loggers.coords, boundary, \"Si_SW_KIM.gif\"; markersize=0.4)\n\n(Image: Silicon SW KIM)\n\nBecause the calculator builds on the KIM API, you can change the \"SW_StillingerWeber_1985_Si__MO_405512056662_006\" identifier to any other model published on OpenKIM and immediately drive the same Molly simulation pipeline. For more details on KIM_API, please consult the documentation.","category":"section"},{"location":"free_energy/#Free-energies-with-MBAR","page":"Free energy","title":"Free energies with MBAR","text":"","category":"section"},{"location":"free_energy/#A-brief-introduction","page":"Free energy","title":"A brief introduction","text":"One of the most relevant uses of molecular dynamics (MD) is the estimation of free energy (FE) changes along a given reaction coordinate. One may be interested in, for example, how favorable the binding of a ligand to a target protein is; or which conformer of a molecule is the most stable. These are the kind of questions that can be addressed with FE techniques.\n\nThrough the years, researchers have developed a collection of techniques to solve these problems. As early as 1954, Robert W Zwanzig introduced the FE perturbation method, leading to the Zwanzig equation:\n\nDelta F_A rightarrow B = F_B - F_A = k_B T ln left langle expleft( - fracE_B - E_Ak_B T right) right rangle _A\n\nThis states that, for a given system, the change of FE in going from state A to state B is equal to the FE difference between the two states and, more importantly, directly related to the total energy difference of states A and B through Botzmann statistics. In this equation, the angle brackets represent the expected value of the Boltzmann-weighted energy difference of the two states, but sampled only from conformations extracted from state A. This implies that, even when sampling only one state, we are able to infer information from the other, given that some niceness criteria is met, i.e. the energy difference between the two states is small enough. This reasoning about unsampled states by re-evaluating sampled states is known as reweighting.\n\nA little over 20 years after Zwanzig introduced FE perturbation, Charles H Bennett expanded on this and developed the Bennett Acceptance Ratio (BAR). Bennett built directly upon the statistical foundation of the Zwanzig equation, and recognized that both forward and reverse energy differences between two states contain complementary information; that is, while Zwanzig’s formulation reweights configurations from a single ensemble to estimate the free energy of another, BAR symmetrizes this process. It combines samples from both states and determines the free energy shift Delta F that makes each ensemble equally probable under some weighting derived from Boltzmann statistics. In this sense, BAR can be viewed as a generalization of Zwanzig’s exponential averaging, reducing to the Zwanzig equation when only one direction of sampling is available. However, it is because of this that BAR still suffers from the same issue as Zwanzig's reweighting method: the energy difference between states A and B must be small enough such that there is sufficient overlap between their configurational spaces, otherwise the necessary statistics for FE estimation will be very poor and intermediate steps between A and B are needed.\n\nThus, in 2008 Michael R Shirts and John D Chodera introduced the Multistate Bennett Acceptance Ratio (MBAR) method. MBAR expands on BAR by instead of just using two states A and B, considering a collection of k in K different thermodynamic states. The only thing that is expected from these states is that they must be sampled from equivalent thermodynamic ensembles, this is, all states should be NVT or NPT, etc.; but other than that, the specific Hamiltonian for each evaluated state can differ in an arbitrary manner. Then, a series of n_k samples are drawn from each thermodynamic state, until a total of N = sum_k^K n_k samples are obtained. By evaluating each sample n in N with each Hamiltonian mathcalH_k k in K, one obtains a matrix of reduced potentials u_nk = beta_k left E_k(n)+p_kV(n) right. MBAR then solves a set of self-consistent equations that yield the relative free energies f_k of all states simultaneously, using every sample across all simulations to estimate each state’s free energy in a statistically optimal way. In this sense, MBAR generalizes BAR to an arbitrary number of thermodynamic states and provides the maximum-likelihood, minimum-variance estimator for free energies and ensemble averages, efficiently combining data from overlapping simulations into a unified framework. MBAR also allows the reweighting of any observable to a completely unsampled thermodynamic state. Because this themodynamic state is compared to a collection of sampled states, instead of just one, the conformational space between states is much more likely to overlap, therefore increasing the probability of the reweighting to be meaningful.","category":"section"},{"location":"free_energy/#How-to-run-MBAR-with-Molly","page":"Free energy","title":"How to run MBAR with Molly","text":"","category":"section"},{"location":"free_energy/#Defining-the-restraint-interactions","page":"Free energy","title":"Defining the restraint interactions","text":"In this example, we will use MBAR to calculate the Potential of Mean Force (PMF) along the central torsion of an alanine dipeptide molecule. In order to do that, we will have to run a series of independent biased simulations, where each will apply an umbrella potential to restrain the peptide torsion fixed around a given angle. We will first define the restraint interaction:\n\n(Image: Alanine dipeptide and the relevant torsion)\n\n# restraints.jl file\n\nusing LinearAlgebra\n\nstruct DihedralRestraint{A, K}\n    ϕ0::A # Radians, dimensionless number\n    Δϕ::A # Radians, dimensionless number\n    k::K  # Energy (e.g. kJ/mol)\nend\n\n# Store angles as plain Float64 radians, k should be energy\nfunction DihedralRestraint(ϕ0::Unitful.AbstractQuantity, Δϕ::Unitful.AbstractQuantity, k)\n    ϕ0r = ustrip(u\"rad\", ϕ0)\n    Δϕr = ustrip(u\"rad\", Δϕ)\n    return DihedralRestraint(ϕ0r, Δϕr, k)\nend\n\nThen, we have to define the potential energy and force functions that Molly will call when it encounters such an interaction. We will make use of the machinery present in Molly and define the restraint as a specific interaction, returning the force as a SpecificForce4Atoms. The functional form used as the bias potential is a quadratic flat bottom angle restraint, using:\n\nvarphi^prime = (varphi - varphi^0)  2pi\n\nVleft( varphi^prime right) = begincases\n    frac12 cdot k cdot left( varphi^prime - Deltavarphi right)^2  mathrmfor  lvert varphi^prime rvert ge Deltavarphi \n    0  mathrmfor  lvert varphi^prime rvert lt Deltavarphi\nendcases\n\nWhere varphi and varphi^0 are the current and reference dihedral angles, respectively; Deltavarphi is the width of the flat bottom of the potential, and k is the energy constant associated with the interaction. The analytic derivation of the force acting on each atom defining the dihedral, given the previous potential, is quite involved and beyond the scope of this tutorial. We do provide here, however, the Julia code used to define the potential energy and force:\n\n# restraints.jl file\n\n# Robust geometry with clamped inverses\nfunction _dihedral_geom(ci, cj, ck, cl, boundary)\n    b1 = vector(cj, ci, boundary)\n    b2 = vector(cj, ck, boundary)\n    b3 = vector(ck, cl, boundary)\n\n    n1 = cross(b1, b2)\n    n2 = cross(b2, b3)\n\n    b2n  = norm(b2)\n    n1n2 = dot(n1, n1)\n    n2n2 = dot(n2, n2)\n\n    # Angle via atan2\n    y = b2n * dot(b1, n2)\n    x = dot(n1, n2)\n    ϕ = atan(y, x)\n\n    return ϕ, b1, b2, b3, n1, n2, b2n, n1n2, n2n2, x, y\nend\n\n_wrap_pi(x::Real) = (x + π) % (2π) - π # Take into account periodicity\n_rad(x::Real) = Float64(x)\n_rad(x) = Float64(ustrip(u\"rad\", x))\n\nfunction Molly.potential_energy(inter::DihedralRestraint{FT, K},\n                                ci, cj, ck, cl, boundary, args...) where {FT, K}\n    b1 = vector(cj, ci, boundary)\n    b2 = vector(cj, ck, boundary)\n    b3 = vector(ck, cl, boundary)\n    n1 = cross(b1, b2)\n    n2 = cross(b2, b3)\n\n    b2n  = norm(b2)\n    n1n2 = dot(n1, n1)\n    n2n2 = dot(n2, n2)\n\n    y = b2n * dot(b1, n2)\n    x = dot(n1, n2)\n    ϕ = atan(y, x)\n\n    # Scale-aware tolerances\n    Ls = max(ustrip(norm(b1) + norm(b2) + norm(b3)), 1.0) * oneunit(norm(b1))\n    tol_b  = 1e-12 * Ls\n    tol_xy = 1e-24 * (Ls^4)\n\n    if !isfinite(ϕ) || b2n ≤ tol_b || abs(x) ≤ tol_xy || abs(y) ≤ tol_xy ||\n                    sqrt(n1n2) ≤ tol_b^2 || sqrt(n2n2) ≤ tol_b^2\n        return zero(inter.k)\n    end\n\n    ϕ0 = _rad(inter.ϕ0)\n    Δ  = _rad(inter.Δϕ)\n    d  = _wrap_pi(ϕ - ϕ0)\n    ad = abs(d)\n\n    if ad ≤ Δ\n        return zero(inter.k)\n    else\n        diff = ad - Δ\n        return FT(inter.k * (diff * diff) / 2)\n    end\nend\n\nfunction Molly.force(inter::DihedralRestraint{FT, K},\n                     ci, cj, ck, cl, boundary, args...) where {FT, K}\n    b1 = vector(cj, ci, boundary)\n    b2 = vector(cj, ck, boundary)\n    b3 = vector(ck, cl, boundary)\n    n1 = cross(b1, b2)\n    n2 = cross(b2, b3)\n\n    b2n  = norm(b2)\n    n1n2 = dot(n1, n1)\n    n2n2 = dot(n2, n2)\n\n    y = b2n * dot(b1, n2)\n    x = dot(n1, n2)\n    ϕ = atan(y, x)\n\n    # Zero force with correct units (energy/length)\n    F0 = FT(zero(inter.k) / oneunit(norm(b1)))\n    Fz = SVector(F0, F0, F0)\n\n    # Tolerances\n    Ls = max(ustrip(norm(b1) + norm(b2) + norm(b3)), 1.0) * oneunit(norm(b1))\n    tol_b  = 1e-12 * Ls\n    tol_xy = 1e-24 * (Ls^4)\n\n    if !isfinite(ϕ) || b2n ≤ tol_b || abs(x) ≤ tol_xy || abs(y) ≤ tol_xy ||\n                    sqrt(n1n2) ≤ tol_b^2 || sqrt(n2n2) ≤ tol_b^2\n        return SpecificForce4Atoms(Fz, Fz, Fz, Fz)\n    end\n\n    ϕ0 = _rad(inter.ϕ0)\n    Δ  = _rad(inter.Δϕ)\n    d  = _wrap_pi(ϕ - ϕ0)\n    ad = abs(d)\n    if ad ≤ Δ\n        return SpecificForce4Atoms(Fz, Fz, Fz, Fz)\n    end\n\n    # dU/dϕ as energy\n    dU_dϕ = inter.k * (ad - Δ) * (d ≥ 0 ? 1.0 : -1.0)\n\n    # Safe inverses\n    εL4 = 1e-32 * (Ls^4)\n    εL2 = 1e-32 * (Ls^2)\n    inv_n1  = 1 / max(n1n2, εL4)\n    inv_n2  = 1 / max(n2n2, εL4)\n    b22     = dot(b2, b2)\n    inv_b22 = 1 / max(b22,  εL2)\n\n    # Gradients (all ~ 1/L)\n    g1 = (b2n * inv_n1) * n1\n    g4 = (b2n * inv_n2) * n2\n    s1 = dot(b1, b2) * inv_b22\n    s3 = dot(b3, b2) * inv_b22\n    g2 = -g1 + s1*g1 - s3*g4\n    g3 = -g4 + s3*g4 - s1*g1\n\n    F1 = -(dU_dϕ) * g1\n    F2 = -(dU_dϕ) * g2\n    F3 = -(dU_dϕ) * g3\n    F4 = -(dU_dϕ) * g4\n    return SpecificForce4Atoms(FT.(F1), FT.(F2), FT.(F3), FT.(F4))\nend","category":"section"},{"location":"free_energy/#Setting-up-simulations","page":"Free energy","title":"Setting up simulations","text":"With this in hand, we are ready to set up the individual biased simulations. We will explore a full torsion around the dihedral, i.e. spanning 360 degrees. We will do so in 60 independent biased simulations, so 360 degrees / 60 simulations = 6 degrees increments per simulation. The system is quite well-behaved, so we can get away with using Float32 precision on GPU. We will use a time step of 1 fs to integrate the equations of motion, and will run the simulations in the NPT ensemble at 310 K and 1 bar of pressure.\n\n# pulling.jl\n\nusing Molly\nusing CUDA\n\ninclude(\"restraints.jl\")\n\nFT     = Float32               # Float precision\nAT     = CuArray               # Array type, run simulations on CUDA GPU\nN_WIN  = 60                    # Number of umbrella windows to generate\ndR     = FT(6)u\"deg\"           # Increment in CV (torsion angle) in each consecutive window\nΔR     = FT(3)u\"deg\"           # Width of flat bottom potential\nK_bias = FT(250)u\"kJ * mol^-1\" # Energy constant for restraint potential\nΔt     = FT(1)u\"fs\"            # Simulation timestep\nT0     = FT(310)u\"K\"           # Simulation temperature\nP0     = FT(1)u\"bar\"           # Simulation pessure\n\nOne must take into account that the simulations will start from an initial (ideally equilibrated) configuration, and therefore an arbitrarirly imposed restraint may be too far away from the equilibrium distribution of the CV to be biased, causing numerical issues. Thus, we will begin our setup by gently pulling the system along the CV in a series of short, sequential simulations. How short? The answer to that question depends on the system to be simulated; the pulling simulations should be long enough so that the system has time to move towards and stabilize around the imposed biased equilibrium, but also sufficiently short as to not waste time in this initial sequential part, as once each umbrella window is equilibrated it can run in parallel with the rest. For this simple study case, equilibrating each window for 0.5 ns is enough. We can define:\n\n# pulling.jl\n\ntu      = unit(Δt)                   # Time units used for timestep\nmax_t   = uconvert(u, FT(0.5)u\"ns\")  # Simulation time in appropriate time units\nN_STEPS = Int(floor(max_t / Δt))     # Number of simulation steps\n\nWe can now load the initial configuration into a System:\n\n# pulling.jl\n\ndata_dir = joinpath(dirname(pathof(Molly)), \"..\", \"data\")\nff_dir   = joinpath(data_dir, \"force_fields\")\n\nff = MolecularForceField(\n    FT,\n    joinpath.(ff_dir, [\"ff99SBildn.xml\", \"tip3p_standard.xml\", \"his.xml\"])...;\n    units=true,\n)\n\nsys_0 = System(\n    joinpath(data_dir, \"dipeptide_equil.pdb\"),\n    ff;\n    array_type          = AT,\n    rename_terminal_res = false,\n    nonbonded_method    = :cutoff,\n)\n\nrandom_velocities!(sys_0, T0) # Initialize velocities from M-B distribution at target temperature\n\nNow, before starting to produce the pulling simulations, we need to know what is the value of the CV (remember, the torsion angle) for an equilibrated system. We can make use of the functions defined in restraints.jl. Remember to take note of this value, it will be important later!\n\n# pulling.jl\n\n# Indices of the atoms defining the dihedral\ni = 17\nj = 15\nk = 9\nl = 7\n\ncoords_cpu = Molly.from_device(sys_0.coords)\neq_θ,      = _dihedral_geom(coords_cpu[i], coords_cpu[j], coords_cpu[k], coords_cpu[l], sys_0.boundary)\neq_θ       = _wrap_pi(eq_θ) # = -0.48948112328583804 rad\n\nWe are getting very close to running the pulling simulations. The only remaining things to define are the coupling algorithms to keep a constant temperature and pressure, which integrator to use, and also tell Molly every how many integration steps should we write the coordinates to a trajectory file:\n\n# pulling.jl\n\nτ_T        = FT(1)u\"ps\" # Thermostat coupling constant\n# Apply thermostat every simulation step, required for Verlet-type integrators\nthermostat = VelocityRescaleThermostat(T0, τ_T, n_steps = 1)\n\nτ_P        = FT(1)u\"ps\" # Barostat coupling constant\n# Apply barostat 10 times per τ_P, good balance of precision and computational overhead\nfrac       = uconvert(tu, 0.1 * τ_P)\nn_P        = Int(floor(frac/Δt)) # The number of simulation steps\nbarostat   = CRescaleBarostat(P0, τ_P; n_steps = n_P)\n\n# Create the integrator, remove COM motion every 100 steps\nvverlet    = VelocityVerlet(Δt, (thermostat, barostat,), 100)\n\nsave_t     = uconvert(tu, FT(1)u\"ps\") # Save coordinates every picosecond\nsave_steps = Int(floor(save_t / Δt))  # The number of simulation steps\n\nWith all of this ready, we only need to sequentially run the pulling simulations. We use the coordinates and velocities at the end of simulation n to seed the beginning of simulation n + 1:\n\n# pulling.jl\n\nold_sys = deepcopy(sys_0) # Get a copy of the initial system\nsils    = deepcopy(sys_0.specific_inter_lists) # Get the interactions lists of the unbiased system\nfor w in 1:N_WIN\n    # Calculate where is the potential well located for a given window\n    rest_θ = FT(eq_θ - (w-1) * uconvert(u\"rad\", dR))\n    # Create the Dihedral restraint given our parameters\n    dRest = DihedralRestraint(rest_θ*u\"rad\", uconvert(u\"rad\", ΔR) , K_bias)\n\n    # Pack restraint into an independent interaction list\n    rest_inter = InteractionList4Atoms(\n        Molly.to_device([i], AT),\n        Molly.to_device([j], AT),\n        Molly.to_device([k], AT),\n        Molly.to_device([l], AT),\n        Molly.to_device([dRest], AT),\n    )\n\n    rest_inter = (sils..., rest_inter,) # Merge unbiased and biased into single tuple\n\n    sys_w = System(\n        deepcopy(old_sys); # Get the same layout as the unbiased system\n        specific_inter_lists=rest_inter, # Overwrite interaction list with the one containing the bias\n        loggers=(TrajectoryWriter(save_steps, \"./pull_$(w).dcd\"),),\n    )\n\n    simulate!(sys_w, vverlet, N_STEPS)\n\n    # We also write the very last structure to a pdb file\n    write_structure(\"./pull_$(w).pdb\", sys_w)\n\n    global old_sys = sys_w # Override old system with the newly simulated one\nend","category":"section"},{"location":"free_energy/#Running-umbrella-simulations","page":"Free energy","title":"Running umbrella simulations","text":"Once we have run the pulling, we can write a small standalone script to produce the umbrella sampling simulations. These can be run in parallel as they are independent. The simulation setup must be exactly the same used to produce the pulling, except for the amount of time the simulations will be run for. In our case, each simulation was run for a total of 50 ns:\n\n# individual_simulation.jl\n\nusing Molly\nusing CUDA\n\ninclude(\"restraints.jl\")\n\nSIM_N = parse(Int, ARGS[1])      # Take the umbrella index as the first argument\n\nFT     = Float32               # Float precision\nAT     = CuArray               # Array type, run simulations on CUDA GPU\nN_WIN  = 60                    # Number of umbrella windows to generate\ndR     = FT(6)u\"deg\"           # Increment in CV (torsion angle) in each consecutive window\nΔR     = FT(3)u\"deg\"           # Width of flat bottom potential\nK_bias = FT(250)u\"kJ * mol^-1\" # Energy constant for restraint potential\nΔt     = FT(1)u\"fs\"            # Simulation timestep\nT0     = FT(310)u\"K\"           # Simulation temperature\nP0     = FT(1)u\"bar\"           # Simulation pessure\n\ndata_dir = joinpath(dirname(pathof(Molly)), \"..\", \"data\")\nff_dir = joinpath(data_dir, \"force_fields\")\n\nff = MolecularForceField(\n    FT,\n    joinpath.(ff_dir, [\"ff99SBildn.xml\", \"tip3p_standard.xml\", \"his.xml\"])...;\n    units=true,\n)\n\nsys = System(\n    joinpath(\"./\", \"./pull_$(SIM_N).pdb\"), # Now we load the final structure for a given pull simulation\n    ff;\n    array_type          = AT,\n    rename_terminal_res = false,\n    nonbonded_method    = :cutoff,\n)\n\nrandom_velocities!(sys, T0)\n\n# Indices of atoms defining the dihedral\ni = 17\nj = 15\nk = 9\nl = 7\n\neq_θ = FT(-0.48948112328583804) # We get this from the equilibrium structure\n\ntu         = unit(Δt)                 # Time units used for timestep\nmax_t      = uconvert(u, FT(50)u\"ns\") # Simulation time in appropriate time units\nN_STEPS    = Int(floor(max_t / Δt))   # Number of simulation steps\n\nτ_T        = FT(1)u\"ps\"               # Thermostat coupling constant\nthermostat = VelocityRescaleThermostat(T0, τ_T, n_steps=1) # Apply thermostat every simulation step\n\nτ_P        = FT(1)u\"ps\"               # Barostat coupling constant\nfrac       = uconvert(tu, 0.1 * τ_P)  # Apply barostat 10 times per τ_P, good balance of precision and computational overhead\nn_P        = Int(floor(frac/Δt))      # To number of simulation steps\nbarostat   = CRescaleBarostat(P0, τ_P; n_steps=n_P)\n\nvverlet    = VelocityVerlet(Δt, (thermostat, barostat,), 100) # Create the integrator, remove COM motion every 100 steps\n\nsave_t     = uconvert(tu, FT(1)u\"ps\")  # Save coordinates every picosecond\nsave_steps = Int(floor(save_t / Δt))   # To number of simulation steps\n\nrest_θ = FT(eq_θ - (SIM_N-1) * uconvert(u\"rad\", dR)) # The equilibrium value for the bias\ndRest  = DihedralRestraint(rest_θ*u\"rad\", uconvert(u\"rad\", ΔR) , K_bias) # Create interaction\n\n# Pack into interaction list\nrest_inter = InteractionList4Atoms(\n    Molly.to_device([i], AT),\n    Molly.to_device([j], AT),\n    Molly.to_device([k], AT),\n    Molly.to_device([l], AT),\n    Molly.to_device([dRest], AT),\n)\n\nsils       = deepcopy(sys.specific_inter_lists) # Unbiased\nrest_inter = (sils..., rest_inter,)             # Merge biased and unbiased\n\nsys = System(\n    deepcopy(sys); # Everything from the unbiased system\n    specific_inter_lists=rest_inter, # Overwrite specific interactions\n    loggers=(trj=TrajectoryWriter(save_steps, \"./umbrella_$(SIM_N).dcd\"),),\n)\n\nsimulate!(sys, vverlet, N_STEPS)","category":"section"},{"location":"free_energy/#Calculating-free-energies-with-MBAR","page":"Free energy","title":"Calculating free energies with MBAR","text":"Once all of the individual umbrella simulations are finished, we are ready to run MBAR on the results and estimate the free energy along our reaction coordinate. Remember from the first section of this tutorial that the MBAR equations are solved by evaluating every generated conformation with every used Hamiltonian. It follows, then, that we will first have to set up an array of System structs that represent each Hamiltonian. Moreover, we will be reading data from trajectories, so those Systems will actually be wrapped inside EnsembleSystem structs, which allow IO operations from trajectory files into data structures usable by Molly.\n\nWe start by defining variables that will be shared by all thermodynamic states. Notice how many things are shared with the parameters used to produce the simulations!\n\n# MBAR.jl\n\nusing Molly\nusing CUDA\n\ninclude(\"restraints.jl\")\n\nAT = CuArray\nFT = Float32\n\n# Bias parameters\ndR     = FT(6)u\"deg\"           # Increment of CV in each umbrella window\nΔR     = FT(3)u\"deg\"           # Width for flat bottom potential\nK_bias = FT(250)u\"kJ * mol^-1\" # Force used in the restraint\n\ntemp = FT(310)u\"K\"\npres = FT(1)u\"bar\"\n\ndata_dir = joinpath(dirname(pathof(Molly)), \"..\", \"data\")\nff_dir = joinpath(data_dir, \"force_fields\")\n\ntrajs_dir = \"./\" # Or wherever you have saved the umbrella simulations\n\nff = MolecularForceField(\n    FT,\n    joinpath.(ff_dir, [\"ff99SBildn.xml\", \"tip3p_standard.xml\", \"his.xml\"])...;\n    units=true,\n)\n\nsys_nobias = System(\n    joinpath(data_dir, \"./dipeptide_equil.pdb\"),\n    ff;\n    array_type          = AT,\n    rename_terminal_res = false,\n    nonbonded_method    = :cutoff,\n)\n\n# Atom indices defining dihedral\ni = 17\nj = 15\nk = 9\nl = 7\n\neq_θ  = FT(-0.48948112328583804) # We get this from the equilibrium structure\n\nN_TRJ       = 60 # The number of umbrella simulations produced\nTRJ_SYSTEMS = Vector{EnsembleSystem}(undef, N_TRJ)\n\nThreads.@threads for trj_n in 1:N_TRJ\n    traj_path = joinpath(trajs_dir, \"umbrella_$(trj_n).dcd\")\n\n    # Note that the restraint and specific interactions list must be created\n    # in exactly the same way as for the umbrella simulations, we need exactly\n    # the same Hamiltonian\n    rest_θ = FT(eq_θ - (trj_n-1) * uconvert(u\"rad\", dR))\n    dRest = DihedralRestraint(rest_θ*u\"rad\", uconvert(u\"rad\", ΔR) , K_bias)\n\n    rest_inter = InteractionList4Atoms(\n        Molly.to_device([i], AT),\n        Molly.to_device([j], AT),\n        Molly.to_device([k], AT),\n        Molly.to_device([l], AT),\n        Molly.to_device([dRest], AT),\n    )\n\n    sils = deepcopy(sys_nobias.specific_inter_lists)\n\n    rest_sils = (sils..., rest_inter,)\n    sys_rest = System(sys_nobias; specific_inter_lists=rest_sils)\n\n    # Store in struct that allows reading trajectories\n    sys_trj = EnsembleSystem(sys_rest, traj_path)\n\n    TRJ_SYSTEMS[trj_n] = sys_trj\nend\n\nWe now have a vector of structs that represent each system and its trajectory. The next step is to read the trajectories and sample the relevant magnitudes to solve MBAR and get our PMF. We will need the coordinates, the system boundaries (needed to calculate the volume for the pV terms of the Hamiltonian, as we have run the simulations in the NPT ensemble) and, of course, the CV of interest. Note that MBAR assumes statistical independence of samples, so the selected conformations must be subsampled from decorrelated states. Molly does provide the functionality to estimate the statistical inefficiency of a given timeseries and subsequent subsampling.\n\n# MBAR.jl\n\nC  = Vector{<:Any}(undef, N_TRJ) # Vector to store coordinates\nB  = Vector{<:Any}(undef, N_TRJ) # Vector to store boundaries\nCV = Vector{<:Any}(undef, N_TRJ) # Vector to store the CV\n\n# We discard the first 12500 frames (12.5 ns), assume system is still equilibrating there\nFIRST_IDX = 12_500\n\nThreads.@threads for nt in 1:N_TRJ\n    trjsys = TRJ_SYSTEMS[nt]\n    n_frames = Int(length(trjsys.trajectory))\n\n    # Temp arrays to store potential energy, coordinates, boundaries and CV\n    u, c, b, cv  = [], [], [], []\n\n    # Iterate over trajectory frames\n    for n in FIRST_IDX:n_frames\n        current_sys = read_frame!(trjsys, n) # Read the current frame as a System\n        pe = potential_energy(current_sys)\n        coords = Molly.from_device(current_sys.coords)\n        boundary = current_sys.boundary\n\n        # Measure the CV at the current frame\n        ϕ = _dihedral_geom(coords[i], coords[j], coords[k], coords[l], boundary)\n\n        push!(u, pe)\n        push!(c, coords)\n        push!(b, boundary)\n        push!(cv, ϕ*u\"rad\")\n    end\n\n    # Estimate the decorrelation time from the timeseries of the potential energy\n    ineff = Molly.statistical_inefficiency(u; maxlag=n_frames-1)\n\n    # Subsample arrays based on statistical inefficiency\n    sub_coords = Molly.subsample(c,  ineff.stride; first=1)\n    sub_bounds = Molly.subsample(b,  ineff.stride; first=1)\n    sub_CV     = Molly.subsample(cv, ineff.stride; first=1)\n\n    C[nt]  = sub_coords\n    B[nt]  = sub_bounds\n    CV[nt] = sub_CV\nend\n\nNext, we define a vector of thermodynamic states to represent each Hamiltonian used to produce the simulations, as well a single state that represents the system in the absence of bias potentials. We will use the ThermoState struct provided by Molly:\n\n# MBAR.jl\n\n# Assemble the thermodynamic systems for each umbrella window\nenergy_units = TRJ_SYSTEMS[1].system.energy_units\nkBT          = uconvert(energy_units, Unitful.R * temp)\nβi           = Float64(ustrip(1.0 / kBT))\n\nstates = ThermoState[ThermoState(\"win_$i\", βi, pres, TRJ_SYSTEMS[i].system)\n                     for i in eachindex(TRJ_SYSTEMS)]\n\ntarget_state = ThermoState(\"target\", βi, pres, sys_nobias)\n\nWe are finally in possession of everything needed to solve the MBAR equations and estimate the PMF along our CV! There are two paths we can take for this, the long path and the short path. For the sake of completeness, we describe the long path first. The first step for solving MBAR is assembling the reduced energy matrix. Molly provides a functionality just for that through the assemble_mbar_inputs method:\n\n# MBAR.jl\n\nmbar_gen = assemble_mbar_inputs(\n    C, B, states; # Coordinates, boundaries and thermodynamic states\n    target_state=target_state, # The target state, in our case the unbiased system\n    energy_units=energy_units,\n)\n\nu        = mbar_gen.u        # Reduced energy matrix, K states by N sampled conformations\nu_target = mbar_gen.u_target # The reduced energy of the N samples evaluated by the target state hamiltonian\nN_counts = mbar_gen.N        # Number of sampled conformations\nwin_of   = mbar_gen.win_of   # Indexing helper that tells which k state was used to generate each n sample\nshifts   = mbar_gen.shifts   # Numerical shifts, if used, for stability reasons when building the reduced energy matrix\n\nThis generates the necessary inputs to use the self-consistent iteration method to solve the MBAR equations. Of course, Molly provides the iterate_mbar method to do so:\n\n# MBAR.jl\n\n# Returns the relative free energy of each k state and log.(N_counts), needed for downstream computations\nF_k, logN = iterate_mbar(u, win_of, N_counts)\n\nWith this, we can also produce a weight matrix and a vector of target weights, using the  mbar_weights method, that will let us reweight any arbitrary quantity from the sampled K thermodynamic states to any target state:\n\n# MBAR.jl\n\n# Returns the weights matrix and the target weights\nW_s, w_target = mbar_weights(u, u_target, F_k, logN, N_counts; check=true, shifts=shifts)\n\nAnd finally, we can estimate the PMF using the output of the previous step by calling the pmf_with_uncertainty method:\n\n# MBAR.jl\n\npmf = pmf_with_uncertainty(u, u_target, F_k, N_counts, logN, CV; shifts=shifts, kBT=kBT)\n\ncenters   = pmf.centers        # The collective variable\nPMF       = pmf.F              # PMF in kBT\nPMF_enr   = pmf.F_energy       # PMF in energy units\nsigma     = pmf.sigma_F        # Standard deviation in kBT\nsigma_enr = pmf.sigma_F_energy # Standard deviation in energy units\n\nBut what about the short path? Well, we also provide an overload of the pmf_with_uncertainty method that allows to get the PMF in a single call by doing:\n\n# MBAR.jl\npmf = pmf_with_uncertainty(\n    C,            # Coordinates\n    B,            # Boundaries\n    states,       # Themodynamic states\n    target_state, # Target state\n    CV,           # Collective variable\n)\n\nNow one can put this into a graph, for example using a scatter for the free energy and making use of the calculated sigmas (see the previous code blocks) to shade the plot and give a feel for the uncertainties. The code is left as an exercise to the reader, but the results should look like something similar to this:\n\n(Image: PMF along the dipeptide torsion in kBT units) (Image: PMF along the dipeptide torsion in energy units)","category":"section"},{"location":"differentiable/#Differentiable-simulation-with-Molly","page":"Differentiable simulation","title":"Differentiable simulation with Molly","text":"note: Note\nThere are still many rough edges when taking gradients through simulations. Please open an issue if you run into an error and remember the golden rule of AD: check your gradients against finite differencing if you want to make sure they are correct.\n\nnote: Note\nThere are currently issues with running differentiable simulations on the GPU and on the CPU in certain cases. Hopefully these will be resolved soon.\n\nIn the last few years, the deep learning revolution has broadened to include the paradigm of differentiable programming. The concept of using automatic differentiation (AD) to obtain exact gradients through physical simulations has many interesting applications, including parameterising force fields and training neural networks to describe atomic potentials.\n\nThere are some projects that explore differentiable molecular simulations - see Related software. However Julia provides a strong suite of AD tools, with Enzyme.jl allowing source-to-source transformations for much of the language. With Molly you can use the power of Enzyme to obtain gradients through molecular simulations, even in the presence of complex interactions such as PME or implicit solvation and stochasticity such as Langevin dynamics or the Andersen thermostat. Reverse and forward mode AD can be used on the CPU with multithreading and on the GPU; performance is typically within an order of magnitude of the primal run. Pairwise, specific and general interactions work, along with neighbor lists, and the same abstractions for running simulations are used as in the main package.\n\nDifferentiable simulation does not currently work with units and some components of the package. This is mentioned in the relevant docstrings. It is memory intensive on the GPU so using gradient checkpointing, e.g. with Checkpointing.jl, will likely be required for larger simulations.","category":"section"},{"location":"differentiable/#Pairwise-interaction-gradients","page":"Differentiable simulation","title":"Pairwise interaction gradients","text":"First, we show how taking gradients through a simulation can be used to optimise an atom property in a Lennard-Jones fluid. In this type of simulation each atom has a σ value that determines how close it likes to get to other atoms. We are going to find the σ value that results in a desired distance of each atom to its closest neighbor. First we need a function to obtain the mean distance of each atom to its closest neighbor:\n\nusing Molly, Statistics\n\nfunction mean_min_separation(coords, boundary)\n    min_seps = Float64[]\n    for i in eachindex(coords)\n        min_sq_sep = 100.0\n        for j in eachindex(coords)\n            if i != j\n                sq_dist = sum(abs2, vector(coords[i], coords[j], boundary))\n                min_sq_sep = min(sq_dist, min_sq_sep)\n            end\n        end\n        push!(min_seps, sqrt(min_sq_sep))\n    end\n    return mean(min_seps)\nend\n\nNow we can set up and run the simulation in a similar way to that described in the Molly documentation. The difference is that we wrap the simulation in a loss function. This returns a single value that we want to obtain gradients with respect to, in this case the difference between the value of the above function at the end of the simulation and a target distance.\n\ndist_true = 0.5\nscale_σ_to_dist = 2 ^ (1 / 6)\nσtrue = dist_true / scale_σ_to_dist\n\nn_atoms = 50\nn_steps = 500\natom_mass = 10.0\nboundary = CubicBoundary(3.0)\ntemp = 1.0\nsimulator = VelocityVerlet(\n    dt=0.02,\n    coupling=ImmediateThermostat(temp),\n)\ncoords = place_atoms(n_atoms, boundary; min_dist=0.6)\nvelocities = [random_velocity(atom_mass, temp) for i in 1:n_atoms]\nlj = LennardJones(cutoff=DistanceCutoff(1.5), use_neighbors=true)\npairwise_inters = (lj,)\nneighbor_finder = DistanceNeighborFinder(\n    eligible=trues(n_atoms, n_atoms),\n    n_steps=10,\n    dist_cutoff=1.8,\n)\n\nfunction loss(σ, coords, velocities, boundary, pairwise_inters,\n              neighbor_finder, simulator, n_steps, n_atoms, atom_mass, dist_true)\n    atoms = [Atom(i, 1, atom_mass, 0.0, σ, 0.2) for i in 1:n_atoms]\n\n    sys = System(\n        atoms=atoms,\n        coords=coords,\n        boundary=boundary,\n        velocities=velocities,\n        pairwise_inters=pairwise_inters,\n        neighbor_finder=neighbor_finder,\n        force_units=NoUnits,\n        energy_units=NoUnits,\n    )\n\n    simulate!(sys, simulator, n_steps)\n    mms_end = mean_min_separation(sys.coords, boundary)\n    loss_val = abs(mms_end - dist_true)\n\n    print(\n        \"σ \", round(σ; digits=3), \"  |  Mean min sep expected \", round(σ * (2 ^ (1 / 6)); digits=3),\n        \"  |  Mean min sep end \", round(mms_end; digits=3), \"  |  Loss \", round(loss_val; digits=3),\n        \"  |  \",\n    )\n\n    return loss_val\nend\n\nWe can obtain the gradient of loss with respect to the atom property σ using Enzyme.\n\nusing Enzyme\n\nconst_args = [\n    Const(boundary), Const(pairwise_inters), Const(neighbor_finder),\n    Const(simulator), Const(n_steps), Const(n_atoms),\n    Const(atom_mass), Const(dist_true),\n]\n\ngrad_enzyme = autodiff(\n    set_runtime_activity(Reverse), loss, Active, Active(σtrue),\n    Duplicated(coords, zero(coords)), Duplicated(velocities, zero(velocities)),\n    const_args...,\n)[1][1]\n\nThis gradient can be used in a training loop to optimise σ, starting from an arbitrary value.\n\nfunction train()\n    σlearn = 0.60 / scale_σ_to_dist\n    n_epochs = 15\n\n    for epoch_n in 1:n_epochs\n        print(\"Epoch \", epoch_n, \"  |  \")\n        coords = place_atoms(n_atoms, boundary; min_dist=0.6)\n        velocities = [random_velocity(atom_mass, temp) for i in 1:n_atoms]\n        grad = autodiff(\n            set_runtime_activity(Reverse), loss, Active, Active(σlearn),\n            Duplicated(coords, zero(coords)), Duplicated(velocities, zero(velocities)),\n            const_args...,\n        )[1][1]\n        println(\"Grad \", round(grad; digits=3))\n        σlearn -= grad * 1e-2\n    end\nend\n\ntrain()\n\nEpoch 1  |  σ 0.535  |  Mean min sep expected 0.6  |  Mean min sep end 0.59  |  Loss 0.09  |  Grad 1.495\nEpoch 2  |  σ 0.52  |  Mean min sep expected 0.583  |  Mean min sep end 0.577  |  Loss 0.077  |  Grad 0.721\nEpoch 3  |  σ 0.512  |  Mean min sep expected 0.575  |  Mean min sep end 0.562  |  Loss 0.062  |  Grad 1.066\nEpoch 4  |  σ 0.502  |  Mean min sep expected 0.563  |  Mean min sep end 0.553  |  Loss 0.053  |  Grad 0.435\nEpoch 5  |  σ 0.497  |  Mean min sep expected 0.558  |  Mean min sep end 0.552  |  Loss 0.052  |  Grad 0.398\nEpoch 6  |  σ 0.493  |  Mean min sep expected 0.554  |  Mean min sep end 0.551  |  Loss 0.051  |  Grad 0.318\nEpoch 7  |  σ 0.49  |  Mean min sep expected 0.55  |  Mean min sep end 0.536  |  Loss 0.036  |  Grad 1.291\nEpoch 8  |  σ 0.477  |  Mean min sep expected 0.536  |  Mean min sep end 0.533  |  Loss 0.033  |  Grad 0.257\nEpoch 9  |  σ 0.475  |  Mean min sep expected 0.533  |  Mean min sep end 0.53  |  Loss 0.03  |  Grad 0.539\nEpoch 10  |  σ 0.469  |  Mean min sep expected 0.527  |  Mean min sep end 0.535  |  Loss 0.035  |  Grad 1.253\nEpoch 11  |  σ 0.457  |  Mean min sep expected 0.513  |  Mean min sep end 0.504  |  Loss 0.004  |  Grad 1.453\nEpoch 12  |  σ 0.442  |  Mean min sep expected 0.496  |  Mean min sep end 0.491  |  Loss 0.009  |  Grad -1.07\nEpoch 13  |  σ 0.453  |  Mean min sep expected 0.508  |  Mean min sep end 0.504  |  Loss 0.004  |  Grad 1.599\nEpoch 14  |  σ 0.437  |  Mean min sep expected 0.49  |  Mean min sep end 0.494  |  Loss 0.006  |  Grad -0.181\nEpoch 15  |  σ 0.439  |  Mean min sep expected 0.493  |  Mean min sep end 0.49  |  Loss 0.01  |  Grad -1.355\n\nThe final value we get is 0.439, close to the theoretical value of 0.445 if all atoms have a neighbor at the minimum pairwise energy distance. The RDF looks as follows, with the purple line corresponding to the desired distance to the closest neighbor. (Image: LJ RDF)\n\nTo make this run on the GPU the appropriate objects should be transferred to the GPU with CuArray: coords, velocities, atoms and the eligible matrix for the neighbor finder. If using custom interactions or some built-in interactions you may need to define methods of zero and + for your interaction type.\n\nIt is common to require a loss function formed from values throughout a simulation. In this case it is recommended to split up the simulation into a set of short simulations in the loss function, each starting from the previous final coordinates and velocities. This runs an identical simulation but makes the intermediate coordinates and velocities available for use in calculating the final loss. For example, the RMSD could be calculated from the coordinates every 100 steps and added to a variable that is then divided by the number of chunks to get a loss value corresponding to the mean RMSD over the simulation.","category":"section"},{"location":"differentiable/#Specific-interaction-gradients","page":"Differentiable simulation","title":"Specific interaction gradients","text":"Next we look at obtaining gradients through simulations with specific interactions, e.g. bonds or angles between specified atoms. We will simulate two triatomic molecules and search for a minimum energy bond angle that gives a desired distance between the atoms at the end of the simulation.\n\nusing Molly, Enzyme, LinearAlgebra\n\ndist_true = 1.0\nn_steps = 150\natom_mass = 10.0\nboundary = CubicBoundary(3.0)\ntemp = 0.05\ncoords = [\n    SVector(0.8, 0.75, 1.5), SVector(1.5, 0.70, 1.5), SVector(2.3, 0.75, 1.5),\n    SVector(0.8, 2.25, 1.5), SVector(1.5, 2.20, 1.5), SVector(2.3, 2.25, 1.5),\n]\nn_atoms = length(coords)\nvelocities = zero(coords)\natoms = [Atom(i, 1, atom_mass, 0.0, 0.0, 0.0) for i in 1:n_atoms]\nsimulator = VelocityVerlet(\n    dt=0.05,\n    coupling=BerendsenThermostat(temp, 0.5),\n)\nbonds = InteractionList2Atoms(\n    [1, 2, 4, 5],\n    [2, 3, 5, 6],\n    [HarmonicBond(100.0, 0.7) for _ in 1:4],\n)\n\nfunction loss(θ, coords, velocities, atoms, bonds, boundary, simulator, n_steps,\n              n_atoms, atom_mass, dist_true)\n    angles = InteractionList3Atoms(\n        [1, 4],\n        [2, 5],\n        [3, 6],\n        [HarmonicAngle(10.0, θ), HarmonicAngle(10.0, θ)],\n    )\n\n    sys = System(\n        atoms=atoms,\n        coords=coords,\n        boundary=boundary,\n        velocities=velocities,\n        specific_inter_lists=(bonds, angles),\n        force_units=NoUnits,\n        energy_units=NoUnits,\n    )\n\n    simulate!(sys, simulator, n_steps)\n\n    d1 = norm(vector(sys.coords[1], sys.coords[3], boundary))\n    d2 = norm(vector(sys.coords[4], sys.coords[6], boundary))\n    dist_end = 0.5 * (d1 + d2)\n    loss_val = abs(dist_end - dist_true)\n\n    print(\n        \"θ \", round(rad2deg(θ); digits=1), \"°  |  Final dist \", round(dist_end; digits=2),\n        \"  |  Loss \", round(loss_val; digits=3), \"  |  \",\n    )\n\n    return loss_val\nend\n\nconst_args = [\n    Const(atoms), Const(bonds), Const(boundary), Const(simulator),\n    Const(n_steps), Const(n_atoms), Const(atom_mass), Const(dist_true),\n]\n\nfunction train()\n    θlearn = deg2rad(110.0)\n    n_epochs = 20\n\n    for epoch_n in 1:n_epochs\n        print(\"Epoch \", epoch_n, \"  |  \")\n        grad = autodiff(\n            set_runtime_activity(Reverse), loss, Active, Active(θlearn),\n            Duplicated(copy(coords), zero(coords)), Duplicated(copy(velocities), zero(velocities)),\n            const_args...,\n        )[1][1]\n        println(\"Grad \", round(grad; digits=2))\n        θlearn -= grad * 0.1\n    end\nend\n\ntrain()\n\nEpoch 1  |  θ 110.0°  |  Final dist 1.16  |  Loss 0.155  |  Grad 0.41\nEpoch 2  |  θ 107.7°  |  Final dist 1.14  |  Loss 0.138  |  Grad 0.43\nEpoch 3  |  θ 105.2°  |  Final dist 1.12  |  Loss 0.119  |  Grad 0.45\nEpoch 4  |  θ 102.6°  |  Final dist 1.1  |  Loss 0.099  |  Grad 0.47\nEpoch 5  |  θ 100.0°  |  Final dist 1.08  |  Loss 0.077  |  Grad 0.49\nEpoch 6  |  θ 97.2°  |  Final dist 1.05  |  Loss 0.049  |  Grad 0.71\nEpoch 7  |  θ 93.1°  |  Final dist 1.01  |  Loss 0.012  |  Grad 0.52\nEpoch 8  |  θ 90.1°  |  Final dist 0.98  |  Loss 0.015  |  Grad -0.54\nEpoch 9  |  θ 93.2°  |  Final dist 1.01  |  Loss 0.013  |  Grad 0.52\nEpoch 10  |  θ 90.2°  |  Final dist 0.99  |  Loss 0.015  |  Grad -0.54\nEpoch 11  |  θ 93.3°  |  Final dist 1.01  |  Loss 0.014  |  Grad 0.52\nEpoch 12  |  θ 90.3°  |  Final dist 0.99  |  Loss 0.014  |  Grad -0.54\nEpoch 13  |  θ 93.4°  |  Final dist 1.01  |  Loss 0.015  |  Grad 0.52\nEpoch 14  |  θ 90.4°  |  Final dist 0.99  |  Loss 0.013  |  Grad -0.54\nEpoch 15  |  θ 93.5°  |  Final dist 1.02  |  Loss 0.016  |  Grad 0.52\nEpoch 16  |  θ 90.5°  |  Final dist 0.99  |  Loss 0.012  |  Grad -0.54\nEpoch 17  |  θ 93.6°  |  Final dist 1.02  |  Loss 0.016  |  Grad 0.52\nEpoch 18  |  θ 90.6°  |  Final dist 0.99  |  Loss 0.011  |  Grad -0.53\nEpoch 19  |  θ 93.7°  |  Final dist 1.02  |  Loss 0.017  |  Grad 0.52\nEpoch 20  |  θ 90.7°  |  Final dist 0.99  |  Loss 0.01  |  Grad -0.53\n\nThe final value we get is 90.7°, close to the theoretical value of 91.2° which can be calculated with trigonometry. The final simulation looks like this: (Image: Angle simulation) In the presence of other forces this value would not be so trivially obtainable. We can record the gradients for different values of θ:\n\nθs = collect(0:3:180)[2:end]\ngrads = [autodiff(\n            set_runtime_activity(Reverse), loss, Active, Active(deg2rad(θ)),\n            Duplicated(copy(coords), zero(coords)), Duplicated(copy(velocities), zero(velocities)),\n            const_args...,\n        )[1][1] for θ in θs]\n\nThe plot of these shows that the gradient has the expected sign either side of the correct value: (Image: Angle gradient)","category":"section"},{"location":"differentiable/#Neural-network-potentials","page":"Differentiable simulation","title":"Neural network potentials","text":"Flux models can also be incorporated into simulations. Here we show a neural network in the force function, though they can also be used in other parts of the simulation. This example also shows how gradients for multiple parameters can be obtained, in this case the parameters of the neural network. The jump from single to multiple parameters is important because single parameters can be optimised using finite differencing, whereas differentiable simulation is well-placed to optimise many parameters simultaneously.\n\nWe set up three pseudo-atoms and train a network to imitate the Julia logo by moving the bottom two atoms:\n\nusing Molly\nusing Enzyme\nusing Flux\nimport AtomsCalculators\nimport GLMakie\nusing LinearAlgebra\n\nmodel = Chain(\n    Dense(1, 5, relu),\n    Dense(5, 1, tanh),\n)\n\nstruct NNBonds{T}\n    model::T\nend\n\nfunction AtomsCalculators.forces!(fs, sys, inter::NNBonds; kwargs...)\n    vec_ij = vector(sys.coords[1], sys.coords[3], sys.boundary)\n    dist = norm(vec_ij)\n    f = inter.model([dist])[1] * normalize(vec_ij)\n    fs .+= [f, zero(f), -f]\n    return fs\nend\n\ndist_true = 1.0f0\nn_steps = 400\nboundary = CubicBoundary(5.0f0)\ntemp = 0.01f0\ncoords = [\n    SVector(2.3f0, 2.07f0, 0.0f0),\n    SVector(2.5f0, 2.93f0, 0.0f0),\n    SVector(2.7f0, 2.07f0, 0.0f0),\n]\nn_atoms = length(coords)\nvelocities = zero(coords)\natoms = [Atom(i, 1, 10.0f0, 0.0f0, 0.0f0, 0.0f0) for i in 1:n_atoms]\nsimulator = VelocityVerlet(\n    dt=0.02f0,\n    coupling=BerendsenThermostat(temp, 0.5f0),\n)\n\nfunction loss(model, coords, velocities, atoms, boundary, simulator, n_steps, dist_true)\n    loggers = (coords=CoordinatesLogger(Float32, 10),)\n    general_inters = (NNBonds(model),)\n\n    sys = System(\n        atoms=atoms,\n        coords=coords,\n        boundary=boundary,\n        velocities=velocities,\n        general_inters=general_inters,\n        loggers=loggers,\n        force_units=NoUnits,\n        energy_units=NoUnits,\n    )\n\n    simulate!(sys, simulator, n_steps)\n\n    dist_end = (norm(vector(sys.coords[1], sys.coords[2], boundary)) +\n                norm(vector(sys.coords[2], sys.coords[3], boundary)) +\n                norm(vector(sys.coords[3], sys.coords[1], boundary))) / 3\n    loss_val = abs(dist_end - dist_true)\n\n    println(\"Dist end \", round(dist_end; digits=3), \"  |  Loss \", round(loss_val; digits=3))\n    visualize(sys.loggers.coords, boundary, \"sim.mp4\"; show_boundary=false)\n\n    return loss_val\nend\n\nBefore training the result looks like this: (Image: Logo before)\n\nfunction train()\n    model = Chain(\n        Dense(1, 5, relu),\n        Dense(5, 1, tanh),\n    )\n    opt = Optimisers.setup(ADAM(0.02, (0.9, 0.999)), model)\n    n_epochs = 20\n\n    for epoch_n in 1:n_epochs\n        print(\"Epoch \", epoch_n, \"  |  \")\n        d_model = Flux.fmap(model) do x\n            x isa Array ? zero(x) : x\n        end\n        autodiff(\n            set_runtime_activity(Reverse), loss, Active, Duplicated(model, d_model),\n            Duplicated(copy(coords), zero(coords)), Duplicated(copy(velocities), zero(velocities)),\n            Const(atoms), Const(boundary), Const(simulator), Const(n_steps), Const(dist_true),\n        )\n        opt, model = Optimisers.update!(opt, model, d_model)\n    end\nend\n\ntrain()\n\nEpoch 1  |  Dist end 0.821  |  Loss 0.179\nEpoch 2  |  Dist end 0.859  |  Loss 0.141\nEpoch 3  |  Dist end 0.902  |  Loss 0.098\nEpoch 4  |  Dist end 0.948  |  Loss 0.052\nEpoch 5  |  Dist end 0.996  |  Loss 0.004\nEpoch 6  |  Dist end 1.044  |  Loss 0.044\nEpoch 7  |  Dist end 1.069  |  Loss 0.069\nEpoch 8  |  Dist end 1.08  |  Loss 0.08\nEpoch 9  |  Dist end 1.081  |  Loss 0.081\nEpoch 10  |  Dist end 1.073  |  Loss 0.073\nEpoch 11  |  Dist end 1.06  |  Loss 0.06\nEpoch 12  |  Dist end 1.042  |  Loss 0.042\nEpoch 13  |  Dist end 1.019  |  Loss 0.019\nEpoch 14  |  Dist end 0.994  |  Loss 0.006\nEpoch 15  |  Dist end 0.978  |  Loss 0.022\nEpoch 16  |  Dist end 0.97  |  Loss 0.03\nEpoch 17  |  Dist end 0.968  |  Loss 0.032\nEpoch 18  |  Dist end 0.973  |  Loss 0.027\nEpoch 19  |  Dist end 0.982  |  Loss 0.018\nEpoch 20  |  Dist end 0.995  |  Loss 0.005\n\nAfter training it looks much better: (Image: Logo after) You could replace the simple network here with a much more complicated model and it would theoretically be able to train, even if it might prove practically difficult (see discussion below).","category":"section"},{"location":"differentiable/#Biomolecular-force-fields","page":"Differentiable simulation","title":"Biomolecular force fields","text":"Molly was used to train the GB99dms force field for implicit solvent molecular dynamics of proteins. This involved doing differentiable simulations of one million steps with a loss function based on the residue-residue distance match to explicit solvent simulations. The code is available.","category":"section"},{"location":"differentiable/#Reversible-simulation","page":"Differentiable simulation","title":"Reversible simulation","text":"Molly.jl was also used to code reversible simulation, an extension of differentiable simulation with RAD where the gradients are calculated explicitly. This means the memory cost is constant in step number.","category":"section"},{"location":"differentiable/#Molecular-loss-functions","page":"Differentiable simulation","title":"Molecular loss functions","text":"Ultimately, you need some objective function in order to calculate the gradient for each parameter. Here are some ideas for loss functions suitable for differentiable molecular simulations:\n\nThe distance between atoms at the end of the simulation compared to some reference state. This loss is used in the examples given here, is physically reasonable, and has obvious bounds.\nThe distance between atoms throughout the simulation.\nThe radial distribution function of atoms.\nRMSD between atoms and a reference state - this would be suitable for macromolecules.\ndRMSD, the distance between a distance map and a reference distance map.\nThe radius of gyration of a molecule.\nThe flexibility of a set of atoms over the simulation.\nSupramolecular geometry, for example assembly of molecules into straight fibres.\nThe correlation of different velocities over the simulation.\nThe energy of the system.\nThe temperature of the system.\nSome measure of phase change or a critical point.\nA combination of the above, for example to obtain a force field relevant to both ordered and disordered proteins.\n\nSome of these are currently not possible in Molly as the loggers are ignored for gradient purposes, but this will hopefully change in future.","category":"section"},{"location":"differentiable/#Tips-and-tricks","page":"Differentiable simulation","title":"Tips and tricks","text":"The magnitude of gradients may be less important than the sign. Consider sampling gradients across different sources of stochasticity, such as starting velocities and conformations.\nExploding gradients prove a problem when using the velocity Verlet integrator in the NVE ensemble. This is why the velocity rescaling and Berendsen thermostats were used in the above examples. Langevin dynamics also seems to work. It is likely that the development of suitable simulation strategies and thermostats will be necessary to unlock the potential of differentiable simulation.\nForward mode AD holds much promise for differentiable simulation, provided that the number of parameters is small, because the memory requirement is constant in the number of simulation steps. However, if the code runs slower than non-differentiable alternatives then the best approach is likely to use finite differencing with the simulation as a black box. Adjoint sensitivity is another approach to getting gradients which is not yet available in Molly.jl.","category":"section"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://github.com/JuliaMolSim/Molly.jl/blob/master/docs/src/images/logo_molly.png\" alt=\"Molly logo\" width=\"400\">\n\n(Image: Build status) (Image: Coverage status) (Image: Latest release) (Image: License) (Image: Documentation stable) (Image: Documentation dev)\n\nMuch of science can be explained by the movement and interaction of molecules. Molecular dynamics (MD) is a computational technique used to explore these phenomena, from noble gases to biological macromolecules. Molly.jl is a pure Julia package for MD, and for the simulation of physical systems more broadly.\n\nThe package is described in a talk at JuliaCon 2024, an earlier talk at Enzyme Conference 2023 and a tutorial at the MolSSI JuliaMolSim Workshop 2024. Slides are also available for a tutorial in 2025.\n\nImplemented features include:\n\nNon-bonded interactions - Lennard-Jones van der Waals/repulsion force, electrostatic Coulomb potential and reaction field, gravitational potential, soft sphere potential, Mie potential, Buckingham potential, soft core variants for alchemical simulation.\nBonded interactions - harmonic and Morse bonds, bond angles, torsion angles, harmonic position restraints, FENE bonds.\nEwald and particle mesh Ewald (PME) electrostatic summation.\nInterface to allow definition of new interactions, simulators, thermostats, neighbor finders, loggers etc.\nRead in OpenMM force field files and coordinate files supported by Chemfiles.jl. There is also experimental support for Gromacs files.\nWrite out trajectory files in formats supported by Chemfiles.jl, including DCD and XTC.\nVerlet, velocity Verlet, Störmer-Verlet, flexible Langevin and Nosé-Hoover integrators.\nAndersen, Berendsen and velocity rescaling thermostats.\nC-rescale, Monte Carlo and Berendsen barostats with flexible virial calculation.\nSteepest descent energy minimization.\nReplica exchange molecular dynamics.\nMonte Carlo simulation.\nPeriodic, triclinic and infinite boundary conditions.\nConstraints with SHAKE and RATTLE\nFlexible loggers to track arbitrary properties throughout simulations.\nCutoff algorithms for non-bonded interactions.\nVarious neighbor list implementations to speed up the calculation of non-bonded forces, including the use of CellListMap.jl.\nImplicit solvent GBSA methods.\nUnitful.jl compatibility so numbers have physical meaning.\nSet up crystal systems using SimpleCrystals.jl.\nAutomatic multithreading.\nGPU acceleration on all backends supported by KernelAbstractions.jl, with better performance on CUDA-enabled devices.\nRun with Float64, Float32 or other float types.\nSome analysis functions, e.g. RDF.\nVisualise simulations as animations with Makie.jl.\nCompatibility with AtomsBase.jl and AtomsCalculators.jl.\nInterface to use Python ASE calculators.\nControl of random numbers during simulation, allowing reproducible stochastic simulations.\nDifferentiable molecular simulation. This is a unique feature of the package and the focus of its current development.\n\nFeatures not yet implemented include:\n\nOptimal GPU performance - currently we are ~5x slower than OpenMM on CUDA GPUs.\nProtein preparation - solvent box, add hydrogens etc.\nSimulators such as metadynamics.\nQuantum mechanical modelling.\nDomain decomposition algorithms.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Julia is required, with Julia v1.10 or later required to get the latest version of Molly. It is recommended to run on the current stable Julia release for the best performance. Install Molly from the Julia REPL. Enter the package mode by pressing ] and run add Molly. If you want to run on a GPU you will also need to install the appropriate package, e.g. add CUDA.","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"Some examples are given here, see the documentation for more on how to use the package.\n\nSimulation of a Lennard-Jones fluid:\n\nusing Molly\n\nn_atoms = 100\nboundary = CubicBoundary(2.0u\"nm\")\ntemp = 298.0u\"K\"\natom_mass = 10.0u\"g/mol\"\n\natoms = [Atom(mass=atom_mass, σ=0.3u\"nm\", ϵ=0.2u\"kJ * mol^-1\") for i in 1:n_atoms]\ncoords = place_atoms(n_atoms, boundary; min_dist=0.3u\"nm\")\nvelocities = [random_velocity(atom_mass, temp) for i in 1:n_atoms]\npairwise_inters = (LennardJones(),)\nsimulator = VelocityVerlet(\n    dt=0.002u\"ps\",\n    coupling=AndersenThermostat(temp, 1.0u\"ps\"),\n)\n\nsys = System(\n    atoms=atoms,\n    coords=coords,\n    boundary=boundary,\n    velocities=velocities,\n    pairwise_inters=pairwise_inters,\n    loggers=(temp=TemperatureLogger(100),),\n)\n\nsimulate!(sys, simulator, 10_000)\n\nSimulation of a protein on GPU:\n\nusing Molly, CUDA\n\ndata_dir = joinpath(dirname(pathof(Molly)), \"..\", \"data\")\nT = Float32\nff = MolecularForceField(\n    T,\n    joinpath(data_dir, \"force_fields\", \"ff99SBildn.xml\"),\n    joinpath(data_dir, \"force_fields\", \"tip3p_standard.xml\"),\n    joinpath(data_dir, \"force_fields\", \"his.xml\"),\n)\n\nsys = System(\n    joinpath(data_dir, \"6mrr_equil.pdb\"),\n    ff;\n    nonbonded_method=:pme,\n    loggers=(\n        energy=TotalEnergyLogger(10),\n        writer=TrajectoryWriter(10, \"traj_6mrr_5ps.dcd\"),\n    ),\n    array_type=CuArray,\n)\n\nminimizer = SteepestDescentMinimizer()\nsimulate!(sys, minimizer)\n\ntemp = T(298.0)u\"K\"\nrandom_velocities!(sys, temp)\nsimulator = Langevin(\n    dt=T(0.001)u\"ps\",\n    temperature=temp,\n    friction=T(1.0)u\"ps^-1\",\n    coupling=MonteCarloBarostat(T(1.0)u\"bar\", temp, sys.boundary),\n)\n\nsimulate!(sys, simulator, 5_000)\n\nThe above 5 ps simulation looks something like this when you view it in PyMOL: (Image: MD simulation)","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"Contributions are very welcome including reporting bugs, fixing bugs, adding new features, improving performance, adding tests and improving documentation. Feel free to open an issue or use the channels below to discuss your contribution. New features will generally require tests to be added as well. As described in the documentation, potentials implementing the AtomsCalculators interface can be used with Molly. If you have an interesting example of such a potential in your package, do contribute an example to the Molly documentation. See the roadmap issue for some discussion of recent progress and future plans.\n\nJoin the #molly channel on the JuliaMolSim Zulip, the #juliamolsim channel on the Julia Slack or post on the Julia Discourse to discuss the usage and development of Molly.jl.\n\nMolly.jl follows the Contributor Covenant code of conduct.","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use Molly, please cite the following paper (bib entry here):\n\nGreener JG. Differentiable simulation to develop molecular dynamics force fields for disordered proteins, Chemical Science 15, 4897-4909 (2024)\n\nA paper involving more contributors with further details on the software will be written at some point.","category":"section"},{"location":"documentation/#Molly-documentation","page":"Documentation","title":"Molly documentation","text":"This documentation will first introduce the main features of the package with some examples, then will give details on each component of a simulation. There are further examples in the Molly examples section. For more information on specific types or functions, see the Molly API section or call ?function_name in Julia. The Differentiable simulation with Molly section describes taking gradients through simulations and the Free energies with MBAR section covers an approach to estimate free energies.\n\nThe package takes a modular approach to molecular simulation. To run a simulation you create a System object and call simulate! on it. The different components of the system and simulation can be used as defined by the package, or you can define your own versions. An important principle of the package is that your custom components, particularly force and potential energy functions, should be easy to define and just as performant as the built-in versions.","category":"section"},{"location":"documentation/#Simulation-basics","page":"Documentation","title":"Simulation basics","text":"Let's look at the simulation of a fluid acting under the Lennard-Jones potential to start with. First, we'll need some atoms with the relevant parameters defined.\n\nusing Molly\n\nn_atoms = 100\natom_mass = 10.0u\"g/mol\"\natoms = [Atom(mass=atom_mass, σ=0.3u\"nm\", ϵ=0.2u\"kJ * mol^-1\") for i in 1:n_atoms]\n\nSee the Unitful.jl documentation for more information on the unit annotations. Molly re-exports Unitful.jl and StaticArrays.jl since they are often required to run simulations. You can use your own atom types in Molly, provided that the mass function is defined and any fields required by the interactions are present. Next, we'll need some starting coordinates and velocities.\n\nboundary = CubicBoundary(2.0u\"nm\") # Periodic boundary conditions with a 2 nm cube\ncoords = place_atoms(n_atoms, boundary; min_dist=0.3u\"nm\") # Random placement without clashing\n\ntemp = 100.0u\"K\"\nvelocities = [random_velocity(atom_mass, temp) for i in 1:n_atoms]\n\nWe store the coordinates and velocities as static arrays for performance. They can be of 2 or 3 dimensions and of any number type, e.g. Float64 or Float32. Setting individual dimensions in a CubicBoundary to Inf * u\"nm\" makes the simulation have no boundary in that dimension. You can also use a TriclinicBoundary. Simulations in 2 dimensions should use a RectangularBoundary.\n\nThe vector function calculates the vector from one coordinate to another accounting for periodic boundary conditions by using the minimum image convention:\n\nvector(coords[1], coords[2], boundary)\n\n3-element SVector{3, Quantity{Float64, 𝐋, Unitful.FreeUnits{(nm,), 𝐋, nothing}}} with indices SOneTo(3):\n -0.8619698558762985 nm\n -0.9475020064484192 nm\n  0.8359421827141784 nm\n\nNow we can define our pairwise interactions, i.e. those between most or all atom pairs, as a tuple. Because we have defined the relevant parameters for the atoms, we can use the built-in LennardJones type.\n\npairwise_inters = (LennardJones(),) # Don't forget the trailing comma!\n\nFinally, we can define the system and run the simulation. We use an AndersenThermostat to keep a constant temperature, and we log the temperature and coordinates every 10 steps. Periodic boundary conditions are automatically used with the cubic box we defined earlier.\n\nsys = System(\n    atoms=atoms,\n    coords=coords,\n    boundary=boundary,\n    velocities=velocities,\n    pairwise_inters=pairwise_inters,\n    loggers=(\n        temp=TemperatureLogger(10),\n        coords=CoordinatesLogger(10),\n    ),\n)\n\nsimulator = VelocityVerlet(\n    dt=0.002u\"ps\",\n    coupling=AndersenThermostat(temp, 1.0u\"ps\"),\n)\n\nsimulate!(sys, simulator, 1_000)\n\natoms, coords and boundary are the minimum required properties to define a System, though you would generally want to add interactions to a System to do something useful with it. The data keyword argument can give arbitrary data to the System that can be accessed with sys.data, for example metadata or properties to be used with a custom simulator. System implements the AbstractSystem interface from AtomsBase.jl. Various functions can be used on a System:\n\npotential_energy(sys) # -40.91077282719628 kJ mol^-1\nkinetic_energy(sys)   # 119.47758705080862 kJ mol^-1\ntotal_energy(sys)     #  78.56681422361234 kJ mol^-1\n\nforces(sys)\naccelerations(sys)\nvirial(sys)\npressure(sys)\ndipole_moment(sys)\n\nmasses(sys)\ndensity(sys) # 207.56738339673083 kg m^-3\ntemperature(sys) # 96.76667184796673 K\nrandom_velocities(sys, 300.0u\"K\")\n\nfloat_type(sys) # Float64\nis_on_gpu(sys)  # false\n\n# Access properties\nsys.atoms\nsys.coords\nsys.boundary\nsys.velocities\nsys.topology\nsys.pairwise_inters\nsys.constraints\nsys.neighbor_finder\nsys.loggers\nsys.total_mass\n\n# Write out the system to a file\nwrite_structure(\"file.pdb\", sys)\nwrite_structure(\"file.mol2\", sys)\n\n# AtomsBase.jl interface\nimport AtomsBase\nAtomsBase.mass(sys, 5) # 10.0 u\nAtomsBase.position(sys, 10)\n\n# Define a new system with certain properties changed\nSystem(sys; coords=(sys.coords .* 0.5))\n\nBy default the simulation is run in parallel on the number of threads available to Julia, but this behaviour can be changed by giving the keyword argument n_threads to simulate!. For example, n_threads=1 uses no parallelization. n_threads=4 will limit the simulation to 4 threads. Sometimes setting n_threads higher than the number of available threads can improve performance.\n\nThe values stored by the loggers can be accessed using values, e.g. values(sys.loggers.coords). An animation of the stored coordinates can be saved by using visualize, which is available when GLMakie.jl is imported.\n\nusing GLMakie\nvisualize(sys.loggers.coords, boundary, \"sim_lj.mp4\")\n\n(Image: LJ simulation)\n\nA Molly System can also be constructed from an AtomsBase.jl system. For example:\n\nSystem(ab_sys; force_units=u\"kJ/Å\", energy_units=u\"kJ\")","category":"section"},{"location":"documentation/#GPU-acceleration","page":"Documentation","title":"GPU acceleration","text":"To run simulations on the GPU you will need to have a GPU available and then load the appropriate package:\n\nHardware available Necessary package Array type\nParallel CPU none Array\nNVIDIA GPU CUDA CuArray\nAMD GPU AMDGPU ROCArray\nIntel GPU oneAPI oneArray\nApple Silicon Metal MtlArray\n\nModern GPUs can run simulations of over 100,000 atoms, as seen in the examples. Metal/Apple Silicon devices can only run with 32 bit precision, so be sure to use Float32 in this case. Non-CUDA backends are less well-tested with Molly than CUDA.\n\nSimulation setup is similar to above, but with the coordinates, velocities and atoms moved to the GPU. This example also shows setting up a simulation to run with Float32, which gives much better performance on GPUs. Of course, you will need to determine whether this level of numerical accuracy is appropriate in your case. Here is an example script for an NVIDIA GPU using CUDA:\n\nusing Molly\nusing CUDA\n\nn_atoms = 100\natom_mass = 10.0f0u\"g/mol\"\nboundary = CubicBoundary(2.0f0u\"nm\")\ntemp = 100.0f0u\"K\"\natoms = CuArray([Atom(mass=atom_mass, σ=0.3f0u\"nm\", ϵ=0.2f0u\"kJ * mol^-1\") for i in 1:n_atoms])\ncoords = CuArray(place_atoms(n_atoms, boundary; min_dist=0.3u\"nm\"))\nvelocities = CuArray([random_velocity(atom_mass, temp) for i in 1:n_atoms])\nsimulator = VelocityVerlet(dt=0.002f0u\"ps\")\n\nsys = System(\n    atoms=atoms,\n    coords=coords,\n    boundary=boundary,\n    velocities=velocities,\n    pairwise_inters=(LennardJones(),),\n    loggers=(\n        temp=TemperatureLogger(typeof(1.0f0u\"K\"), 10),\n        coords=CoordinatesLogger(typeof(1.0f0u\"nm\"), 10),\n    ),\n)\n\nsimulate!(deepcopy(sys), simulator, 20) # Compile function\nsimulate!(sys, simulator, 1_000)\n\nTo use another GPU package, just swap out CUDA for your desired package and CuArray for your desired array type. The device to run on can be changed with device!, e.g. device!(1). There are two GPU code paths currently: a fast path specific to CUDA and a slower path using KernelAbstractions.jl that is suitable for all backends.\n\nThe number of GPU threads used for the GPU kernels can be tuned with the environmental variables MOLLY_GPUNTHREADS_PAIRWISE, MOLLY_GPUNTHREADS_SPECIFIC, MOLLY_GPUNTHREADS_DISTANCENF and MOLLY_GPUNTHREADS_IMPLICIT. In general these should only be changed if GPU memory errors occur on smaller GPUs.","category":"section"},{"location":"documentation/#Simulating-diatomic-molecules","page":"Documentation","title":"Simulating diatomic molecules","text":"If we want to define specific interactions between atoms, for example bonds, we can do this as well. Using the same definitions as the first example, let's set up the coordinates so that paired atoms are 1 Å apart.\n\natoms = [Atom(mass=atom_mass, σ=0.3u\"nm\", ϵ=0.2u\"kJ * mol^-1\") for i in 1:n_atoms]\n\ncoords = place_atoms(n_atoms ÷ 2, boundary; min_dist=0.3u\"nm\")\nfor i in 1:length(coords)\n    push!(coords, coords[i] .+ [0.1, 0.0, 0.0]u\"nm\")\nend\n\nvelocities = [random_velocity(atom_mass, temp) for i in 1:n_atoms]\n\nWe could have used place_diatomics instead here. Now we can use the built-in interaction list and bond types to place harmonic bonds between paired atoms.\n\nbonds = InteractionList2Atoms(\n    collect(1:(n_atoms ÷ 2)),           # First atom indices\n    collect((1 + n_atoms ÷ 2):n_atoms), # Second atom indices\n    [HarmonicBond(k=300_000.0u\"kJ * mol^-1 * nm^-2\", r0=0.1u\"nm\") for i in 1:(n_atoms ÷ 2)],\n)\n\nspecific_inter_lists = (bonds,) # Don't forget the trailing comma!\n\nThis time we are also going to use a neighbor list to speed up the Lennard-Jones calculation since we don't care about interactions beyond a certain distance. We can use the built-in DistanceNeighborFinder. The arguments are a 2D array of eligible interacting pairs, the number of steps between each update and the distance cutoff to be classed as a neighbor. Since the neighbor finder is run every 10 steps we should also use a distance cutoff for the neighbor list that is larger than the cutoff for the interaction.\n\n# All pairs apart from bonded pairs are eligible for non-bonded interactions\neligible = trues(n_atoms, n_atoms)\nfor i in 1:(n_atoms ÷ 2)\n    eligible[i, i + (n_atoms ÷ 2)] = false\n    eligible[i + (n_atoms ÷ 2), i] = false\nend\n\nneighbor_finder = DistanceNeighborFinder(\n    eligible=eligible,\n    n_steps=10,\n    dist_cutoff=1.5u\"nm\",\n)\n\ncutoff = DistanceCutoff(1.2u\"nm\")\npairwise_inters = (LennardJones(use_neighbors=true, cutoff=cutoff),)\n\nNow we can simulate as before.\n\nsys = System(\n    atoms=atoms,\n    coords=coords,\n    boundary=boundary,\n    velocities=velocities,\n    pairwise_inters=pairwise_inters,\n    specific_inter_lists=specific_inter_lists,\n    neighbor_finder=neighbor_finder,\n    loggers=(\n        temp=TemperatureLogger(10),\n        coords=CoordinatesLogger(10),\n    ),\n)\n\nsimulator = VelocityVerlet(\n    dt=0.002u\"ps\",\n    coupling=AndersenThermostat(temp, 1.0u\"ps\"),\n)\nsimulate!(sys, simulator, 1_000)\n\nThis time when we view the trajectory we can add lines to show the bonds.\n\nvisualize(\n    sys.loggers.coords,\n    boundary,\n    \"sim_diatomic.mp4\";\n    connections=[(i, i + (n_atoms ÷ 2)) for i in 1:(n_atoms ÷ 2)],\n)\n\n(Image: Diatomic simulation) The neighbors can be found using find_neighbors(sys), which returns a NeighborList.","category":"section"},{"location":"documentation/#Simulating-gravity","page":"Documentation","title":"Simulating gravity","text":"Molly is geared primarily to molecular simulation, but can also be used to simulate other physical systems. Let's set up a gravitational simulation. This example also shows a 2D simulation and no specified units.\n\natoms = [Atom(mass=1.0f0), Atom(mass=1.0f0)]\ncoords = [SVector(0.3f0, 0.5f0), SVector(0.7f0, 0.5f0)]\nvelocities = [SVector(0.0f0, 1.0f0), SVector(0.0f0, -1.0f0)]\npairwise_inters = (Gravity(use_neighbors=false, G=1.5f0),)\nsimulator = VelocityVerlet(dt=0.002f0)\nboundary = RectangularBoundary(1.0f0)\n\nsys = System(\n    atoms=atoms,\n    coords=coords,\n    boundary=boundary,\n    velocities=velocities,\n    pairwise_inters=pairwise_inters,\n    loggers=(coords=CoordinatesLogger(Float32, 10; dims=2),),\n    force_units=NoUnits,\n    energy_units=NoUnits,\n)\n\nsimulate!(sys, simulator, 2_000)\n\nWhen we view the simulation we can use some extra options:\n\nvisualize(\n    sys.loggers.coords,\n    boundary,\n    \"sim_gravity.mp4\";\n    trails=4,\n    framerate=15,\n    color=[:orange, :lightgreen],\n)\n\n(Image: Gravity simulation)","category":"section"},{"location":"documentation/#Simulating-a-protein","page":"Documentation","title":"Simulating a protein","text":"The recommended way to run a macromolecular simulation is to read in a force field in OpenMM XML format to a MolecularForceField and then read in a coordinate file in a format supported by Chemfiles.jl. Files for common force fields can be found at OpenMM and OpenMM force fields. This sets up a system in the same data structures as above and that is simulated in the same way. Here we carry out an energy minimization, simulate with a Langevin integrator in the NPT ensemble and use a TrajectoryWriter to write the trajectory as a DCD file (or another file format, by changing the file extension).\n\ndata_dir = joinpath(dirname(pathof(Molly)), \"..\", \"data\")\nT = Float32 # Float32 is much faster on GPU\nff = MolecularForceField(\n    T,\n    joinpath(data_dir, \"force_fields\", \"ff99SBildn.xml\"),\n    joinpath(data_dir, \"force_fields\", \"tip3p_standard.xml\"),\n    joinpath(data_dir, \"force_fields\", \"his.xml\"),\n)\n\nsys = System(\n    joinpath(data_dir, \"6mrr_equil.pdb\"),\n    ff;\n    nonbonded_method=:pme,\n    loggers=(\n        energy=TotalEnergyLogger(10),\n        writer=TrajectoryWriter(10, \"traj_6mrr_5ps.dcd\"),\n    ),\n    array_type=Array, # CuArray for CUDA GPU\n)\n\nminimizer = SteepestDescentMinimizer()\nsimulate!(sys, minimizer)\n\ntemp = T(298.0)u\"K\"\nrandom_velocities!(sys, temp)\nsimulator = Langevin(\n    dt=T(0.001)u\"ps\",\n    temperature=temp,\n    friction=T(1.0)u\"ps^-1\",\n    coupling=MonteCarloBarostat(T(1.0)u\"bar\", temp, sys.boundary),\n)\n\nsimulate!(sys, simulator, 5_000)\n\nThe above 5 ps simulation looks something like this when you view it in PyMOL: (Image: MD simulation)\n\nThe system setup procedure is tested against OpenMM, following their template matching procedure to assign force field parameters to the structures read from the structure file. Some margin in  residue and atom naming is allowed, as the naming present in the structure files is queried against a renaming dictionary that contains common alternative names present in pdb files, which you can consult in src/data/force_fields/pdbNames.xml. You can extend this dictionary yourself, if you really want to use your own naming; or you can build a standalone renaming dictionary following the same structure as the one mentioned above, and pass it as a keyword argument custom_renaming_scheme when you build your MolecularForceField. The bonding topology of the system is automatically inferred for standard residues (protein and nucleic acids, plus water). If your simulation contains other types of molecules, you must provide the topology  for them. You can do this either by using a structure file format with explicit bond definitions, such as mol2 or mmCIF, by defining the appropriate CONNECT records in a pdb file, or by providing a custom topology template in a format equivalent to the one found in /src/data/force_fields/residues.xml.  Residue patches, virtual sites, file includes and any force types other than HarmonicBondForce/HarmonicAngleForce/PeriodicTorsionForce/NonbondedForce are currently ignored.\n\ntip: Obtaining compatible structure files\nThe following tips may help you to read in a file correctly and without errors:Make sure there are no missing residues or heavy atoms. Tools such as MODELLER and SCWRL4 can fix these issues.\nMake sure that the naming in your structure file is either supported by your custom renaming convention, or does not usenames that deviate widely from the conventional residue namings.Make sure your structure file provides explicit chemical elements per particle or that at least the chemical element iseasily inferrable from the atom names, as a fundamental part of template matching for force field parameters assignement revolves around comparing the molecular formulas of the residues and potential templates.Some PDB files that read in fine can be found here.\n\nTo run on the GPU, set array_type=GPUArrayType, where GPUArrayType is the array type for your GPU backend (for example CuArray for NVIDIA or ROCArray for AMD). The nonbonded method can be selected using the nonbonded_method keyword argument to System. The options are :none (short range only), :cutoff (reaction field method), :pme (particle mesh Ewald summation) and :ewald (Ewald summation, slow). To run with constraints, use the constraints (:none, :hbonds, :allbonds or :hangles) and rigid_water keyword arguments.\n\nYou can use an implicit solvent method by giving the implicit_solvent keyword argument. The options are :obc1, :obc2 and :gbn2, corresponding to the Onufriev-Bashford-Case GBSA model with parameter set I or II and the GB-Neck2 model. Other options detailed in the docstring for System include overriding the boundary dimensions in the file (boundary) and modifying the non-bonded interaction and neighbor list cutoff distances (dist_cutoff and dist_buffer).\n\nMolly also has a rudimentary parser of Gromacs topology and coordinate files, which should be considered experimental. For example:\n\nsys = System(\n    joinpath(dirname(pathof(Molly)), \"..\", \"data\", \"5XER\", \"gmx_coords.gro\"),\n    joinpath(dirname(pathof(Molly)), \"..\", \"data\", \"5XER\", \"gmx_top_ff.top\");\n    nonbonded_method=:pme,\n    loggers=(\n        temp=TemperatureLogger(10),\n        writer=TrajectoryWriter(10, \"traj_6mrr_5ps.dcd\"),\n    ),\n)\n\ntemp = 298.0u\"K\"\nrandom_velocities!(sys, temp)\nsimulator = Verlet(\n    dt=0.0002u\"ps\",\n    coupling=BerendsenThermostat(temp, 1.0u\"ps\"),\n)\n\nsimulate!(sys, simulator, 5_000)\n\nHarmonic position restraints can be added to a System for equilibration using add_position_restraints:\n\nsys_res = add_position_restraints(\n    sys,\n    100_000.0u\"kJ * mol^-1 * nm^-2\";\n    atom_selector=is_heavy_atom,\n)","category":"section"},{"location":"documentation/#Enhanced-sampling","page":"Documentation","title":"Enhanced sampling","text":"Molly has the ReplicaSystem struct and simulators such as TemperatureREMD to carry out replica exchange molecular dynamics (REMD). On CPU these are run in parallel by dividing up the number of available threads. For example, to run temperature REMD on a protein with 4 replicas and attempt exchanges every 1 ps:\n\nusing Statistics\n\ndata_dir = joinpath(dirname(pathof(Molly)), \"..\", \"data\")\nff = MolecularForceField(\n    joinpath(data_dir, \"force_fields\", \"ff99SBildn.xml\"),\n    joinpath(data_dir, \"force_fields\", \"tip3p_standard.xml\"),\n    joinpath(data_dir, \"force_fields\", \"his.xml\"),\n)\n\nsys = System(joinpath(data_dir, \"6mrr_equil.pdb\"), ff)\n\nminimizer = SteepestDescentMinimizer()\nsimulate!(sys, minimizer)\n\nn_replicas = 4\n\nrep_sys = ReplicaSystem(\n    atoms=sys.atoms,\n    replica_coords=[copy(sys.coords) for _ in 1:n_replicas],\n    boundary=sys.boundary,\n    n_replicas=n_replicas,\n    atoms_data=sys.atoms_data,\n    pairwise_inters=sys.pairwise_inters,\n    specific_inter_lists=sys.specific_inter_lists,\n    general_inters=sys.general_inters,\n    neighbor_finder=sys.neighbor_finder,\n    replica_loggers=[(temp=TemperatureLogger(10),) for _ in 1:n_replicas],\n)\n\ntemps = [240.0u\"K\", 280.0u\"K\", 320.0u\"K\", 360.0u\"K\"]\ndt = 0.0005u\"ps\"\nsimulators = [Langevin(dt=dt, temperature=temp, friction=1.0u\"ps^-1\") for temp in temps]\n\nsim = TemperatureREMD(\n    dt=dt,\n    temperatures=temps,\n    simulators=simulators,\n    exchange_time=1.0u\"ps\",\n)\n\nsimulate!(rep_sys, sim, 40_000; assign_velocities=true)\n\nprintln(rep_sys.exchange_logger.n_attempts)\n# 30\n\nfor i in 1:n_replicas\n    final_temps = values(rep_sys.replicas[i].loggers.temp)[(end - 10):end]\n    println(mean(final_temps))\nend\n# 240.1691457033836 K\n# 281.3783250460198 K\n# 320.44985840482974 K\n# 357.710520769689 K","category":"section"},{"location":"documentation/#Monte-Carlo-sampling","page":"Documentation","title":"Monte Carlo sampling","text":"Molly has the MetropolisMonteCarlo simulator to carry out Monte Carlo sampling with Metropolis selection rates. For example, to perform simulated annealing on charged particles to form a crystal lattice:\n\nn_atoms = 100\natoms = [Atom(mass=10.0u\"g/mol\", charge=1.0) for i in 1:n_atoms]\nboundary = RectangularBoundary(4.0u\"nm\")\n\ncoords = place_atoms(n_atoms, boundary; min_dist=0.2u\"nm\")\npairwise_inters = (Coulomb(),)\n\ntemperatures = [1198.0, 798.0, 398.0, 198.0, 98.0, 8.0]u\"K\"\nsys = System(\n    atoms=atoms,\n    coords=coords,\n    boundary=boundary,\n    pairwise_inters=pairwise_inters,\n    loggers=(\n        coords=CoordinatesLogger(n_atoms, dims=2),\n        montecarlo=MonteCarloLogger(),\n    ),\n)\n\ntrial_args = Dict(:shift_size => 0.1u\"nm\")\nfor t in temperatures\n    sim = MetropolisMonteCarlo(;\n        temperature=t,\n        trial_moves=random_uniform_translation!,\n        trial_args=trial_args,\n    )\n\n    simulate!(sys, sim, 10_000)\nend\n\nprintln(sys.loggers.montecarlo.n_accept)\n# 15234\n\nvisualize(sys.loggers.coords, boundary, \"sim_montecarlo.gif\")\n\n(Image: Monte Carlo simulation)\n\ntrial_moves should be a function that takes a System as its argument and optional keyword arguments trial_args. It should modify the coordinates as appropriate, accounting for any boundary conditions. random_uniform_translation! and random_normal_translation! are provided as common trial move functions. MonteCarloLogger records various properties throughout the simulation.","category":"section"},{"location":"documentation/#Units","page":"Documentation","title":"Units","text":"Molly is fairly opinionated about using Unitful.jl units as shown above: you don't have to use them, but it is better if you do. Any consistent unit scheme can be used, or no units at all. Molly is most strict about the mixture of molar and non-molar types. For example, if your energy and force units are molar then your atom masses should be g/mol or similar. If you are not using units then no quantities can have Unitful annotations and you are responsible for ensuring a consistent unit system. Whilst you occasionally may run into friction with dimension mismatches, using units has the major advantages of catching whole classes of errors and letting you physically interpret the numbers in your system. The performance overhead of using units is minimal. Units are not currently compatible with differentiable simulations.\n\nAll your interaction types need to return the same units of force and energy or the simulation will not run. By default these are kJ * mol^-1 * nm^-1 for force and kJ * mol^-1 for energy, but this can be changed using the force_units and energy_units arguments to System and some interactions. These arguments should be NoUnits if you are not using units. If you need to strip units for downstream analysis, use the ustrip or ustrip_vec functions. It should be noted that charges are stored as dimensionless, i.e. 1.0 represents an atomic charge of +1. It is possible that you may run into issues when using different but valid units of the same dimension together, e.g. 1.0u\"nm\" and 10.0u\"Å\". In this case, try using the same units throughout.","category":"section"},{"location":"documentation/#Atom-types","page":"Documentation","title":"Atom types","text":"Molly has a built-in Atom type with a few properties commonly used in molecular simulation defined. The mass and charge functions can be used on an Atom. Custom atom types can be used just as effectively provided that either the mass function is defined on the type or the type has a mass field (the fallback for the mass function). The type should also have all fields required by any interactions. The list of atoms passed to the System constructor should be concretely typed.\n\nCustom atom types should generally be bits types, i.e. isbitstype(MyAtom) should be true, to work on the GPU. Additional non-bits type data for the atoms that is not directly used when calculating the interactions can be passed to the System constructor with the atoms_data keyword argument. For example the built-in AtomData type contains fields such as the atom name that are useful when writing trajectories.","category":"section"},{"location":"documentation/#Forces-and-energies","page":"Documentation","title":"Forces and energies","text":"Interactions define how different parts of the system interact. The force on each particle in the system is derived from the potential corresponding to the interaction.\n\nvecF_i = -sum_j fracdV_ij(r_ij)dr_ijfracvecr_ijr_ij\n\nIn Molly there are three types of interactions:\n\nPairwise interactions are present between all or most atom pairs, and account for example for non-bonded terms in molecular mechanics force fields. All pairwise interactions are a subtype of PairwiseInteraction.\nSpecific interactions are present between specific atoms, and account for example for bonded terms in molecular mechanics force fields.\nGeneral interactions are a free-form interaction type that can access the whole system and outputs forces for all atoms. This is useful for neural network potentials, implicit solvent models and other cases that require maximum flexibility. General interactions should be compatible with the AtomsCalculators.jl interface.\n\nThe available pairwise interactions are:\n\nLennardJones\nLennardJonesSoftCoreBeutler\nLennardJonesSoftCoreGapsys\nAshbaughHatch\nSoftSphere\nMie\nBuckingham\nCoulomb\nCoulombSoftCoreBeutler\nCoulombSoftCoreGapsys\nCoulombReactionField\nCoulombEwald\nYukawa\nGravity\n\nThe available specific interactions are:\n\nHarmonicPositionRestraint - 1 atom\nHarmonicBond - 2 atoms\nMorseBond - 2 atoms\nFENEBond - 2 atoms\nHarmonicAngle - 3 atoms\nCosineAngle - 3 atoms\nUreyBradley - 3 atoms\nPeriodicTorsion - 4 atoms\nRBTorsion - 4 atoms\n\nThe available general interactions are:\n\nEwald\nPME\nImplicitSolventOBC\nImplicitSolventGBN2\nMullerBrown\nASECalculator\n\nSome interactions combine instances of the above. For example, particle mesh Ewald summation uses the CoulombEwald pairwise interaction and the PME general interaction, allowing the short range terms to use the neighbors.","category":"section"},{"location":"documentation/#Pairwise-interactions","page":"Documentation","title":"Pairwise interactions","text":"Some pairwise interactions define mixing functions which determine how the parameters from each atom are combined. For example, the default σ_mixing for LennardJones is Molly.lorentz_σ_mixing, which is defined as (atom_i.σ + atom_j.σ) / 2. Other mixing functions are available, such as Molly.waldman_hagler_σ_mixing and Molly.fender_halsey_ϵ_mixing. Custom mixing functions can be given instead and should take in the two atoms as arguments. The atom_type field of the atoms is available, allowing features like changing the weight of solute-solvent interactions.\n\nTo define your own pairwise interaction, first define the struct, which must be a subtype of PairwiseInteraction:\n\nstruct MyPairwiseInter{C} <: PairwiseInteraction\n    # Any properties, e.g. cutoffs and interaction parameters\n    cutoff::C\n    param::Float64\nend\n\nYou can also define a use_neighbors method, which determines whether the neighbor list is used to omit distant atoms (true) or whether all atom pairs are always considered (false):\n\nMolly.use_neighbors(inter::MyPairwiseInter) = true\n\nThis is false by default. If it is true, you must specify a neighbor finder when setting up the System. For built-in interactions this function accesses the use_neighbors field of the struct. To work on the GPU the struct should be a bits type, i.e. isbitstype(MyPairwiseInter) should be true.\n\nNext, you need to define a method for the force and pairwise_force functions acting between a pair of atoms.\n\nThis has a set series of arguments:\n\nfunction Molly.force(inter::MyPairwiseInter,\n                     vec_ij,\n                     atom_i,\n                     atom_j,\n                     force_units,\n                     special,\n                     coord_i,\n                     coord_j,\n                     boundary,\n                     velocity_i,\n                     velocity_j,\n                     step_n)\n    r = norm(dr)\n    params = (inter.param,)\n    f = Molly.force_cutoff(inter.cutoff, inter, r, params)\n    # Multiply the force magnitude by the normalised vector between the atoms\n    fdr = f * vec_ij / r\n    return fdr\nend\n\nfunction Molly.pairwise_force(::MyPairwiseInter, r, params)\n    # Replace this with your force calculation\n    # A positive force causes the atoms to move apart\n    f = 0.0\n    return f\nend\n\nThe logic here is that any parameter mixing, shortcutting or setup is done in force then force_cutoff is used to apply the cutoff by calling pairwise_force, which calculates the force magnitude solely from interatomic distance r. params should not include any distance-based information, since pairwise_force may be called for other distances to apply the cutoff.\n\nMost of the arguments to force will generally not be used but are passed to allow maximum flexibility. You can use args... to indicate unused further arguments, e.g. Molly.force(inter::MyPairwiseInter, vec_ij, args...). vec_ij is the vector between the closest images of atoms i and j accounting for the periodic boundary conditions. Atom properties can be accessed, e.g. atom_i.σ. force_units can be useful for returning a zero force under certain conditions. step_n is the step number in the simulator, allowing time-dependent interactions. Beware that this step counter starts from 1 every time simulate! is called, and can also be 0 to calculate forces before the first step. It also doesn't work with simulate_remd!.\n\nTypically the force function is where most computation time is spent during the simulation, so consider optimising this function if you want high performance. One nice feature of Molly is that this function will work on both the CPU and the GPU. If you need a different version of the function on GPU, you can define Molly.force_gpu (and Molly.potential_energy_gpu). Virial computation is done automatically when required using the force function.\n\nThe argument special is a Bool determining whether the atom pair interaction should be treated as special. This is specified during neighbor finder construction. When simulating molecules, for example, non-bonded interactions for atoms in a 1-4 bonding arrangement (i-x-x-j) are often weighted by a factor such as 0.5. For interactions where this is relevant, special can be used to apply this weighting after calling force_cutoff in the force function. It can have a variety of uses depending on the context, for example if you have multiple interactions and want to exclude certain atom pairs from one of the interactions only.\n\nTo use your custom interaction in a simulation, add it to the list of pairwise interactions:\n\npairwise_inters = (MyPairwiseInter(NoCutoff(), 1.0),) # Don't forget the trailing comma!\n\nThen create a System and simulate as above. Note that you can also use a named tuple instead of a tuple if you want to access interactions by name:\n\npairwise_inters = (MyPairwiseInter=MyPairwiseInter(NoCutoff(), 1.0),)\n\nIf you wish to calculate potential energies or log the energy throughout a simulation, you will need to define methods for the potential_energy and pairwise_pe functions. These have the same arguments and logic as force, except the fifth argument to potential_energy is the energy units not the force units, and should return a single value corresponding to the potential energy:\n\nfunction Molly.potential_energy(inter::MyPairwiseInter,\n                                vec_ij,\n                                atom_i,\n                                atom_j,\n                                energy_units,\n                                special,\n                                coord_i,\n                                coord_j,\n                                boundary,\n                                velocity_i,\n                                velocity_j,\n                                step_n)\n    r = norm(dr)\n    params = (inter.param,)\n    return Molly.pe_cutoff(inter.cutoff, inter, r, params)\nend\n\nfunction Molly.pairwise_pe(::MyPairwiseInter, r, params)\n    # Replace this with your potential energy calculation\n    pe = 0.0\n    return pe\nend","category":"section"},{"location":"documentation/#Specific-interactions","page":"Documentation","title":"Specific interactions","text":"To define your own specific interaction, first define the struct:\n\nstruct MySpecificInter\n    # Properties, e.g. a bond distance corresponding to the energy minimum\nend\n\nNext, you need to define a method for the force function. The form of this will depend on whether the interaction involves 1, 2, 3 or 4 atoms. For example in the 2 atom case:\n\nfunction Molly.force(inter::MySpecificInter,\n                     coord_i,\n                     coord_j,\n                     boundary,\n                     atom_i,\n                     atom_j,\n                     force_units,\n                     velocity_i,\n                     velocity_j)\n    dr = vector(coords_i, coords_j, boundary)\n\n    # Replace this with your force calculation\n    # A positive force causes the atoms to move apart\n    f = 0.0\n\n    fdr = f * normalize(dr)\n    return SpecificForce2Atoms(-fdr, fdr)\nend\n\nAgain, most of these arguments are rarely used and can be replaced with args.... The 3 atom case would define Molly.force(inter::MySpecificInter, coord_i, coord_j, coord_k, boundary, atom_i, atom_j, atom_k, force_units, velocity_i, velocity_j, velocity_k) and return SpecificForce3Atoms(f1, f2, f3). Virial computation is done automatically when required using the force function.\n\nTo use your custom interaction, add it to the specific interaction lists along with the atom indices:\n\nspecific_inter_lists = (\n    InteractionList2Atoms(\n        [1, 3],\n        [2, 4],\n        [MySpecificInter(), MySpecificInter()],\n    ), # Don't forget the trailing comma!\n)\n\nFor 3 atom interactions use InteractionList3Atoms and pass 3 sets of indices. If using the GPU, the inner list of indices and interactions should be moved to the GPU with CuArray. The number in the interaction list and the return type from force must match, e.g. InteractionList3Atoms must always return SpecificForce3Atoms from the corresponding force function. If some atoms are required in the interaction for force calculation but have no force applied to them by the interaction, give a zero force vector for those atoms. Again a method for potential_energy with the same arguments, except the seventh argument is the energy units not the force units, can be defined:\n\nfunction Molly.potential_energy(inter::MySpecificInter,\n                                coord_i,\n                                coord_j,\n                                boundary,\n                                atom_i,\n                                atom_j,\n                                energy_units,\n                                velocity_i,\n                                velocity_j)\n    # Example harmonic bond interaction\n    dr = vector(coord_i, coord_j, boundary)\n    r = norm(dr)\n    return (inter.k / 2) * (r - inter.r0) ^ 2\nend","category":"section"},{"location":"documentation/#General-interactions","page":"Documentation","title":"General interactions","text":"To define your own general interaction, first define the struct:\n\nstruct MyGeneralInter\n    # Properties, e.g. a neural network model\nend\n\nNext, you need to define a method for the AtomsCalculators.forces! function (note this is different to the force function above, and to the forces function).\n\nimport AtomsCalculators\n\nfunction AtomsCalculators.forces!(fs,\n                                  sys,\n                                  inter::MyGeneralInter;\n                                  neighbors=nothing,\n                                  step_n=0,\n                                  n_threads=Threads.nthreads(),\n                                  kwargs...)\n    # kwargs... is required, neighbors/step_n/n_threads can be omitted if not used\n\n    # Calculate the forces on all atoms using the interaction and the system\n    # Add the forces to the existing forces, which have the same shape as the coordinates\n    # For example, a neural network might do something like this\n    fs .+= inter.model(sys.coords, sys.atoms)\n    return fs\nend\n\nThe neighbors calculated from the neighbor list are available in this function, but may or may not be used depending on the context. You could carry out your own neighbor finding in this function if required. Since the forces are available for mutation in the function, general interactions can be used to modify the forces in arbitrary ways, though it is up to you to write an appropriate potential energy function if energies are required. In cases where the forces are not simply added to, the order of general interactions can matter. General interactions are applied after pairwise and specific interactions. Note that this function calculates forces not accelerations; if you have a neural network that calculates accelerations you should multiply these by masses(sys) to get the forces according to F=ma.\n\nIf you want to use the virial in your simulation, for example for to control pressure, you will also need to calculate the contribution to the virial in the AtomsCalculators.forces! function. To do this, the function should take the additional keyword arguments needs_vir and buffers that will be passed by the simulator. needs_vir is a Bool that determines whether the virial is needed that call and buffers.virial contains the virial tensor. For example, the following could go in the function above:\n\n    if needs_vir\n        # The virial is a 3x3 SMatrix with units of energy\n        buffers.virial .+= rand(SMatrix{3, 3, Float64}) * sys.energy_units\n    end\n\nA method for the AtomsCalculators.potential_energy function that takes the same arguments and returns a single value can also be defined. To use your custom interaction in a simulation, add it to the list of general interactions:\n\ngeneral_inters = (MyGeneralInter(),) # Don't forget the trailing comma!\n\ngeneral_inters=general_inters can be given as a keyword argument when setting up the System.","category":"section"},{"location":"documentation/#Cutoffs","page":"Documentation","title":"Cutoffs","text":"As most atomic interactions decay rapidly with the interatomic distance, a cutoff radius beyond which the interaction is ignored is often used. There are a number of approaches to avoid discontinuities in the force/potential energy at the cutoff distance. Since the cutoff strategy is independent of the interaction for which is used, each interaction is defined without including a specific cutoff. See Pairwise interactions for how to make a pairwise interaction compatible with arbitrary cutoffs. The corresponding interaction constructor has a cutoff field (default NoCutoff for the built-in interactions) which is then used via dispatch to apply the chosen cutoff, e.g. SoftSphere(cutoff=ShiftedPotentialCutoff(1.2u\"nm\")).\n\nThe available cutoffs are:\n\nNoCutoff\nDistanceCutoff\nShiftedPotentialCutoff\nShiftedForceCutoff\nCubicSplineCutoff\n\nThe following built-in interactions can use a cutoff:\n\nLennardJones\nLennardJonesSoftCoreBeutler\nLennardJonesSoftCoreGapsys\nAshbaughHatch\nSoftSphere\nMie\nBuckingham\nCoulomb\nCoulombSoftCoreBeutler\nCoulombSoftCoreGapsys\nYukawa\nGravity\n\nIn addition, CoulombReactionField, CoulombEwald and the implicit solvent and Ewald general interactions have a dist_cutoff argument for a cutoff distance. Cutoffs combine well with neighbor finders, provided that the cutoff distance is less than the neighbor distance (see Neighbor finders for more).\n\nTo define a custom cutoff, you should first decide whether it has one cutoff point (the force/potential energy is modified up to the cutoff distance) or two (the force/potential energy is modified between an activation distance and the cutoff distance). Then, create a struct and cutoff functions:\n\nstruct MyCutoff{P, D} <: Molly.AbstractCutoff{1} # One cutoff point\n    dist_cutoff::D # This field is required\nend\n\nMyCutoff(dist_cutoff::D) where D = MyCutoff{1, D}(dist_cutoff)\n\nfunction Molly.pe_apply_cutoff(::MyCutoff, inter, r, params)\n    # Modify the potential energy, pairwise_pe with other values of r can be used\n    pe_r = pairwise_pe(inter, r, params)\n    return pe_r\nend\n\nfunction Molly.force_apply_cutoff(::MyCutoff, inter, r, params)\n    # Modify the force magnitude, pairwise_force with other values of r can be used\n    f_r = pairwise_force(inter, r, params)\n    return f_r\nend\n\nThe two cutoff point case is similar except it should sub-type Molly.AbstractCutoff{2} and the field dist_activation is also required in the struct.","category":"section"},{"location":"documentation/#Boundaries","page":"Documentation","title":"Boundaries","text":"Molly allows the use of various periodic and infinite boundary conditions. The available 3D boundaries are:\n\nCubicBoundary\nTriclinicBoundary\n\nThe available 2D boundaries are:\n\nRectangularBoundary\n\nSome examples of using boundaries:\n\nCubicBoundary(2.0u\"nm\"                             ) # Periodic cube with 2 nm sides\nCubicBoundary(2.0u\"nm\"   , 2.0u\"nm\"   , 2.0u\"nm\"   ) # Periodic cube with 2 nm sides\nCubicBoundary(4.0u\"nm\"   , 5.0u\"nm\"   , 6.0u\"nm\"   ) # Periodic cuboid\nCubicBoundary(2.0u\"nm\"   , 2.0u\"nm\"   , Inf * u\"nm\") # Infinite boundary in z direction\nCubicBoundary(Inf * u\"nm\", Inf * u\"nm\", Inf * u\"nm\") # Infinite boundary, no periodicity\nCubicBoundary(Inf * u\"nm\"                          ) # Infinite boundary, no periodicity\n\nRectangularBoundary(2.0u\"nm\"             ) # Periodic square\nRectangularBoundary(4.0u\"nm\", 5.0u\"nm\"   ) # Periodic rectangle\nRectangularBoundary(2.0u\"nm\", Inf * u\"nm\") # Infinite boundary in y direction\n\n# Periodic triclinic from basis vectors\nTriclinicBoundary(SVector(\n    SVector(2.2      , 0.0      , 0.0      )u\"nm\",\n    SVector(1.0      , 1.7320508, 0.0      )u\"nm\",\n    SVector(1.37888  , 0.5399122, 1.0233204)u\"nm\",\n))\n\n# Periodic triclinic from basis vector lengths and angles α/β/γ\nb = TriclinicBoundary(\n    SVector(2.2, 2.0, 1.8)u\"nm\",\n    deg2rad.(SVector(50.0, 40.0, 60.0)),\n)\n\n# Volume of bounding box\nvolume(b) # 3.8993746318188633 nm^3\n\n# Random coordinate uniformly distributed within boundary\nrandom_coord(b) # SVector(2.651062310435411, 2.1702306804433973, 0.9518105403051831)u\"nm\"\n\n# Wrap a coordinate back into the boundary if it is outside\nwrap_coords(SVector(1.0, 1.0, 1.0)u\"nm\", b) # SVector(3.2, 1.0, 1.0)u\"nm\"\n\nThe box_center, AtomsBase.n_dimensions, float_type, place_atoms and place_diatomics functions are also available for boundaries.\n\nThe appropriate boundary to use will depend on your simulation. For example, having different lengths in each dimension would usually only make sense in a situation where forces or restraints depended on the dimension.","category":"section"},{"location":"documentation/#Simulators","page":"Documentation","title":"Simulators","text":"Simulators define what type of simulation is run. This could be anything from a simple energy minimization to complicated replica exchange MD. The available simulators are:\n\nSteepestDescentMinimizer\nVelocityVerlet\nVerlet\nStormerVerlet\nLangevin\nLangevinSplitting\nOverdampedLangevin\nNoseHoover\nTemperatureREMD\nHamiltonianREMD\nMetropolisMonteCarlo\n\nMany of these require a time step dt as an argument. Many also remove the center of mass motion every time step, which can be tuned with the remove_CM_motion argument (false or a number of steps).\n\nThe LangevinSplitting simulator can be used to define a variety of integrators such as velocity Verlet (splitting \"BAB\"), the Langevin implementation in Langevin (\"BAOA\"), and symplectic Euler integrators (\"AB\" and \"BA\").\n\nTo define your own simulator, first define a struct:\n\nstruct MySimulator\n    # Any properties, e.g. the time step or coupling methods\nend\n\nThen, define a method for simulate! that carries out the simulation. This example shows some helper functions that you can use:\n\nfunction Molly.simulate!(sys,\n                         sim::MySimulator,\n                         n_steps::Integer;\n                         n_threads::Integer=Threads.nthreads(),\n                         run_loggers=true)\n    # Find neighbors like this\n    neighbors = find_neighbors(sys, sys.neighbor_finder; n_threads=n_threads)\n\n    for step_n in 1:n_steps\n        # Calculate accelerations like this\n        # See src/simulators.jl for more efficient code that reuses memory\n        accels_t = accelerations(sys, neighbors, step_n; n_threads=n_threads)\n\n        # Ensure coordinates stay within the simulation box like this\n        sys.coords .= wrap_coords.(sys.coords, (sys.boundary,))\n\n        # Example velocity update\n        # Includes appropriate unit conversion for when the force units are per mol\n        sys.velocities .+= (accels_t .+ accels_t_dt) .* sim.dt / 2\n\n        # Apply coupling like this\n        recompute_forces = apply_coupling!(sys, buffers, sim.coupling, sim, neighbors, step_n;\n                                           n_threads=n_threads)\n\n        # Remove center of mass motion like this\n        remove_CM_motion!(sys)\n\n        # Apply the loggers like this\n        # Computed quantities can also be given as keyword arguments to apply_loggers!\n        apply_loggers!(sys, buffers, neighbors, step_n, run_loggers; n_threads=n_threads)\n\n        # Find new neighbors like this\n        neighbors = find_neighbors(sys, sys.neighbor_finder, neighbors, step_n, recompute_forces;\n                                   n_threads=n_threads)\n    end\n\n    return sys\nend\n\nSee more in the source code, for example how to apply constraints to coordinates and velocities. To use your custom simulator, give it as the second argument when calling simulate!.\n\nTo define your own replica exchange simulator, first define a struct:\n\nstruct MyREMDSimulator\n    dt # Time step\n    exchange_time # Time between exchanges\n    simulators # A list of simulators to use for each replica e.g. Langevin\n    # Other properties of the simulation\nend\n\nThen define the function that carries out the exchange, remd_exchange!:\n\nfunction Molly.remd_exchange!(sys::ReplicaSystem,\n                              sim::MyREMDSimulator,\n                              n::Integer,\n                              m::Integer;\n                              n_threads::Integer=Threads.nthreads(),\n                              rng=Random.default_rng())\n    # Attempt to exchange the replicas with index n and m\n    # First define Δ for the REMD scheme\n    make_exchange = Δ <= 0 || rand(rng) < exp(-Δ) # Example of Metropolis acceptance rate\n    if make_exchange\n        # Exchange coordinates and velocities of replicas\n        # Also scale the velocities to match the temperature if required\n    end\n\n    return Δ, make_exchange\nend\n\nThe above function returns Δ, the argument of the acceptance rate that is logged by ReplicaExchangeLogger, and a boolean indicating whether the exchange was successful.\n\nThen, define a method for the simulate! function to perform the parallel simulation. This does any initial setup such as assigning velocities then uses simulate_remd! to run the simulation:\n\nfunction Molly.simulate!(sys::ReplicaSystem,\n                         sim::MyREMDSimulator,\n                         n_steps::Integer;\n                         rng=Random.default_rng(),\n                         n_threads::Integer=Threads.nthreads())\n    # Do any initial setup if necessary\n    simulate_remd!(sys, sim, n_steps; rng=rng, n_threads=n_threads)\nend\n\nUnder the hood there are multiple implementations for the forces function, used by accelerations, and for potential_energy: a version geared towards CPUs and parallelism, a CUDA version, and a version for other GPU backends. You can define different versions of a simulator for CPU, CUDA and generic GPU systems by dispatching on System{D, Array} or System{D, CuArray} and System{D, AT} where AT <: AbstractGPUArray respectively. This also applies to coupling methods, neighbor finders and analysis functions. You do not have to define different versions though: you may only intend to use the simulator one way, or one version may be performant in all cases.","category":"section"},{"location":"documentation/#Coupling","page":"Documentation","title":"Coupling","text":"Some simulators can be modified by adding coupling methods to allow properties like temperature and pressure to be controlled during a simulation. The available couplers are:\n\nNoCoupling\nImmediateThermostat\nVelocityRescaleThermostat\nAndersenThermostat\nBerendsenThermostat\nBerendsenBarostat\nCRescaleBarostat\nMonteCarloBarostat\n\nCurrently the VelocityVerlet, Verlet, StormerVerlet, Langevin and NoseHoover simulators support coupling methods, with the default being NoCoupling. Couplers are given to the coupling keyword argument during simulator construction:\n\ntemp = 300.0u\"K\"\npress = 1.0u\"bar\"\nthermostat = AndersenThermostat(temp, 1.0u\"ps\")\nbarostat = MonteCarloBarostat(press, temp, sys.boundary)\n\n# Velocity Verlet with Andersen thermostat\nVelocityVerlet(dt=0.001u\"ps\", coupling=thermostat)\n\n# Velocity Verlet with Andersen thermostat and Monte Carlo barostat\nVelocityVerlet(dt=0.001u\"ps\", coupling=(thermostat, barostat))\n\nThe appropriate coupling to use will depend on the situation. For example, the Langevin simulator controls temperature so does not require a thermostat. The MonteCarloBarostat for controlling pressure assumes a constant temperature but does not actively control the temperature. It should be used alongside a temperature coupling method such as the Langevin simulator or the AndersenThermostat coupling.\n\nTo define your own coupling method, first define the struct:\n\nstruct MyCoupler\n    # Any properties, e.g. a target temperature or coupling constant\nend\n\nThen, define the function that implements the coupling every time step:\n\nfunction Molly.apply_coupling!(sys, buffers, coupling::MyCoupler, sim, neighbors, step_n;\n                               n_threads=Threads.nthreads(), rng=Random.default_rng())\n    # Do something to the simulation, e.g. scale the velocities\n    # Return whether the coupling has invalidated the currently stored forces,\n    #   for example by changing the coordinates\n    recompute_forces = false\n    return recompute_forces\nend\n\nThe functions random_velocity, maxwell_boltzmann and temperature may be useful here. To use your custom coupler, give it as the coupling argument to the simulator as above.\n\nNote that as some coupling methods need the virial to work, a custom coupler can be accompanied by a function that tells Molly the interval of simulation steps at which the virial is required. This helps save computation. For example:\n\n# The virial is needed every c.n_steps\nMolly.needs_virial(c::MyCoupler) = c.n_steps\n\n# The virial is not needed, this is the default\nMolly.needs_virial(c::MyCoupler) = Inf\n\nThe use of the virial tensor allows for non-isotropic pressure control. Molly follows the definition in LAMMPS, taking into account pairwise and specific interactions as well as the contribution of the Ewald and PME methods. Contributions from constraints and implicit solvent methods are ignored. As described previously, custom general interactions should implement virial calculation if required.","category":"section"},{"location":"documentation/#Loggers","page":"Documentation","title":"Loggers","text":"Loggers record properties of the simulation to allow monitoring and analysis. The available loggers are:\n\nGeneralObservableLogger\nTemperatureLogger\nCoordinatesLogger\nVelocitiesLogger\nTotalEnergyLogger\nKineticEnergyLogger\nPotentialEnergyLogger\nForcesLogger\nVolumeLogger\nDensityLogger\nVirialLogger\nScalarVirialLogger\nPressureLogger\nScalarPressureLogger\nDisplacementsLogger\nTrajectoryWriter\nTimeCorrelationLogger\nAutoCorrelationLogger\nAverageObservableLogger\nReplicaExchangeLogger\nMonteCarloLogger\n\nMany of the loggers can be initialised with just the number of steps between recorded values, e.g. CoordinatesLogger(10). An optional first argument is the type of the recorded value; the above is equivalent to CoordinatesLogger(typeof(1.0u\"nm\"), 10) but if the simulation did not use units then CoordinatesLogger(Float64, 10) would be required. If the simulation is in 2D, giving dims=2 as a keyword argument is required for some loggers. A logger's history can be accessed with values(my_logger).\n\nTo define your own logger, first define the struct and a method for values to access the stored values:\n\nstruct MyLogger\n    n_steps::Int\n    history::Vector{Float64}\n    # Any other properties\nend\n\nBase.values(logger::MyLogger) = logger.history\n\nThen, define the logging function that is called every step by the simulator:\n\nfunction Molly.log_property!(logger::MyLogger,\n                                sys,\n                                neighbors,\n                                step_n;\n                                n_threads=Threads.nthreads(),\n                                kwargs...)\n    if step_n % logger.n_steps == 0\n        # Record some property or carry out some action\n    end\nend\n\nThe use of n_steps is optional and is an example of how to record a property periodically throughout the simulation. To use your custom logger, add it to the named tuple of loggers given when creating the System:\n\nloggers = (mylogger=MyLogger(10, []),) # Don't forget the trailing comma!\n\nIn addition to being run at the end of each step, loggers are run before the first step, i.e. at step 0. This means that a logger that records a value every step for a simulation with 100 steps will end up with 101 values. Running loggers before the first step can be disabled by giving run_loggers=:skipzero as a keyword argument to simulate!, which can be useful when splitting up simulations into multiple simulate! calls. For example, this runs the loggers 301 times:\n\nsimulate!(sys, simulator, 100) # Default run_loggers=true\nsimulate!(sys, simulator, 100; run_loggers=:skipzero)\nsimulate!(sys, simulator, 100; run_loggers=:skipzero)\n\nRunning loggers can be disabled entirely with run_loggers=false, which is the default for SteepestDescentMinimizer. Loggers are currently ignored for the purposes of taking gradients, so if a logger is used in the gradient calculation the gradients will appear to be nothing.\n\nMany times, a logger will just record an observation to an Array containing a record of past observations. For this purpose, you can use the GeneralObservableLogger without defining a custom logging function. Define your observation function as\n\nfunction my_observable(sys::System, neighbors, step_n; n_threads::Integer, kwargs...)\n    # Probe the system for some desired property\n    return observation\nend\n\nKeyword arguments current_forces and current_potential_energy can also be used here to avoid recomputing values that are passed from the simulator:\n\nfunction my_pe_observable(sys::System, neighbors; n_threads::Integer,\n                          current_potential_energy=nothing, kwargs...)\n    if isnothing(current_potential_energy)\n        # Compute potential energy\n        return potential_energy(sys, neighbors; n_threads=n_threads)\n    else\n        # Potential energy was passed from simulator, reuse\n        return current_potential_energy\n    end\nend\n\nThese keyword arguments are also available in log_property!. Which values are passed depends on the simulator being used, for example SteepestDescentMinimizer passes current_potential_energy because it uses it for minimization. Note that loggers are called after apply_coupling!, so the coordinates may have changed since the potential energy or forces were computed.\n\nA logger which records the property every n_steps can be constructed through\n\nmy_logger = GeneralObservableLogger(my_observable, T, n_steps)\n\nwhere T = typeof(observation) is the type of the return value for my_observable. AverageObservableLogger is similar but records a running average rather than storing observations.\n\nThe TimeCorrelationLogger logger can be used to compute correlation functions of the form\n\nC(t) = fraclangle A_t cdot B_0 ranglesqrtlangle A^2 rangle langle B^2 rangle\n\nwhere A and B are scalar or vector centered observables and the brackets are ensemble averages. This includes the computations of autocorrelation functions, which can be used to gather insight into the dynamical properties of the system, for instance using Green-Kubo formulas, or the statistical properties of a sampling method.\n\nLet's look at a simple example, computing the velocity autocorrelation function for a simple system consisting of diatomic molecules defined by HarmonicBond potentials between pairs of atoms, and an additional SoftSphere potential between all pairs of atoms. Let's start by defining the system.\n\nn_atoms = 400\natom_mass = 10.0u\"g/mol\"\natoms = [Atom(mass=atom_mass, σ=0.2u\"nm\", ϵ=0.2u\"kJ * mol^-1\") for i in 1:n_atoms]\n\n# Initialization\nboundary = CubicBoundary(6.0u\"nm\")\ncoords = place_diatomics(n_atoms ÷ 2, boundary, 0.2u\"nm\"; min_dist=0.2u\"nm\")\n\ntemp = 50.0u\"K\"\nvelocities = [random_velocity(atom_mass, temp) .* 0.01 for i in 1:n_atoms]\n\n# Interaction potentials\npairwise_inters = (SoftSphere(use_neighbors=true, cutoff=DistanceCutoff(0.6u\"nm\")),)\n\nbonds = [HarmonicBond(k=10000u\"kJ * mol^-1 * nm^-2\", r0=0.2u\"nm\") for i in 1:(n_atoms ÷ 2)]\nspecific_inter_lists = (InteractionList2Atoms(\n    collect(1:2:n_atoms),\n    collect(2:2:n_atoms),\n    bonds,\n),)\n\n# Define system\nnf = DistanceNeighborFinder(eligible=trues(n_atoms, n_atoms), dist_cutoff=0.6u\"nm\")\n\nsys = System(\n    atoms=atoms,\n    coords=coords,\n    boundary=boundary,\n    velocities=velocities,\n    pairwise_inters=pairwise_inters,\n    specific_inter_lists=specific_inter_lists,\n    neighbor_finder=nf,\n)\n\nWe leave the loggers empty until we thermalize the system using Langevin dynamics.\n\ndt = 0.002u\"ps\"\nsimulator = LangevinSplitting(\n    dt=dt,\n    temperature=temp,\n    friction=10.0u\"g * mol^-1 * ps^-1\",\n    splitting=\"BAOAB\",\n)\nsimulate!(sys, simulator, 10_000)\n@show temperature(sys)\n\ntemperature(sys) = 48.76795299825687 K\n\nNext we define our correlation logger, add it to the system's loggers and run a longer simulation. Note that we need to redeclare the system when adding a logger.\n\n# Velocity observable\n# args and kwargs because more complex observables may require neighbors and parallelism\nV(s::System, args...; kwargs...) = s.velocities\nV_Type = eltype(sys.velocities)\nlogger = TimeCorrelationLogger(V, V, V_Type, V_Type, n_atoms, 1_000)\n\nsys = System(\n    atoms=atoms,\n    coords=sys.coords,\n    boundary=boundary,\n    velocities=sys.velocities,\n    pairwise_inters=pairwise_inters,\n    specific_inter_lists=specific_inter_lists,\n    neighbor_finder=nf,\n    loggers=(velocity_autocorrelation=logger,)\n)\nsimulate!(sys, simulator, 100_000)\n\nCheck the output:\n\nshow(sys.loggers)\n\n(velocity_autocorrelation = AutoCorrelationLogger with n_correlation 1000 and 100001 samples collected for observable V,)\n\nNote we also could have used the convenience function AutoCorrelationLogger to define our logger since the two observables we are correlating are the same.\n\nusing GLMakie\nf = Figure()\nax = Axis(f[1, 1], xlabel=\"Time / ps\", ylabel=\"Correlation\")\nlines!((1:1000) .* ustrip(dt), values(sys.loggers.velocity_autocorrelation))\n\n(Image: Velocity Autocorrelations)\nAs expected, the velocities are highly correlated at small time offsets and the correlation decays rapidly. The oscillatory behavior is due to the harmonic bond interactions.","category":"section"},{"location":"documentation/#Constraints","page":"Documentation","title":"Constraints","text":"Molly implements SHAKE and its extension, RATTLE, to perform constrained molecular dynamics (see SHAKE_RATTLE). These methods are useful for maintaining bond lengths and angles during a simulation, often allowing the use of longer time steps and therefore more efficient use of computing resources. The constraints satisfied by SHAKE are solely on the atomic coordinates:\n\nbeginaligned\nvecr_ij cdot vecr_ij = d^2_ij\nendaligned\n\nwhereas RATTLE also constrains the velocities:\n\nbeginaligned\nvecr_ij cdot vecv_ij = 0\nendaligned\n\nHere vecr_ij is the vector between atoms i and j in a constraint, d_ij is the bond length to be maintained and vecv_ij is the difference in the velocity vectors for atoms i and j. SHAKE was originally derived for the Verlet integration scheme (Ryckaert et al. 1977) with RATTLE extending SHAKE to work for velocity Verlet where the velocities are also integrated (Andersen 1983).\n\nCurrently, constraints are supported by the following simulators:\n\nSteepestDescentMinimizer\nVelocityVerlet\nVerlet\nStormerVerlet\nLangevin\n\nSimulators incompatible with constraints will print a warning and continue without applying constraints when used with systems containing constraints.\n\nMolly supports DistanceConstraint and AngleConstraint on CPU and GPU. Distance constraints fix the distance between two atoms. Angle constraints are defined for sets of three atoms (e.g. water) and restrict the angle and the two bond lengths.\n\nConstraints can be added when setting up a system from a file as described above. To add constraints to a system manually, use something like the following:\n\ndist_constraints = [\n    DistanceConstraint(1, 2, 1.0u\"nm\"),\n    DistanceConstraint(2, 3, 0.11u\"nm\"),\n]\nangle_constraints = [AngleConstraint(4, 5, 6, deg2rad(104.5), 0.1u\"nm\", 0.1u\"nm\")]\n\nshake = SHAKE_RATTLE(\n    6;\n    dist_constraints=dist_constraints,\n    angle_constraints=angle_constraints,\n)\n# SHAKE_RATTLE with 0 2-atom clusters, 1 3-atom clusters, 0 4-atom clusters and 1 angle clusters\n\nconstraints=(shake,) can then be given when setting up a System. See this example for more.\n\nThis diagram demonstrates the four allowed constraint types: (Image: Valid Constraints)\n\nSingle bond between two atoms (e.g. a hydrogen molecule).\n3 atoms, 2 DistanceConstraints, angle is free (e.g. the hydrogens on either carbon of ethelene).\n3 atoms, 1 AngleConstraint, implemented as 3 distance constraints (e.g. a water molecule).\n3 atoms around 1 central atom, 3 DistanceConstraints (e.g. an ammonia molecule).\n\nnote: Note\nYou can't constrain a linear chain of four atoms or an angle of 180°. Constraints beyond the four valid classes can't be used. For example, you can't constrain all the hydrogen bonds and the double bond in ethylene simultaneously. This would create a cluster of 5 constraints which is not supported.\n\nThese constraints provide enough flexibility to constrain all hydrogen atoms in organic molecules as well as water molecules.\n\nAll velocity constraints and diatomic distance constraints are solved analytically while larger constraints are linearized and solved iteratively via matrix inverse. The direct matrix inverse does not scale well beyond clusters with 3 constraints and is not implemented. Other methods can be used to solve larger constraint clusters, these are not yet supported by Molly.","category":"section"},{"location":"documentation/#Neighbor-finders","page":"Documentation","title":"Neighbor finders","text":"Neighbor finders find close atoms periodically throughout the simulation, saving on computation time by allowing the force calculation between distant atoms to be omitted. The available neighbor finders are:\n\nNoNeighborFinder\nCellListMapNeighborFinder\nGPUNeighborFinder\nDistanceNeighborFinder\nTreeNeighborFinder\n\nThe recommended neighbor finder is CellListMapNeighborFinder on CPU, GPUNeighborFinder on NVIDIA GPUs and DistanceNeighborFinder on other GPUs. When using a neighbor finder you should in general also use an interaction cutoff (see Cutoffs) with a cutoff distance less than the neighbor finder distance. The difference between the two should be larger than an atom can move in the time of the n_steps defined by the neighbor finder. The exception is GPUNeighborFinder, which uses the algorithm from Eastman and Pande 2010 to avoid calculating a neighbor list and should have dist_cutoff set to the interaction cutoff distance.\n\nTo define your own neighbor finder, first define the struct:\n\nstruct MyNeighborFinder\n    eligible::BitArray{2}\n    special::BitArray{2}\n    n_steps::Int\n    # Any other properties, e.g. a distance cutoff\nend\n\nExamples of three useful properties are given here: a matrix indicating atom pairs eligible for pairwise interactions, a matrix indicating atoms in a special arrangement such as 1-4 bonding, and a value determining how many time steps occur between each evaluation of the neighbor finder. Then, define the neighbor finding function that is called every step by the simulator:\n\nfunction Molly.find_neighbors(sys,\n                              nf::MyNeighborFinder,\n                              current_neighbors=nothing,\n                              step_n::Integer=0,\n                              force_recompute::Bool=false;\n                              n_threads::Integer=Threads.nthreads())\n    if force_recompute || step_n % nf.n_steps == 0\n        if isnothing(current_neighbors)\n            neighbors = NeighborList()\n        else\n            neighbors = current_neighbors\n        end\n        empty!(neighbors)\n        # Add to neighbors, for example\n        push!(neighbors, (1, 2, false)) # atom i, atom j and whether they are in a special interaction\n        return neighbors\n    else\n        return current_neighbors\n    end\nend\n\nTo use your custom neighbor finder, give it as the neighbor_finder argument when creating the System.","category":"section"},{"location":"documentation/#Analysis","page":"Documentation","title":"Analysis","text":"Molly contains some tools for analysing the results of simulations. Functions that may be useful for analysis include:\n\nvisualize\nrdf\ndistances\ndisplacements\nrmsd\nradius_gyration\nhydrodynamic_radius\nbond_angle\ntorsion_angle\n\nJulia is a language well-suited to implementing all kinds of analysis for molecular simulations.","category":"section"},{"location":"documentation/#Randomness","page":"Documentation","title":"Randomness","text":"Many functions can take in a random number generator to allow reproducible randomness. For example:\n\njulia> using Molly, Random\n\njulia> random_velocity(10.0u\"g/mol\", 300.0u\"K\")\n3-element SVector{3, Quantity{Float64, 𝐋 𝐓^-1, Unitful.FreeUnits{(nm, ps^-1), 𝐋 𝐓^-1, nothing}}} with indices SOneTo(3):\n    0.5749142510427172 nm ps^-1\n   -0.5373536210638031 nm ps^-1\n -0.044898786241729376 nm ps^-1\n\njulia> random_velocity(10.0u\"g/mol\", 300.0u\"K\"; rng=Xoshiro(10))\n3-element SVector{3, Quantity{Float64, 𝐋 𝐓^-1, Unitful.FreeUnits{(nm, ps^-1), 𝐋 𝐓^-1, nothing}}} with indices SOneTo(3):\n    0.1703351361585439 nm ps^-1\n -0.027009534351612234 nm ps^-1\n   0.23543457751795477 nm ps^-1\n\njulia> random_velocity(10.0u\"g/mol\", 300.0u\"K\"; rng=Xoshiro(10))\n3-element SVector{3, Quantity{Float64, 𝐋 𝐓^-1, Unitful.FreeUnits{(nm, ps^-1), 𝐋 𝐓^-1, nothing}}} with indices SOneTo(3):\n    0.1703351361585439 nm ps^-1\n -0.027009534351612234 nm ps^-1\n   0.23543457751795477 nm ps^-1\n\n\nThis may not apply across Julia versions, though you can use StableRNGs.jl. It also does not apply across different backends such as CPU and GPU.","category":"section"},{"location":"exercises/#Molly-exercises","page":"Exercises","title":"Molly exercises","text":"A notebook with exercises covering various parts of Molly is available here.\n\nAnother notebook with exercises on computing transport coefficients with Molly is available here.","category":"section"}]
}
