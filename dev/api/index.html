<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Molly.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Molly.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../docs/">Documentation</a></li><li><a class="tocitem" href="../differentiable/">Differentiable simulation</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../related/">Related software</a></li><li><a class="tocitem" href="../development/">Development</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMolSim/Molly.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Molly-API"><a class="docs-heading-anchor" href="#Molly-API">Molly API</a><a id="Molly-API-1"></a><a class="docs-heading-anchor-permalink" href="#Molly-API" title="Permalink"></a></h1><p>The API reference can be found here.</p><p>Molly also re-exports <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a>, <a href="https://github.com/PainterQubits/Unitful.jl">Unitful.jl</a> and <a href="https://github.com/JuliaMolSim/AtomsBase.jl">AtomsBase.jl</a>, making the likes of <code>SVector</code> and <code>1.0u&quot;nm&quot;</code> available when you call <code>using Molly</code>.</p><p>The <a href="#Molly.visualize"><code>visualize</code></a> function is only available once you have called <code>using GLMakie</code>. <a href="https://github.com/JuliaPackaging/Requires.jl">Requires.jl</a> is used to lazily load this code when <a href="https://github.com/JuliaPlots/Makie.jl">GLMakie.jl</a> is available, which reduces the dependencies of the package.</p><ul><li><a href="#Molly.AbstractGBSA"><code>Molly.AbstractGBSA</code></a></li><li><a href="#Molly.AndersenThermostat"><code>Molly.AndersenThermostat</code></a></li><li><a href="#Molly.Atom"><code>Molly.Atom</code></a></li><li><a href="#Molly.AtomData"><code>Molly.AtomData</code></a></li><li><a href="#Molly.AtomType"><code>Molly.AtomType</code></a></li><li><a href="#Molly.AverageObservableLogger"><code>Molly.AverageObservableLogger</code></a></li><li><a href="#Molly.BerendsenThermostat"><code>Molly.BerendsenThermostat</code></a></li><li><a href="#Molly.Buckingham"><code>Molly.Buckingham</code></a></li><li><a href="#Molly.CellListMapNeighborFinder"><code>Molly.CellListMapNeighborFinder</code></a></li><li><a href="#Molly.CosineAngle"><code>Molly.CosineAngle</code></a></li><li><a href="#Molly.Coulomb"><code>Molly.Coulomb</code></a></li><li><a href="#Molly.CoulombReactionField"><code>Molly.CoulombReactionField</code></a></li><li><a href="#Molly.CoulombSoftCore"><code>Molly.CoulombSoftCore</code></a></li><li><a href="#Molly.CubicBoundary"><code>Molly.CubicBoundary</code></a></li><li><a href="#Molly.CubicSplineCutoff"><code>Molly.CubicSplineCutoff</code></a></li><li><a href="#Molly.DistanceCutoff"><code>Molly.DistanceCutoff</code></a></li><li><a href="#Molly.DistanceNeighborFinder"><code>Molly.DistanceNeighborFinder</code></a></li><li><a href="#Molly.FENEBond"><code>Molly.FENEBond</code></a></li><li><a href="#Molly.GeneralObservableLogger"><code>Molly.GeneralObservableLogger</code></a></li><li><a href="#Molly.Gravity"><code>Molly.Gravity</code></a></li><li><a href="#Molly.HamiltonianREMD"><code>Molly.HamiltonianREMD</code></a></li><li><a href="#Molly.HarmonicAngle"><code>Molly.HarmonicAngle</code></a></li><li><a href="#Molly.HarmonicBond"><code>Molly.HarmonicBond</code></a></li><li><a href="#Molly.HarmonicPositionRestraint"><code>Molly.HarmonicPositionRestraint</code></a></li><li><a href="#Molly.ImplicitSolventGBN2"><code>Molly.ImplicitSolventGBN2</code></a></li><li><a href="#Molly.ImplicitSolventOBC"><code>Molly.ImplicitSolventOBC</code></a></li><li><a href="#Molly.InteractionList1Atoms"><code>Molly.InteractionList1Atoms</code></a></li><li><a href="#Molly.InteractionList2Atoms"><code>Molly.InteractionList2Atoms</code></a></li><li><a href="#Molly.InteractionList3Atoms"><code>Molly.InteractionList3Atoms</code></a></li><li><a href="#Molly.InteractionList4Atoms"><code>Molly.InteractionList4Atoms</code></a></li><li><a href="#Molly.Langevin"><code>Molly.Langevin</code></a></li><li><a href="#Molly.LangevinSplitting"><code>Molly.LangevinSplitting</code></a></li><li><a href="#Molly.LennardJones"><code>Molly.LennardJones</code></a></li><li><a href="#Molly.LennardJonesSoftCore"><code>Molly.LennardJonesSoftCore</code></a></li><li><a href="#Molly.MetropolisMonteCarlo"><code>Molly.MetropolisMonteCarlo</code></a></li><li><a href="#Molly.Mie"><code>Molly.Mie</code></a></li><li><a href="#Molly.MolecularForceField"><code>Molly.MolecularForceField</code></a></li><li><a href="#Molly.MolecularTopology"><code>Molly.MolecularTopology</code></a></li><li><a href="#Molly.MonteCarloBarostat"><code>Molly.MonteCarloBarostat</code></a></li><li><a href="#Molly.MonteCarloLogger"><code>Molly.MonteCarloLogger</code></a></li><li><a href="#Molly.MorseBond"><code>Molly.MorseBond</code></a></li><li><a href="#Molly.MullerBrown"><code>Molly.MullerBrown</code></a></li><li><a href="#Molly.NeighborList"><code>Molly.NeighborList</code></a></li><li><a href="#Molly.NoCoupling"><code>Molly.NoCoupling</code></a></li><li><a href="#Molly.NoCutoff"><code>Molly.NoCutoff</code></a></li><li><a href="#Molly.NoNeighborFinder"><code>Molly.NoNeighborFinder</code></a></li><li><a href="#Molly.NoseHoover"><code>Molly.NoseHoover</code></a></li><li><a href="#Molly.PairwiseInteraction"><code>Molly.PairwiseInteraction</code></a></li><li><a href="#Molly.PeriodicTorsion"><code>Molly.PeriodicTorsion</code></a></li><li><a href="#Molly.PeriodicTorsionType"><code>Molly.PeriodicTorsionType</code></a></li><li><a href="#Molly.RBTorsion"><code>Molly.RBTorsion</code></a></li><li><a href="#Molly.RectangularBoundary"><code>Molly.RectangularBoundary</code></a></li><li><a href="#Molly.ReplicaExchangeLogger"><code>Molly.ReplicaExchangeLogger</code></a></li><li><a href="#Molly.ReplicaSystem"><code>Molly.ReplicaSystem</code></a></li><li><a href="#Molly.RescaleThermostat"><code>Molly.RescaleThermostat</code></a></li><li><a href="#Molly.ResidueType"><code>Molly.ResidueType</code></a></li><li><a href="#Molly.SHAKE"><code>Molly.SHAKE</code></a></li><li><a href="#Molly.ShiftedForceCutoff"><code>Molly.ShiftedForceCutoff</code></a></li><li><a href="#Molly.ShiftedPotentialCutoff"><code>Molly.ShiftedPotentialCutoff</code></a></li><li><a href="#Molly.SoftSphere"><code>Molly.SoftSphere</code></a></li><li><a href="#Molly.SpecificForce1Atoms"><code>Molly.SpecificForce1Atoms</code></a></li><li><a href="#Molly.SpecificForce2Atoms"><code>Molly.SpecificForce2Atoms</code></a></li><li><a href="#Molly.SpecificForce3Atoms"><code>Molly.SpecificForce3Atoms</code></a></li><li><a href="#Molly.SpecificForce4Atoms"><code>Molly.SpecificForce4Atoms</code></a></li><li><a href="#Molly.SpecificInteraction"><code>Molly.SpecificInteraction</code></a></li><li><a href="#Molly.SteepestDescentMinimizer"><code>Molly.SteepestDescentMinimizer</code></a></li><li><a href="#Molly.StormerVerlet"><code>Molly.StormerVerlet</code></a></li><li><a href="#Molly.StructureWriter"><code>Molly.StructureWriter</code></a></li><li><a href="#Molly.System-Tuple{AbstractString, MolecularForceField}"><code>Molly.System</code></a></li><li><a href="#Molly.System-Union{Tuple{SimpleCrystals.Crystal{D, A, B} where {A, B&lt;:(AbstractVector{&lt;:SimpleCrystals.Atom{D}})}}, Tuple{D}} where D"><code>Molly.System</code></a></li><li><a href="#Molly.System"><code>Molly.System</code></a></li><li><a href="#Molly.System-Tuple{System}"><code>Molly.System</code></a></li><li><a href="#Molly.TemperatureREMD"><code>Molly.TemperatureREMD</code></a></li><li><a href="#Molly.TimeCorrelationLogger"><code>Molly.TimeCorrelationLogger</code></a></li><li><a href="#Molly.TreeNeighborFinder"><code>Molly.TreeNeighborFinder</code></a></li><li><a href="#Molly.TriclinicBoundary"><code>Molly.TriclinicBoundary</code></a></li><li><a href="#Molly.VelocityVerlet"><code>Molly.VelocityVerlet</code></a></li><li><a href="#Molly.Verlet"><code>Molly.Verlet</code></a></li><li><a href="#AtomsBase.n_dimensions-Tuple{CubicBoundary}"><code>AtomsBase.n_dimensions</code></a></li><li><a href="#Molly.AutoCorrelationLogger-Tuple{Any, Any, Integer, Integer}"><code>Molly.AutoCorrelationLogger</code></a></li><li><a href="#Molly.CoordinateLogger-Tuple{Any, Integer}"><code>Molly.CoordinateLogger</code></a></li><li><a href="#Molly.ForceLogger-Tuple{Any, Integer}"><code>Molly.ForceLogger</code></a></li><li><a href="#Molly.KineticEnergyLogger-Tuple{Type, Integer}"><code>Molly.KineticEnergyLogger</code></a></li><li><a href="#Molly.PotentialEnergyLogger-Tuple{Type, Integer}"><code>Molly.PotentialEnergyLogger</code></a></li><li><a href="#Molly.PressureLogger-Tuple{Type, Integer}"><code>Molly.PressureLogger</code></a></li><li><a href="#Molly.TemperatureLogger-Tuple{DataType, Integer}"><code>Molly.TemperatureLogger</code></a></li><li><a href="#Molly.TotalEnergyLogger-Tuple{DataType, Any}"><code>Molly.TotalEnergyLogger</code></a></li><li><a href="#Molly.VelocityLogger-Tuple{Any, Integer}"><code>Molly.VelocityLogger</code></a></li><li><a href="#Molly.VirialLogger-Tuple{Type, Integer}"><code>Molly.VirialLogger</code></a></li><li><a href="#Molly.accelerations"><code>Molly.accelerations</code></a></li><li><a href="#Molly.add_position_restraints-Tuple{Any, Any}"><code>Molly.add_position_restraints</code></a></li><li><a href="#Molly.apply_constraints!-Tuple{Any, Any, Any}"><code>Molly.apply_constraints!</code></a></li><li><a href="#Molly.apply_constraints!-Tuple{Any, SHAKE, Any, Any}"><code>Molly.apply_constraints!</code></a></li><li><a href="#Molly.apply_coupling!-Tuple{Any, Union{Tuple, NamedTuple}, Any, Any, Any}"><code>Molly.apply_coupling!</code></a></li><li><a href="#Molly.bond_angle-NTuple{4, Any}"><code>Molly.bond_angle</code></a></li><li><a href="#Molly.born_radii_and_grad-Tuple{ImplicitSolventOBC, Any, Any}"><code>Molly.born_radii_and_grad</code></a></li><li><a href="#Molly.box_center-Tuple{Union{CubicBoundary, RectangularBoundary}}"><code>Molly.box_center</code></a></li><li><a href="#Molly.box_volume-Tuple{Union{CubicBoundary, RectangularBoundary}}"><code>Molly.box_volume</code></a></li><li><a href="#Molly.charge-Tuple{Any}"><code>Molly.charge</code></a></li><li><a href="#Molly.displacements-Tuple{Any, Any}"><code>Molly.displacements</code></a></li><li><a href="#Molly.distances-Tuple{Any, Any}"><code>Molly.distances</code></a></li><li><a href="#Molly.extract_parameters-Tuple{Any, Any}"><code>Molly.extract_parameters</code></a></li><li><a href="#Molly.find_neighbors-Tuple{System}"><code>Molly.find_neighbors</code></a></li><li><a href="#Molly.float_type-Union{Tuple{Union{ReplicaSystem{D, G, T}, System{D, G, T}}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}"><code>Molly.float_type</code></a></li><li><a href="#Molly.force-NTuple{8, Any}"><code>Molly.force</code></a></li><li><a href="#Molly.forces-Union{Tuple{System{D, false}}, Tuple{D}, Tuple{System{D, false}, Any}} where D"><code>Molly.forces</code></a></li><li><a href="#Molly.inject_gradients-Union{Tuple{G}, Tuple{D}, Tuple{System{D, G}, Any}} where {D, G}"><code>Molly.inject_gradients</code></a></li><li><a href="#Molly.is_any_atom-Tuple{Any, Any}"><code>Molly.is_any_atom</code></a></li><li><a href="#Molly.is_heavy_atom-Tuple{Any, Any}"><code>Molly.is_heavy_atom</code></a></li><li><a href="#Molly.is_on_gpu-Union{Tuple{Union{ReplicaSystem{D, G}, System{D, G}}}, Tuple{G}, Tuple{D}} where {D, G}"><code>Molly.is_on_gpu</code></a></li><li><a href="#Molly.kinetic_energy-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}"><code>Molly.kinetic_energy</code></a></li><li><a href="#Molly.log_property!"><code>Molly.log_property!</code></a></li><li><a href="#Molly.mass-Tuple{Any}"><code>Molly.mass</code></a></li><li><a href="#Molly.masses-Tuple{System}"><code>Molly.masses</code></a></li><li><a href="#Molly.maxwell_boltzmann-Tuple{Any, Any, Any}"><code>Molly.maxwell_boltzmann</code></a></li><li><a href="#Molly.molecule_centers-Union{Tuple{C}, Tuple{D}, Tuple{AbstractArray{SVector{D, C}}, Any, Any}} where {D, C}"><code>Molly.molecule_centers</code></a></li><li><a href="#Molly.place_atoms-Tuple{Integer, Any}"><code>Molly.place_atoms</code></a></li><li><a href="#Molly.place_diatomics-Tuple{Integer, Any, Any}"><code>Molly.place_diatomics</code></a></li><li><a href="#Molly.potential_energy-Union{Tuple{System{D, false, T}}, Tuple{T}, Tuple{D}, Tuple{System{D, false, T}, Any}} where {D, T}"><code>Molly.potential_energy</code></a></li><li><a href="#Molly.pressure-Union{Tuple{AbstractSystem{D}}, Tuple{D}, Tuple{AbstractSystem{D}, Any}} where D"><code>Molly.pressure</code></a></li><li><a href="#Molly.radius_gyration-Tuple{Any, Any}"><code>Molly.radius_gyration</code></a></li><li><a href="#Molly.random_coord-Tuple{CubicBoundary}"><code>Molly.random_coord</code></a></li><li><a href="#Molly.random_normal_translation!-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}"><code>Molly.random_normal_translation!</code></a></li><li><a href="#Molly.random_uniform_translation!-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}"><code>Molly.random_uniform_translation!</code></a></li><li><a href="#Molly.random_velocities-Tuple{AbstractSystem{3}, Any}"><code>Molly.random_velocities</code></a></li><li><a href="#Molly.random_velocities!-Tuple{Any, Any}"><code>Molly.random_velocities!</code></a></li><li><a href="#Molly.random_velocity"><code>Molly.random_velocity</code></a></li><li><a href="#Molly.rdf-Tuple{Any, Any}"><code>Molly.rdf</code></a></li><li><a href="#Molly.remd_exchange!-Union{Tuple{T}, Tuple{G}, Tuple{D}, Tuple{ReplicaSystem{D, G, T}, TemperatureREMD, Integer, Integer}} where {D, G, T}"><code>Molly.remd_exchange!</code></a></li><li><a href="#Molly.remove_CM_motion!-Tuple{Any}"><code>Molly.remove_CM_motion!</code></a></li><li><a href="#Molly.rmsd-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{SVector{D, T}}, AbstractArray{SVector{D, T}}}} where {D, T}"><code>Molly.rmsd</code></a></li><li><a href="#Molly.run_loggers!"><code>Molly.run_loggers!</code></a></li><li><a href="#Molly.scale_boundary-Tuple{CubicBoundary, Any}"><code>Molly.scale_boundary</code></a></li><li><a href="#Molly.scale_coords!-Tuple{Any, Any}"><code>Molly.scale_coords!</code></a></li><li><a href="#Molly.simulate!-Tuple{Any, SteepestDescentMinimizer}"><code>Molly.simulate!</code></a></li><li><a href="#Molly.simulate_remd!-Tuple{ReplicaSystem, Any, Integer}"><code>Molly.simulate_remd!</code></a></li><li><a href="#Molly.temperature-Tuple{Any}"><code>Molly.temperature</code></a></li><li><a href="#Molly.torsion_angle-NTuple{5, Any}"><code>Molly.torsion_angle</code></a></li><li><a href="#Molly.total_energy"><code>Molly.total_energy</code></a></li><li><a href="#Molly.use_neighbors-Tuple{PairwiseInteraction}"><code>Molly.use_neighbors</code></a></li><li><a href="#Molly.ustrip_vec-Tuple"><code>Molly.ustrip_vec</code></a></li><li><a href="#Molly.vector-Tuple{Any, Any, Union{CubicBoundary, RectangularBoundary}}"><code>Molly.vector</code></a></li><li><a href="#Molly.vector_1D-Tuple{Any, Any, Any}"><code>Molly.vector_1D</code></a></li><li><a href="#Molly.velocity_autocorr-Union{Tuple{GeneralObservableLogger{T, typeof(Molly.velocities_wrapper)}}, Tuple{T}, Tuple{GeneralObservableLogger{T, typeof(Molly.velocities_wrapper)}, Integer}, Tuple{GeneralObservableLogger{T, typeof(Molly.velocities_wrapper)}, Integer, Integer}} where T"><code>Molly.velocity_autocorr</code></a></li><li><a href="#Molly.virial"><code>Molly.virial</code></a></li><li><a href="#Molly.visualize"><code>Molly.visualize</code></a></li><li><a href="#Molly.wrap_coord_1D-Tuple{Any, Any}"><code>Molly.wrap_coord_1D</code></a></li><li><a href="#Molly.wrap_coords-Tuple{Any, Union{CubicBoundary, RectangularBoundary}}"><code>Molly.wrap_coords</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Molly.AbstractGBSA" href="#Molly.AbstractGBSA"><code>Molly.AbstractGBSA</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Generalized Born (GB) implicit solvent models augmented with the hydrophobic solvent accessible surface area (SA) term.</p><p>Custom GBSA methods should sub-type this abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/implicit_solvent.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.AndersenThermostat" href="#Molly.AndersenThermostat"><code>Molly.AndersenThermostat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AndersenThermostat(temperature, coupling_const)</code></pre><p>The Andersen thermostat for controlling temperature.</p><p>The velocity of each atom is randomly changed each time step with probability <code>dt / coupling_const</code> to a velocity drawn from the Maxwell-Boltzmann distribution. See <a href="https://doi.org/10.1063/1.439486">Andersen 1980</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/coupling.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.Atom" href="#Molly.Atom"><code>Molly.Atom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Atom(; &lt;keyword arguments&gt;)</code></pre><p>An atom and its associated information.</p><p>Properties unused in the simulation or in analysis can be left with their default values. The types used should be bits types if the GPU is going to be used.</p><p><strong>Arguments</strong></p><ul><li><code>index::Int</code>: the index of the atom in the system.</li><li><code>charge::C=0.0</code>: the charge of the atom, used for electrostatic interactions.</li><li><code>mass::M=1.0u&quot;u&quot;</code>: the mass of the atom.</li><li><code>σ::S=0.0u&quot;nm&quot;</code>: the Lennard-Jones finite distance at which the inter-particle   potential is zero.</li><li><code>ϵ::E=0.0u&quot;kJ * mol^-1&quot;</code>: the Lennard-Jones depth of the potential well.</li><li><code>solute::Bool=false</code>: whether the atom is part of the solute.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L208-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.AtomData" href="#Molly.AtomData"><code>Molly.AtomData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AtomData(atom_type, atom_name, res_number, res_name)</code></pre><p>Data associated with an atom.</p><p>Storing this separately allows the <a href="#Molly.Atom"><code>Atom</code></a> types to be bits types and hence work on the GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L272-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.AtomType" href="#Molly.AtomType"><code>Molly.AtomType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AtomType(type, class, element, charge, mass, σ, ϵ)</code></pre><p>An atom type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/setup.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.AverageObservableLogger" href="#Molly.AverageObservableLogger"><code>Molly.AverageObservableLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AverageObservableLogger(observable::Function, T::DataType, n_steps::Integer;
                        n_blocks::Integer=1024)</code></pre><p>A logger that periodically records observations of a system and keeps a running empirical average.</p><p>While <a href="#Molly.GeneralObservableLogger"><code>GeneralObservableLogger</code></a> holds a full record of observations, <a href="#Molly.AverageObservableLogger"><code>AverageObservableLogger</code></a> does not. In addition, calling <code>values(logger::AverageObservableLogger; std::Bool=true)</code> returns two values: the current running average, and an estimate of the standard deviation for this average based on the block averaging method described in <a href="https://doi.org/10.1063/1.457480">Flyvbjerg and Petersen 1989</a>.</p><p><strong>Arguments</strong></p><ul><li><code>observable::Function</code>: the observable whose mean is recorded, must support   the method <code>observable(s::System, neighbors; n_threads::Integer)</code>.</li><li><code>T::DataType</code>: the type returned by <code>observable</code>.</li><li><code>n_steps::Integer</code>: number of simulation steps between observations.</li><li><code>n_blocks::Integer=1024</code>: the number of blocks used in the block averaging   method, should be an even number.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L449-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.BerendsenThermostat" href="#Molly.BerendsenThermostat"><code>Molly.BerendsenThermostat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BerendsenThermostat(temperature, coupling_const)</code></pre><p>The Berendsen thermostat for controlling temperature.</p><p>The scaling factor for the velocities each step is</p><p class="math-container">\[\lambda^2 = 1 + \frac{\delta t}{\tau} \left( \frac{T_0}{T} - 1 \right)\]</p><p>This thermostat should be used with caution as it can lead to simulation artifacts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/coupling.jl#L106-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.Buckingham" href="#Molly.Buckingham"><code>Molly.Buckingham</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Buckingham(; cutoff, use_neighbors, weight_special, force_units, energy_units)</code></pre><p>The Buckingham interaction between two atoms.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = A_{ij} \exp(-B_{ij} r_{ij}) - \frac{C_{ij}}{r_{ij}^6}\]</p><p>and the force on each atom by</p><p class="math-container">\[\vec{F}_i = \left( A_{ij} B_{ij} \exp(-B_{ij} r_{ij}) - 6 \frac{C_{ij}}{r_{ij}^7} \right) \frac{\vec{r}_{ij}}{r_{ij}}\]</p><p>The parameters are derived from the atom parameters according to</p><p class="math-container">\[\begin{aligned}
A_{ij} &amp;= (A_{ii} A_{jj})^{1/2} \\
B_{ij} &amp;= \frac{2}{\frac{1}{B_{ii}} + \frac{1}{B_{jj}}} \\
C_{ij} &amp;= (C_{ii} C_{jj})^{1/2}
\end{aligned}\]</p><p>so atoms that use this interaction should have fields <code>A</code>, <code>B</code> and <code>C</code> available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/buckingham.jl#L3-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.CellListMapNeighborFinder" href="#Molly.CellListMapNeighborFinder"><code>Molly.CellListMapNeighborFinder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CellListMapNeighborFinder(; eligible, dist_cutoff, special, n_steps, x0, unit_cell)</code></pre><p>Find close atoms by distance using a cell list algorithm from CellListMap.jl.</p><p><code>x0</code> and <code>unit_cell</code> are optional initial coordinates and system unit cell that improve the first approximation of the cell list structure. Can not be used if one or more dimensions has infinite boundaries.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; coords
15954-element Vector{SVector{3, Quantity{Float64, 𝐋, Unitful.FreeUnits{(nm,), 𝐋, nothing}}}}:
 [2.5193063341012127 nm, 3.907448346081021 nm, 4.694954671434135 nm]
 [2.4173958848835233 nm, 3.916034913604175 nm, 4.699661024574953 nm]
 ⋮
 [1.818842280373283 nm, 5.592152965227421 nm, 4.992100424805031 nm]
 [1.7261366568663976 nm, 5.610326185704369 nm, 5.084523386833478 nm]

julia&gt; boundary
CubicBoundary{Quantity{Float64, 𝐋, Unitful.FreeUnits{(nm,), 𝐋, nothing}}}(Quantity{Float64, 𝐋, Unitful.FreeUnits{(nm,), 𝐋, nothing}}[5.676 nm, 5.6627 nm, 6.2963 nm])

julia&gt; neighbor_finder = CellListMapNeighborFinder(
           eligible=s.neighbor_finder.eligible, dist_cutoff=1.2u&quot;nm&quot;,
           special=s.neighbor_finder.special, n_steps=10,
           x0=coords, unit_cell=boundary,
       )
CellListMapNeighborFinder{Quantity{Float64, 𝐋, Unitful.FreeUnits{(nm,), 𝐋, nothing}}, 3, Float64}
  Size of eligible matrix = (15954, 15954)
  n_steps = 10
  dist_cutoff = 1.2 nm
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/neighbors.jl#L192-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.CosineAngle" href="#Molly.CosineAngle"><code>Molly.CosineAngle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CosineAngle(; k, θ0)</code></pre><p>A cosine bond angle between three atoms.</p><p><code>θ0</code> is in radians. The potential energy is defined as</p><p class="math-container">\[V(\theta) = k(1 + \cos(\theta - \theta_0))\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/cosine_angle.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.Coulomb" href="#Molly.Coulomb"><code>Molly.Coulomb</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Coulomb(; cutoff, use_neighbors, weight_special, coulomb_const, force_units, energy_units)</code></pre><p>The Coulomb electrostatic interaction between two atoms.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = \frac{q_i q_j}{4 \pi \varepsilon_0 r_{ij}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/coulomb.jl#L6-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.CoulombReactionField" href="#Molly.CoulombReactionField"><code>Molly.CoulombReactionField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CoulombReactionField(; dist_cutoff, solvent_dielectric, use_neighbors, weight_special,
                        coulomb_const, force_units, energy_units)</code></pre><p>The Coulomb electrostatic interaction modified using the reaction field approximation between two atoms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/coulomb.jl#L220-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.CoulombSoftCore" href="#Molly.CoulombSoftCore"><code>Molly.CoulombSoftCore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CoulombSoftCore(; cutoff, α, λ, p, use_neighbors, lorentz_mixing, weight_special,
                coulomb_const, force_units, energy_units)</code></pre><p>The Coulomb electrostatic interaction between two atoms with a soft core.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = \frac{q_i q_j}{4 \pi \varepsilon_0 (r_{ij}^6 + \alpha  \sigma_{ij}^6  \lambda^p)^{\frac{1}{6}}}\]</p><p>If <span>$\alpha$</span> or <span>$\lambda$</span> are zero this gives the standard <a href="#Molly.Coulomb"><code>Coulomb</code></a> potential.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/coulomb.jl#L114-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.CubicBoundary" href="#Molly.CubicBoundary"><code>Molly.CubicBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CubicBoundary(x, y, z)
CubicBoundary(x)</code></pre><p>Cubic 3D bounding box defined by three side lengths.</p><p>If one length is given then all three sides will have that length. Setting one or more values to <code>Inf</code> gives no boundary in that dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L27-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.CubicSplineCutoff" href="#Molly.CubicSplineCutoff"><code>Molly.CubicSplineCutoff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CubicSplineCutoff(dist_activation, dist_cutoff)</code></pre><p>Cutoff that interpolates the true potential and zero between an activation point and a cutoff point, using a cubic Hermite spline.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/cutoffs.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.DistanceCutoff" href="#Molly.DistanceCutoff"><code>Molly.DistanceCutoff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DistanceCutoff(dist_cutoff)</code></pre><p>Cutoff that sets the potential and force to be zero past a specified cutoff point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/cutoffs.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.DistanceNeighborFinder" href="#Molly.DistanceNeighborFinder"><code>Molly.DistanceNeighborFinder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DistanceNeighborFinder(; eligible, dist_cutoff, special, n_steps)</code></pre><p>Find close atoms by distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/neighbors.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.FENEBond" href="#Molly.FENEBond"><code>Molly.FENEBond</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FENEBond(; k, r0, σ, ϵ)</code></pre><p>A finitely extensible non-linear elastic (FENE) bond between two atoms, see <a href="https://doi.org/10.1063/1.458541">Kremer and Grest 1990</a>.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r) = -\frac{1}{2} k r^2_0 \ln \left( 1 - \left( \frac{r}{r_0} \right) ^2 \right) + V_{\text{WCA}}(r)\]</p><p>where the WCA contribution is given by</p><p class="math-container">\[V_{\text{WCA}}(r) =
    \begin{cases}
      4\varepsilon \left[ \left( \frac{\sigma}{r} \right) ^{12} - \left( \frac{\sigma}{r} \right) ^6 \right] + \varepsilon &amp; r &lt; 2^{1/6}\sigma\\
      0 &amp; r \geq 2^{1/6}\sigma\\
    \end{cases}       \]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/fene_bond.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.GeneralObservableLogger" href="#Molly.GeneralObservableLogger"><code>Molly.GeneralObservableLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeneralObservableLogger(observable::Function, T, n_steps)</code></pre><p>A logger which holds a record of regularly sampled observations of a system. </p><p><code>observable</code> should return an object of type <code>T</code> and support the method <code>observable(s::System, neighbors; n_threads::Integer)::T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.Gravity" href="#Molly.Gravity"><code>Molly.Gravity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Gravity(; G, use_neighbors)</code></pre><p>The gravitational interaction between two atoms.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = -\frac{G m_i m_j}{r_{ij}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/gravity.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.HamiltonianREMD" href="#Molly.HamiltonianREMD"><code>Molly.HamiltonianREMD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HamiltonianREMD(; &lt;keyword arguments&gt;)</code></pre><p>A simulator for a parallel Hamiltonian replica exchange MD (H-REMD) simulation on a <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a>.</p><p>The replicas are expected to have different Hamiltonians, i.e. different interactions. When calling <a href="#Molly.simulate!-Tuple{Any, SteepestDescentMinimizer}"><code>simulate!</code></a>, the <code>assign_velocities</code> keyword argument determines whether to assign random velocities at the appropriate temperature for each replica.</p><p>Not currently compatible with automatic differentiation using Zygote.</p><p><strong>Arguments</strong></p><ul><li><code>dt::DT</code>: the time step of the simulation.</li><li><code>temperature::T</code>: the temperatures of the simulation.</li><li><code>simulators::ST</code>: individual simulators for simulating each replica.</li><li><code>exchange_time::ET</code>: the time interval between replica exchange attempts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/simulators.jl#L678-L695">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.HarmonicAngle" href="#Molly.HarmonicAngle"><code>Molly.HarmonicAngle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HarmonicAngle(; k, θ0)</code></pre><p>A harmonic bond angle between three atoms.</p><p><code>θ0</code> is in radians. The potential energy is defined as</p><p class="math-container">\[V(\theta) = \frac{1}{2} k (\theta - \theta_0)^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/harmonic_angle.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.HarmonicBond" href="#Molly.HarmonicBond"><code>Molly.HarmonicBond</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HarmonicBond(; k, r0)</code></pre><p>A harmonic bond between two atoms.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r) = \frac{1}{2} k (r - r_0)^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/harmonic_bond.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.HarmonicPositionRestraint" href="#Molly.HarmonicPositionRestraint"><code>Molly.HarmonicPositionRestraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HarmonicPositionRestraint(; k, x0)</code></pre><p>A harmonic position restraint on an atom to coordinate <code>x0</code>.</p><p>The potential energy is defined as</p><p class="math-container">\[V(\boldsymbol{x}) = \frac{1}{2} k |\boldsymbol{x} - \boldsymbol{x}_0|^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/harmonic_position_restraint.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.ImplicitSolventGBN2" href="#Molly.ImplicitSolventGBN2"><code>Molly.ImplicitSolventGBN2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ImplicitSolventGBN2(atoms, atoms_data, bonds)</code></pre><p>GBn2 solvation model.</p><p>Should be used along with a <a href="#Molly.Coulomb"><code>Coulomb</code></a> or <a href="#Molly.CoulombReactionField"><code>CoulombReactionField</code></a> interaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/implicit_solvent.jl#L443-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.ImplicitSolventOBC" href="#Molly.ImplicitSolventOBC"><code>Molly.ImplicitSolventOBC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ImplicitSolventOBC(atoms, atoms_data, bonds)</code></pre><p>Onufriev-Bashford-Case GBSA model.</p><p>Should be used along with a <a href="#Molly.Coulomb"><code>Coulomb</code></a> or <a href="#Molly.CoulombReactionField"><code>CoulombReactionField</code></a> interaction. The keyword argument <code>use_OBC2</code> determines whether to use parameter set I (<code>false</code>, the default) or II (<code>true</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/implicit_solvent.jl#L331-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.InteractionList1Atoms" href="#Molly.InteractionList1Atoms"><code>Molly.InteractionList1Atoms</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InteractionList1Atoms(is, inters)
InteractionList1Atoms(is, inters, types)
InteractionList1Atoms(inter_type)</code></pre><p>A list of specific interactions that involve one atom such as position restraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.InteractionList2Atoms" href="#Molly.InteractionList2Atoms"><code>Molly.InteractionList2Atoms</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InteractionList2Atoms(is, js, inters)
InteractionList2Atoms(is, js, inters, types)
InteractionList2Atoms(inter_type)</code></pre><p>A list of specific interactions that involve two atoms such as bond potentials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.InteractionList3Atoms" href="#Molly.InteractionList3Atoms"><code>Molly.InteractionList3Atoms</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InteractionList3Atoms(is, js, ks, inters)
InteractionList3Atoms(is, js, ks, inters, types)
InteractionList3Atoms(inter_type)</code></pre><p>A list of specific interactions that involve three atoms such as bond angle potentials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L77-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.InteractionList4Atoms" href="#Molly.InteractionList4Atoms"><code>Molly.InteractionList4Atoms</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InteractionList4Atoms(is, js, ks, ls, inters)
InteractionList4Atoms(is, js, ks, ls, inters, types)
InteractionList4Atoms(inter_type)</code></pre><p>A list of specific interactions that involve four atoms such as torsion potentials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.Langevin" href="#Molly.Langevin"><code>Molly.Langevin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Langevin(; &lt;keyword arguments&gt;)</code></pre><p>The Langevin integrator, based on the Langevin Middle Integrator in OpenMM.</p><p>This is a leapfrog integrator, so the velocities are offset by half a time step behind the positions.</p><p><strong>Arguments</strong></p><ul><li><code>dt::S</code>: the time step of the simulation.</li><li><code>temperature::K</code>: the equilibrium temperature of the simulation.</li><li><code>friction::F</code>: the friction coefficient of the simulation.</li><li><code>coupling::C=NoCoupling()</code>: the coupling which applies during the simulation.</li><li><code>remove_CM_motion=1</code>: remove the center of mass motion every this number of steps,   set to <code>false</code> or <code>0</code> to not remove center of mass motion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/simulators.jl#L288-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.LangevinSplitting" href="#Molly.LangevinSplitting"><code>Molly.LangevinSplitting</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LangevinSplitting(; &lt;keyword arguments&gt;)</code></pre><p>The Langevin simulator using a general splitting scheme.</p><p>This consists of a succession of <strong>A</strong>, <strong>B</strong> and <strong>O</strong> steps, corresponding respectively to updates in position, velocity for the potential part, and velocity for the thermal fluctuation-dissipation part. The <a href="#Molly.Langevin"><code>Langevin</code></a> and <a href="#Molly.VelocityVerlet"><code>VelocityVerlet</code></a> simulators without coupling correspond to the <strong>BAOA</strong> and <strong>BAB</strong> schemes respectively. For more information on the sampling properties of splitting schemes, see <a href="https://doi.org/10.3390/e20050318">Fass et al. 2018</a>.</p><p>Not currently compatible with automatic differentiation using Zygote.</p><p><strong>Arguments</strong></p><ul><li><code>dt::S</code>: the time step of the simulation.</li><li><code>temperature::K</code>: the equilibrium temperature of the simulation.</li><li><code>friction::F</code>: the friction coefficient. If units are used, it should have a   dimensionality of mass per time.</li><li><code>splitting::W</code>: the splitting specifier. Should be a string consisting of the   characters <code>A</code>, <code>B</code> and <code>O</code>. Strings with no <code>O</code>s reduce to deterministic   symplectic schemes.</li><li><code>remove_CM_motion=1</code>: remove the center of mass motion every this number of steps,   set to <code>false</code> or <code>0</code> to not remove center of mass motion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/simulators.jl#L361-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.LennardJones" href="#Molly.LennardJones"><code>Molly.LennardJones</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LennardJones(; cutoff, use_neighbors, lorentz_mixing, weight_special, weight_solute_solvent,
             force_units, energy_units, skip_shortcut)</code></pre><p>The Lennard-Jones 6-12 interaction between two atoms.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = 4\varepsilon_{ij} \left[\left(\frac{\sigma_{ij}}{r_{ij}}\right)^{12} - \left(\frac{\sigma_{ij}}{r_{ij}}\right)^{6}\right]\]</p><p>and the force on each atom by</p><p class="math-container">\[\begin{aligned}
\vec{F}_i &amp;= 24\varepsilon_{ij} \left(2\frac{\sigma_{ij}^{12}}{r_{ij}^{13}} - \frac{\sigma_{ij}^6}{r_{ij}^{7}}\right) \frac{\vec{r}_{ij}}{r_{ij}} \\
&amp;= \frac{24\varepsilon_{ij}}{r_{ij}^2} \left[2\left(\frac{\sigma_{ij}^{6}}{r_{ij}^{6}}\right)^2 -\left(\frac{\sigma_{ij}}{r_{ij}}\right)^{6}\right] \vec{r}_{ij}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/lennard_jones.jl#L5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.LennardJonesSoftCore" href="#Molly.LennardJonesSoftCore"><code>Molly.LennardJonesSoftCore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LennardJonesSoftCore(; cutoff, α, λ, p, use_neighbors, lorentz_mixing, weight_special,
                     weight_solute_solvent, force_units, energy_units, skip_shortcut)</code></pre><p>The Lennard-Jones 6-12 interaction between two atoms with a soft core.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = 4\varepsilon_{ij} \left[\left(\frac{\sigma_{ij}}{r_{ij}^{\text{sc}}}\right)^{12} - \left(\frac{\sigma_{ij}}{r_{ij}^{\text{sc}}}\right)^{6}\right]\]</p><p>and the force on each atom by</p><p class="math-container">\[\vec{F}_i = 24\varepsilon_{ij} \left(2\frac{\sigma_{ij}^{12}}{(r_{ij}^{\text{sc}})^{13}} - \frac{\sigma_{ij}^6}{(r_{ij}^{\text{sc}})^{7}}\right) \left(\frac{r_{ij}}{r_{ij}^{\text{sc}}}\right)^5 \frac{\vec{r}_{ij}}{r_{ij}}\]</p><p>where</p><p class="math-container">\[r_{ij}^{\text{sc}} = \left(r_{ij}^6 + \alpha \sigma_{ij}^6 \lambda^p \right)^{1/6}\]</p><p>If <span>$\alpha$</span> or <span>$\lambda$</span> are zero this gives the standard <a href="#Molly.LennardJones"><code>LennardJones</code></a> potential.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/lennard_jones.jl#L156-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.MetropolisMonteCarlo" href="#Molly.MetropolisMonteCarlo"><code>Molly.MetropolisMonteCarlo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MetropolisMonteCarlo(; &lt;keyword arguments&gt;)</code></pre><p>A Monte Carlo simulator that uses the Metropolis algorithm to sample the configuration space.</p><p><strong>Arguments</strong></p><ul><li><code>temperature::T</code>: the temperature of the system.</li><li><code>trial_moves::M</code>: a function that performs the trial moves.</li><li><code>trial_args::Dict</code>: a dictionary of arguments to be passed to the trial move function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/simulators.jl#L846-L855">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.Mie" href="#Molly.Mie"><code>Molly.Mie</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Mie(; m, n, cutoff, use_neighbors, lorentz_mixing, force_units, energy_units, skip_shortcut)</code></pre><p>The Mie generalized interaction between two atoms.</p><p>When <code>m</code> equals 6 and <code>n</code> equals 12 this is equivalent to the Lennard-Jones interaction. The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = C \varepsilon_{ij} \left[\left(\frac{\sigma_{ij}}{r_{ij}}\right)^n - \left(\frac{\sigma_{ij}}{r_{ij}}\right)^m\right]\]</p><p>where</p><p class="math-container">\[C = \frac{n}{n - m} \left( \frac{n}{m} \right) ^\frac{m}{n - m}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/mie.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.MolecularForceField" href="#Molly.MolecularForceField"><code>Molly.MolecularForceField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MolecularForceField(ff_files...; units=true)
MolecularForceField(T, ff_files...; units=true)
MolecularForceField(atom_types, residue_types, bond_types, angle_types,
                    torsion_types, torsion_order, weight_14_coulomb,
                    weight_14_lj, attributes_from_residue)</code></pre><p>A molecular force field.</p><p>Read one or more OpenMM force field XML files by passing them to the constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/setup.jl#L166-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.MolecularTopology" href="#Molly.MolecularTopology"><code>Molly.MolecularTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MolecularTopology(bond_is, bond_js, n_atoms)
MolecularTopology(atom_molecule_inds, molecule_atom_counts)</code></pre><p>Topology information for a system.</p><p>Stores the index of the molecule each atom belongs to and the number of atoms in each molecule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L297-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.MonteCarloBarostat" href="#Molly.MonteCarloBarostat"><code>Molly.MonteCarloBarostat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MonteCarloBarostat(pressure, temperature, boundary; n_steps=30, n_iterations=1,
                   scale_factor=0.01, scale_increment=1.1, max_volume_frac=0.3,
                   trial_find_neighbors=false)</code></pre><p>The Monte Carlo barostat for controlling pressure.</p><p>See <a href="https://doi.org/10.1016/0010-4655(95)00059-O">Chow and Ferguson 1995</a>, <a href="https://doi.org/10.1016/j.cplett.2003.12.039">Åqvist et al. 2004</a> and the OpenMM source code. At regular intervals a Monte Carlo step is attempted by scaling the coordinates and the bounding box by a randomly chosen amount. The step is accepted or rejected based on</p><p class="math-container">\[\Delta W = \Delta E + P \Delta V - N k_B T \ln \left( \frac{V + \Delta V}{V} \right)\]</p><p>where <code>ΔE</code> is the change in potential energy, <code>P</code> is the equilibrium pressure, <code>ΔV</code> is the change in volume, <code>N</code> is the number of molecules in the system, <code>T</code> is the equilibrium temperature and <code>V</code> is the system volume. If <code>ΔW ≤ 0</code> the step is always accepted, if <code>ΔW &gt; 0</code> the step is accepted with probability <code>exp(-ΔW/kT)</code>.</p><p>The scale factor is modified over time to maintain an acceptance rate of around half. If the topology of the system is set then molecules are moved as a unit so properties such as bond lengths do not change.</p><p>The barostat assumes that the simulation is being run at a constant temperature but does not actively control the temperature. It should be used alongside a temperature coupling method such as the <a href="#Molly.Langevin"><code>Langevin</code></a> simulator or <a href="#Molly.AndersenThermostat"><code>AndersenThermostat</code></a> coupling. The neighbor list is not updated when making trial moves or after accepted moves. Note that the barostat can change the bounding box of the system.</p><p>Not currently compatible with automatic differentiation using Zygote.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/coupling.jl#L131-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.MonteCarloLogger" href="#Molly.MonteCarloLogger"><code>Molly.MonteCarloLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MonteCarloLogger()
MonteCarloLogger(T)</code></pre><p>A logger that records acceptances in a Monte Carlo simulation.</p><p>The logged quantities include the number of new selections (<code>n_select</code>), the number of successful acceptances (<code>n_accept</code>), an array named <code>energy_rates</code> which stores the value of <span>$\frac{E}{k_B T}$</span> i.e. the argument of the Boltzmann factor for the states, and a <code>BitVector</code> named <code>state_changed</code> that stores whether a new state was accepted for the logged step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L568-L579">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.MorseBond" href="#Molly.MorseBond"><code>Molly.MorseBond</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MorseBond(; D, a, r0)</code></pre><p>A Morse potential bond between two atoms.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r) = D(1 - e^{-a(r - r_0)})^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/morse_bond.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.MullerBrown" href="#Molly.MullerBrown"><code>Molly.MullerBrown</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MullerBrown(; A, a, b, c, x0, y0, force_units, energy_units)</code></pre><p>The Müller-Brown potential energy surface.</p><p>The potential energy is defined as</p><p class="math-container">\[V(x,y) = \sum_{n=1}^{4} A_k \exp[a_k(x-x_k^0)^2 + b_k(x-x_k^0)(y-y_k^0) + c_k(y-y_k^0)^2]\]</p><p>where <code>A</code>, <code>a</code>, <code>b</code>, <code>c</code>, <code>x0</code>, <code>y0</code> are 4-element <code>SVector</code>s with standard defaults.</p><p>This potential is only compatible with 2D systems. It is often used for testing algorithms that find transition states or explore minimum energy pathways. There are 3 minima and 2 saddle points with the default parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/muller_brown.jl#L3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.NeighborList" href="#Molly.NeighborList"><code>Molly.NeighborList</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NeighborList(n, list)
NeighborList()</code></pre><p>Structure to contain neighbor lists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L332-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.NoCoupling" href="#Molly.NoCoupling"><code>Molly.NoCoupling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoCoupling()</code></pre><p>Placeholder coupler that does nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/coupling.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.NoCutoff" href="#Molly.NoCutoff"><code>Molly.NoCutoff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoCutoff()</code></pre><p>Placeholder cutoff that does not alter forces or potentials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/cutoffs.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.NoNeighborFinder" href="#Molly.NoNeighborFinder"><code>Molly.NoNeighborFinder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoNeighborFinder()</code></pre><p>Placeholder neighbor finder that returns no neighbors.</p><p>When using this neighbor finder, ensure that <a href="#Molly.use_neighbors-Tuple{PairwiseInteraction}"><code>use_neighbors</code></a> for the interactions returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/neighbors.jl#L10-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.NoseHoover" href="#Molly.NoseHoover"><code>Molly.NoseHoover</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoseHoover(; &lt;keyword arguments&gt;)</code></pre><p>The Nosé-Hoover integrator, a NVT simulator that extends velocity Verlet to control the temperature of the system.</p><p>See <a href="https://doi.org/10.1063/1.449071">Evans and Holian 1985</a>. The current implementation is limited to ergodic systems.</p><p><strong>Arguments</strong></p><ul><li><code>dt::T</code>: the time step of the simulation.</li><li><code>temperature::K</code>: the equilibrium temperature of the simulation.</li><li><code>damping::D=100*dt</code>: the temperature damping time scale.</li><li><code>coupling::C=NoCoupling()</code>: the coupling which applies during the simulation.</li><li><code>remove_CM_motion=1</code>: remove the center of mass motion every this number of steps,   set to <code>false</code> or <code>0</code> to not remove center of mass motion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/simulators.jl#L488-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.PairwiseInteraction" href="#Molly.PairwiseInteraction"><code>Molly.PairwiseInteraction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A pairwise interaction that will apply to all or most atom pairs.</p><p>Custom pairwise interactions should sub-type this abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.PeriodicTorsion" href="#Molly.PeriodicTorsion"><code>Molly.PeriodicTorsion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PeriodicTorsion(; periodicities, phases, ks, proper)</code></pre><p>A periodic torsion angle between four atoms.</p><p><code>phases</code> are in radians. The potential energy is defined as</p><p class="math-container">\[V(\phi) = \sum_{n=1}^N k_n (1 + \cos(n \phi - \phi_{s,n}))\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/periodic_torsion.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.PeriodicTorsionType" href="#Molly.PeriodicTorsionType"><code>Molly.PeriodicTorsionType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PeriodicTorsionType(periodicities, phases, ks, proper)</code></pre><p>A periodic torsion type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/setup.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.RBTorsion" href="#Molly.RBTorsion"><code>Molly.RBTorsion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RBTorsion(; f1, f2, f3, f4)</code></pre><p>A Ryckaert-Bellemans torsion angle between four atoms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/rb_torsion.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.RectangularBoundary" href="#Molly.RectangularBoundary"><code>Molly.RectangularBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RectangularBoundary(x, y)
RectangularBoundary(x)</code></pre><p>Rectangular 2D bounding box defined by two side lengths.</p><p>If one length is given then both sides will have that length. Setting one or more values to <code>Inf</code> gives no boundary in that dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L53-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.ReplicaExchangeLogger" href="#Molly.ReplicaExchangeLogger"><code>Molly.ReplicaExchangeLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReplicaExchangeLogger(n_replicas)
ReplicaExchangeLogger(T, n_replicas)</code></pre><p>A logger that records exchanges in a replica exchange simulation.</p><p>The logged quantities include the number of exchange attempts (<code>n_attempts</code>), number of successful exchanges (<code>n_exchanges</code>), exchanged replica indices (<code>indices</code>), exchange steps (<code>steps</code>) and the value of Δ i.e. the argument of Metropolis rate for the exchanges (<code>deltas</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L522-L532">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.ReplicaSystem" href="#Molly.ReplicaSystem"><code>Molly.ReplicaSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReplicaSystem(; &lt;keyword arguments&gt;)</code></pre><p>A wrapper for replicas in a replica exchange simulation.</p><p>Each individual replica is a <a href="#Molly.System"><code>System</code></a>. Properties unused in the simulation or in analysis can be left with their default values. The minimal required arguments are <code>atoms</code>, <code>replica_coords</code>, <code>boundary</code> and <code>n_replicas</code>. <code>atoms</code> and the elements in <code>replica_coords</code> should have the same length, along with <code>atoms_data</code> and the elements in <code>replica_velocities</code> if these are provided. The number of elements in <code>replica_coords</code>, <code>replica_velocities</code>, <code>replica_loggers</code> and  the interaction arguments <code>replica_pairwise_inters</code>, <code>replica_specific_inter_lists</code>,  <code>replica_general_inters</code> and <code>replica_constraints</code> should be equal to <code>n_replicas</code>. This is a sub-type of <code>AbstractSystem</code> from AtomsBase.jl and implements the interface described there.</p><p>When using <code>ReplicaSystem</code> with <a href="#Molly.CellListMapNeighborFinder"><code>CellListMapNeighborFinder</code></a>, the number of threads used for both the simulation of replicas and the neighbor finder should be set to be the same. This can be done by passing <code>nbatches=(min(n, 8), n)</code> to <a href="#Molly.CellListMapNeighborFinder"><code>CellListMapNeighborFinder</code></a> during construction where <code>n</code> is the number of threads to be used per replica.</p><p><strong>Arguments</strong></p><ul><li><code>atoms::A</code>: the atoms, or atom equivalents, in the system. Can be   of any type but should be a bits type if the GPU is used.</li><li><code>replica_coords</code>: the coordinates of the atoms in each replica.</li><li><code>boundary::B</code>: the bounding box in which the simulation takes place.</li><li><code>n_replicas::Integer</code>: the number of replicas of the system.</li><li><code>replica_velocities=[zero(replica_coords[1]) * u&quot;ps^-1&quot; for _ in 1:n_replicas]</code>:   the velocities of the atoms in each replica.</li><li><code>atoms_data::AD</code>: other data associated with the atoms, allowing the atoms to   be bits types and hence work on the GPU.</li><li><code>topology::TO=nothing</code>: topological information about the system such as which   atoms are in the same molecule (to be used if the same for all replicas).   This is only used if no value is passed to the argument <code>replica_topology</code>.</li><li><code>replica_topology=[nothing for _ in 1:n_replicas]</code>: the topological information for    each replica.</li><li><code>pairwise_inters::PI=()</code>: the pairwise interactions in the system, i.e. interactions    between all or most atom pairs such as electrostatics (to be used if the same for all replicas).   Typically a <code>Tuple</code>. This is only used if no value is passed to the argument    <code>replica_pairwise_inters</code>.</li><li><code>replica_pairwise_inters=[() for _ in 1:n_replicas]</code>: the pairwise interactions for    each replica.</li><li><code>specific_inter_lists::SI=()</code>: the specific interactions in the system, i.e. interactions    between specific atoms such as bonds or angles (to be used if the same for all replicas).    Typically a <code>Tuple</code>. This is only used if no value is passed to the argument    <code>replica_specific_inter_lists</code>.</li><li><code>replica_specific_inter_lists=[() for _ in 1:n_replicas]</code>: the specific interactions in    each replica.</li><li><code>general_inters::GI=()</code>: the general interactions in the system, i.e. interactions involving    all atoms such as implicit solvent (to be used if the same for all replicas). Typically a   <code>Tuple</code>. This is only used if no value is passed to the argument <code>replica_general_inters</code>.</li><li><code>replica_general_inters=[() for _ in 1:n_replicas]</code>: the general interactions for    each replica.</li><li><code>constraints::CN=()</code>: the constraints for bonds and angles in the system (to be used if the same    for all replicas). Typically a <code>Tuple</code>.</li><li><code>replica_constraints=[() for _ in 1:n_replicas]</code>: the constraints for bonds and angles in each   replica. This is only used if no value is passed to the argument <code>replica_constraints</code>.</li><li><code>neighbor_finder::NF=NoNeighborFinder()</code>: the neighbor finder used to find   close atoms and save on computation. It is duplicated for each replica.</li><li><code>replica_loggers=[() for _ in 1:n_replicas]</code>: the loggers for each replica    that record properties of interest during a simulation.</li><li><code>exchange_logger::EL=ReplicaExchangeLogger(n_replicas)</code>: the logger used to record   the exchange of replicas.</li><li><code>k::K=Unitful.k</code>: the Boltzmann constant, which may be modified in some   simulations.</li><li><code>force_units::F=u&quot;kJ * mol^-1 * nm^-1&quot;</code>: the units of force of the system.   Should be set to <code>NoUnits</code> if units are not being used.</li><li><code>energy_units::E=u&quot;kJ * mol^-1&quot;</code>: the units of energy of the system. Should   be set to <code>NoUnits</code> if units are not being used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L674-L743">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.RescaleThermostat" href="#Molly.RescaleThermostat"><code>Molly.RescaleThermostat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RescaleThermostat(temperature)</code></pre><p>The velocity rescaling thermostat for controlling temperature.</p><p>Velocities are immediately rescaled to match a target temperature. The scaling factor for the velocities each step is</p><p class="math-container">\[\lambda = \sqrt{\frac{T_0}{T}}\]</p><p>This thermostat should be used with caution as it can lead to simulation artifacts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/coupling.jl#L82-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.ResidueType" href="#Molly.ResidueType"><code>Molly.ResidueType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ResidueType(name, types, charges, indices)</code></pre><p>A residue type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/setup.jl#L142-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.SHAKE" href="#Molly.SHAKE"><code>Molly.SHAKE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SHAKE(dists, is, js)</code></pre><p>Constrains a set of bonds to defined distances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/constraints.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.ShiftedForceCutoff" href="#Molly.ShiftedForceCutoff"><code>Molly.ShiftedForceCutoff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ShiftedForceCutoff(dist_cutoff)</code></pre><p>Cutoff that shifts the force to be continuous at a specified cutoff point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/cutoffs.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.ShiftedPotentialCutoff" href="#Molly.ShiftedPotentialCutoff"><code>Molly.ShiftedPotentialCutoff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ShiftedPotentialCutoff(dist_cutoff)</code></pre><p>Cutoff that shifts the potential to be continuous at a specified cutoff point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/cutoffs.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.SoftSphere" href="#Molly.SoftSphere"><code>Molly.SoftSphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SoftSphere(; cutoff, use_neighbors, lorentz_mixing, force_units, energy_units, skip_shortcut)</code></pre><p>The soft-sphere potential.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = 4\varepsilon_{ij} \left(\frac{\sigma_{ij}}{r_{ij}}\right)^{12}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/soft_sphere.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.SpecificForce1Atoms" href="#Molly.SpecificForce1Atoms"><code>Molly.SpecificForce1Atoms</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SpecificForce1Atoms(f1)</code></pre><p>Force on one atom arising from an interaction such as a position restraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/force.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.SpecificForce2Atoms" href="#Molly.SpecificForce2Atoms"><code>Molly.SpecificForce2Atoms</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SpecificForce2Atoms(f1, f2)</code></pre><p>Forces on two atoms arising from an interaction such as a bond potential.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/force.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.SpecificForce3Atoms" href="#Molly.SpecificForce3Atoms"><code>Molly.SpecificForce3Atoms</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SpecificForce3Atoms(f1, f2, f3)</code></pre><p>Forces on three atoms arising from an interaction such as a bond angle potential.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/force.jl#L106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.SpecificForce4Atoms" href="#Molly.SpecificForce4Atoms"><code>Molly.SpecificForce4Atoms</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SpecificForce4Atoms(f1, f2, f3, f4)</code></pre><p>Forces on four atoms arising from an interaction such as a torsion potential.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/force.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.SpecificInteraction" href="#Molly.SpecificInteraction"><code>Molly.SpecificInteraction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A specific interaction between sets of specific atoms, e.g. a bond angle.</p><p>Custom specific interactions should sub-type this abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.SteepestDescentMinimizer" href="#Molly.SteepestDescentMinimizer"><code>Molly.SteepestDescentMinimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SteepestDescentMinimizer(; &lt;keyword arguments&gt;)</code></pre><p>Steepest descent energy minimization.</p><p>Not currently compatible with automatic differentiation using Zygote.</p><p><strong>Arguments</strong></p><ul><li><code>step_size::D=0.01u&quot;nm&quot;</code>: the initial maximum displacement.</li><li><code>max_steps::Int=1000</code>: the maximum number of steps.</li><li><code>tol::F=1000.0u&quot;kJ * mol^-1 * nm^-1&quot;</code>: the maximum force below which to   finish minimization.</li><li><code>log_stream::L=devnull</code>: stream to print minimization progress to.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/simulators.jl#L20-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.StormerVerlet" href="#Molly.StormerVerlet"><code>Molly.StormerVerlet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StormerVerlet(; &lt;keyword arguments&gt;)</code></pre><p>The Störmer-Verlet integrator.</p><p>The velocity calculation is accurate to O(dt).</p><p>Does not currently work with coupling methods that alter the velocity. Does not currently remove the center of mass motion.</p><p><strong>Arguments</strong></p><ul><li><code>dt::T</code>: the time step of the simulation.</li><li><code>coupling::C=NoCoupling()</code>: the coupling which applies during the simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/simulators.jl#L226-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.StructureWriter" href="#Molly.StructureWriter"><code>Molly.StructureWriter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StructureWriter(n_steps, filepath, excluded_res=String[])</code></pre><p>Write 3D output structures to a file in the PDB format throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.System" href="#Molly.System"><code>Molly.System</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">System(; &lt;keyword arguments&gt;)</code></pre><p>A physical system to be simulated.</p><p>Properties unused in the simulation or in analysis can be left with their default values. The minimal required arguments are <code>atoms</code>, <code>coords</code> and <code>boundary</code>. <code>atoms</code> and <code>coords</code> should have the same length, along with <code>velocities</code> and <code>atoms_data</code> if these are provided. This is a sub-type of <code>AbstractSystem</code> from AtomsBase.jl and implements the interface described there.</p><p><strong>Arguments</strong></p><ul><li><code>atoms::A</code>: the atoms, or atom equivalents, in the system. Can be   of any type but should be a bits type if the GPU is used.</li><li><code>coords::C</code>: the coordinates of the atoms in the system. Typically a   vector of <code>SVector</code>s of 2 or 3 dimensions.</li><li><code>boundary::B</code>: the bounding box in which the simulation takes place.</li><li><code>velocities::V=zero(coords) * u&quot;ps^-1&quot;</code>: the velocities of the atoms in the   system.</li><li><code>atoms_data::AD=[]</code>: other data associated with the atoms, allowing the atoms to   be bits types and hence work on the GPU.</li><li><code>topology::TO=nothing</code>: topological information about the system such as which   atoms are in the same molecule.</li><li><code>pairwise_inters::PI=()</code>: the pairwise interactions in the system, i.e.   interactions between all or most atom pairs such as electrostatics.   Typically a <code>Tuple</code>.</li><li><code>specific_inter_lists::SI=()</code>: the specific interactions in the system,   i.e. interactions between specific atoms such as bonds or angles. Typically   a <code>Tuple</code>.</li><li><code>general_inters::GI=()</code>: the general interactions in the system,   i.e. interactions involving all atoms such as implicit solvent. Typically   a <code>Tuple</code>.</li><li><code>constraints::CN=()</code>: the constraints for bonds and angles in the system. Typically   a <code>Tuple</code>.</li><li><code>neighbor_finder::NF=NoNeighborFinder()</code>: the neighbor finder used to find   close atoms and save on computation.</li><li><code>loggers::L=()</code>: the loggers that record properties of interest during a   simulation.</li><li><code>k::K=Unitful.k</code>: the Boltzmann constant, which may be modified in some   simulations.</li><li><code>force_units::F=u&quot;kJ * mol^-1 * nm^-1&quot;</code>: the units of force of the system.   Should be set to <code>NoUnits</code> if units are not being used.</li><li><code>energy_units::E=u&quot;kJ * mol^-1&quot;</code>: the units of energy of the system. Should   be set to <code>NoUnits</code> if units are not being used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L422-L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.System-Tuple{AbstractString, MolecularForceField}" href="#Molly.System-Tuple{AbstractString, MolecularForceField}"><code>Molly.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">System(coordinate_file, force_field; &lt;keyword arguments&gt;)</code></pre><p>Read a coordinate file in a file format readable by Chemfiles and apply a force field to it.</p><p>Atom names should exactly match residue templates - no searching of residue templates is carried out.</p><pre><code class="language-none">System(coordinate_file, topology_file; &lt;keyword arguments&gt;)
System(T, coordinate_file, topology_file; &lt;keyword arguments&gt;)</code></pre><p>Read a Gromacs coordinate file and a Gromacs topology file with all includes collapsed into one file.</p><p>Gromacs file reading should be considered experimental. The <code>implicit_solvent</code>, <code>kappa</code> and <code>rename_terminal_res</code> keyword arguments are not available when reading Gromacs files.</p><p><strong>Arguments</strong></p><ul><li><code>boundary=nothing</code>: the bounding box used for simulation, read from the   file by default.</li><li><code>velocities=nothing</code>: the velocities of the atoms in the system, set to   zero by default.</li><li><code>loggers=()</code>: the loggers that record properties of interest during a   simulation.</li><li><code>units::Bool=true</code>: whether to use Unitful quantities.</li><li><code>gpu::Bool=false</code>: whether to move the relevant parts of the system onto   the GPU.</li><li><code>dist_cutoff=1.0u&quot;nm&quot;</code>: cutoff distance for long-range interactions.</li><li><code>dist_neighbors=1.2u&quot;nm&quot;</code>: cutoff distance for the neighbor list, should be   greater than <code>dist_cutoff</code>.</li><li><code>center_coords::Bool=true</code>: whether to center the coordinates in the   simulation box.</li><li><code>use_cell_list::Bool=true</code>: whether to use <a href="#Molly.CellListMapNeighborFinder"><code>CellListMapNeighborFinder</code></a>   on CPU. If <code>false</code>, <a href="#Molly.DistanceNeighborFinder"><code>DistanceNeighborFinder</code></a> is used.</li><li><code>implicit_solvent=nothing</code>: specify a string to add an implicit solvent   model, options are &quot;obc1&quot;, &quot;obc2&quot; and &quot;gbn2&quot;.</li><li><code>kappa=0.0u&quot;nm^-1&quot;</code>: the kappa value for the implicit solvent model if one   is used.</li><li><code>rename_terminal_res=true</code>: whether to rename the first and last residues   to match the appropriate atom templates, for example the first (N-terminal)   residue could be changed from &quot;MET&quot; to &quot;NMET&quot;.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/setup.jl#L400-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.System-Tuple{System}" href="#Molly.System-Tuple{System}"><code>Molly.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">System(sys; &lt;keyword arguments&gt;)</code></pre><p>Convenience constructor for changing properties in a <code>System</code>.</p><p>A copy of the <code>System</code> is returned with the provided keyword arguments modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L569-L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.System-Union{Tuple{SimpleCrystals.Crystal{D, A, B} where {A, B&lt;:(AbstractVector{&lt;:SimpleCrystals.Atom{D}})}}, Tuple{D}} where D" href="#Molly.System-Union{Tuple{SimpleCrystals.Crystal{D, A, B} where {A, B&lt;:(AbstractVector{&lt;:SimpleCrystals.Atom{D}})}}, Tuple{D}} where D"><code>Molly.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">System(crystal; &lt;keyword arguments&gt;)</code></pre><p>Construct a <code>System</code> from a SimpleCrystals.jl <code>Crystal</code> struct.</p><p>Properties unused in the simulation or in analysis can be left with their default values. <code>atoms</code>, <code>atoms_data</code>, <code>coords</code> and <code>boundary</code> are automatically calcualted from the <code>Crystal</code> struct. Extra atom paramaters like <code>σ</code> have to be added manually after construction using the convenience constructor <code>System(sys; &lt;keyword arguments&gt;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L611-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.TemperatureREMD" href="#Molly.TemperatureREMD"><code>Molly.TemperatureREMD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TemperatureREMD(; &lt;keyword arguments&gt;)</code></pre><p>A simulator for a parallel temperature replica exchange MD (T-REMD) simulation on a <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a>.</p><p>See <a href="https://doi.org/10.1016/S0009-2614(99)01123-9">Sugita and Okamoto 1999</a>. The corresponding <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a> should have the same number of replicas as the number of temperatures in the simulator. When calling <a href="#Molly.simulate!-Tuple{Any, SteepestDescentMinimizer}"><code>simulate!</code></a>, the <code>assign_velocities</code> keyword argument determines whether to assign random velocities at the appropriate temperature for each replica.</p><p>Not currently compatible with automatic differentiation using Zygote.</p><p><strong>Arguments</strong></p><ul><li><code>dt::DT</code>: the time step of the simulation.</li><li><code>temperatures::TP</code>: the temperatures corresponding to the replicas.</li><li><code>simulators::ST</code>: individual simulators for simulating each replica.</li><li><code>exchange_time::ET</code>: the time interval between replica exchange attempts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/simulators.jl#L567-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.TimeCorrelationLogger" href="#Molly.TimeCorrelationLogger"><code>Molly.TimeCorrelationLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TimeCorrelationLogger(observableA::Function, observableB::Function,
                        TA::DataType, TB::DataType,
                        observable_length::Integer, n_correlation::Integer)</code></pre><p>A time correlation logger.</p><p>Estimates statistical correlations of normalized form</p><p class="math-container">\[C(t)=\frac{\langle A_t\cdot B_0\rangle -\langle A\rangle\cdot \langle B\rangle}{\sqrt{\langle |A|^2\rangle\langle |B|^2\rangle}}\]</p><p>or unnormalized form</p><p class="math-container">\[C(t)=\langle A_t\cdot B_0\rangle -\langle A \rangle\cdot \langle B\rangle\]</p><p>These can be used to estimate statistical error, or to compute transport coefficients from Green-Kubo type formulas. <em>A</em> and <em>B</em> are observables, functions of the form <code>observable(sys::System, neighbors; n_threads::Integer)</code>.     The return values of <em>A</em> and <em>B</em> can be of scalar or vector type (including <code>Vector{SVector{...}}</code>, like positions or velocities) and must implement <code>dot</code>.</p><p><code>n_correlation</code> should typically be chosen so that <code>dt * n_correlation &gt; t_corr</code>, where <code>dt</code> is the simulation timestep and <code>t_corr</code> is the decorrelation time for the considered system and observables. For the purpose of numerical stability, the logger internally records sums instead of running averages. The normalized and unnormalized form of the correlation function can be retrieved through <code>values(logger::TimeCorrelationLogger; normalize::Bool)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>observableA::Function</code>: the function corresponding to observable A.</li><li><code>observableB::Function</code>: the function corresponding to observable B.</li><li><code>TA::DataType</code>: the type returned by <code>observableA</code>, supporting <code>zero(TA)</code>.</li><li><code>TB::DataType</code>: the type returned by <code>observableB</code>, supporting <code>zero(TB)</code>.</li><li><code>observable_length::Integer</code>: the length of the observables if they are   vectors, or <code>1</code> if they are scalar-valued.</li><li><code>n_correlation::Integer</code>: the length of the computed correlation vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L291-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.TreeNeighborFinder" href="#Molly.TreeNeighborFinder"><code>Molly.TreeNeighborFinder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TreeNeighborFinder(; eligible, dist_cutoff, special, n_steps)</code></pre><p>Find close atoms by distance using a tree search.</p><p>Can not be used if one or more dimensions has infinite boundaries. Can not be used with <a href="#Molly.TriclinicBoundary"><code>TriclinicBoundary</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/neighbors.jl#L138-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.TriclinicBoundary" href="#Molly.TriclinicBoundary"><code>Molly.TriclinicBoundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TriclinicBoundary(v1, v2, v3; approx_images=true)
TriclinicBoundary(SVector(v1, v2, v3); approx_images=true)
TriclinicBoundary(SVector(l1, l2, l3), SVector(α, β, γ); approx_images=true)
TriclinicBoundary(arr; approx_images=true)</code></pre><p>Triclinic 3D bounding box defined by 3 <code>SVector{3}</code> basis vectors or basis vector lengths and angles α/β/γ in radians.</p><p>The first basis vector must point along the x-axis and the second must lie in the xy plane. An approximation is used to find the closest periodic image when using the minimum image convention. The approximation is correct for distances shorter than half the shortest box height/width. Setting the keyword argument <code>approx_images</code> to <code>false</code> means the exact closest image is found, which is slower.</p><p>Not currently compatible with infinite boundaries. Not currently compatible with automatic differentiation using Zygote.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L79-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.VelocityVerlet" href="#Molly.VelocityVerlet"><code>Molly.VelocityVerlet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VelocityVerlet(; &lt;keyword arguments&gt;)</code></pre><p>The velocity Verlet integrator.</p><p><strong>Arguments</strong></p><ul><li><code>dt::T</code>: the time step of the simulation.</li><li><code>coupling::C=NoCoupling()</code>: the coupling which applies during the simulation.</li><li><code>remove_CM_motion=1</code>: remove the center of mass motion every this number of steps,   set to <code>false</code> or <code>0</code> to not remove center of mass motion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/simulators.jl#L105-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.Verlet" href="#Molly.Verlet"><code>Molly.Verlet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Verlet(; &lt;keyword arguments&gt;)</code></pre><p>The leapfrog Verlet integrator.</p><p>This is a leapfrog integrator, so the velocities are offset by half a time step behind the positions.</p><p><strong>Arguments</strong></p><ul><li><code>dt::T</code>: the time step of the simulation.</li><li><code>coupling::C=NoCoupling()</code>: the coupling which applies during the simulation.</li><li><code>remove_CM_motion=1</code>: remove the center of mass motion every this number of steps,   set to <code>false</code> or <code>0</code> to not remove center of mass motion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/simulators.jl#L168-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtomsBase.n_dimensions-Tuple{CubicBoundary}" href="#AtomsBase.n_dimensions-Tuple{CubicBoundary}"><code>AtomsBase.n_dimensions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">n_dimensions(boundary)</code></pre><p>Number of dimensions of a bounding box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.AutoCorrelationLogger-Tuple{Any, Any, Integer, Integer}" href="#Molly.AutoCorrelationLogger-Tuple{Any, Any, Integer, Integer}"><code>Molly.AutoCorrelationLogger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AutoCorrelationLogger(observable::Function, TA::DataType,
                        observable_length::Integer, n_correlation::Integer)</code></pre><p>An autocorrelation logger, equivalent to a <a href="#Molly.TimeCorrelationLogger"><code>TimeCorrelationLogger</code></a> in the case that <code>observableA == observableB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L376-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.CoordinateLogger-Tuple{Any, Integer}" href="#Molly.CoordinateLogger-Tuple{Any, Integer}"><code>Molly.CoordinateLogger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CoordinateLogger(n_steps; dims=3)
CoordinateLogger(T, n_steps; dims=3)</code></pre><p>Log the coordinates throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L105-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.ForceLogger-Tuple{Any, Integer}" href="#Molly.ForceLogger-Tuple{Any, Integer}"><code>Molly.ForceLogger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ForceLogger(n_steps; dims=3)
ForceLogger(T, n_steps; dims=3)</code></pre><p>Log the <a href="#Molly.forces-Union{Tuple{System{D, false}}, Tuple{D}, Tuple{System{D, false}, Any}} where D"><code>forces</code></a> throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L181-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.KineticEnergyLogger-Tuple{Type, Integer}" href="#Molly.KineticEnergyLogger-Tuple{Type, Integer}"><code>Molly.KineticEnergyLogger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">KineticEnergyLogger(n_steps)
KineticEnergyLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.kinetic_energy-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}"><code>kinetic_energy</code></a> of a system throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L153-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.PotentialEnergyLogger-Tuple{Type, Integer}" href="#Molly.PotentialEnergyLogger-Tuple{Type, Integer}"><code>Molly.PotentialEnergyLogger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PotentialEnergyLogger(n_steps)
PotentialEnergyLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.potential_energy-Union{Tuple{System{D, false, T}}, Tuple{T}, Tuple{D}, Tuple{System{D, false, T}, Any}} where {D, T}"><code>potential_energy</code></a> of a system throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L167-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.PressureLogger-Tuple{Type, Integer}" href="#Molly.PressureLogger-Tuple{Type, Integer}"><code>Molly.PressureLogger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PressureLogger(n_steps)
PressureLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.pressure-Union{Tuple{AbstractSystem{D}}, Tuple{D}, Tuple{AbstractSystem{D}, Any}} where D"><code>pressure</code></a> of a system throughout a simulation.</p><p>This should only be used on systems containing just pairwise interactions, or where the specific interactions, general interactions and constraints do not contribute to the pressure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L214-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.TemperatureLogger-Tuple{DataType, Integer}" href="#Molly.TemperatureLogger-Tuple{DataType, Integer}"><code>Molly.TemperatureLogger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TemperatureLogger(n_steps)
TemperatureLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.temperature-Tuple{Any}"><code>temperature</code></a> throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.TotalEnergyLogger-Tuple{DataType, Any}" href="#Molly.TotalEnergyLogger-Tuple{DataType, Any}"><code>Molly.TotalEnergyLogger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TotalEnergyLogger(n_steps)
TotalEnergyLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.total_energy"><code>total_energy</code></a> of a system throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.VelocityLogger-Tuple{Any, Integer}" href="#Molly.VelocityLogger-Tuple{Any, Integer}"><code>Molly.VelocityLogger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">VelocityLogger(n_steps; dims=3)
VelocityLogger(T, n_steps; dims=3)</code></pre><p>Log the velocities throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.VirialLogger-Tuple{Type, Integer}" href="#Molly.VirialLogger-Tuple{Type, Integer}"><code>Molly.VirialLogger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">VirialLogger(n_steps)
VirialLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.virial"><code>virial</code></a> of a system throughout a simulation.</p><p>This should only be used on systems containing just pairwise interactions, or where the specific interactions, general interactions and constraints do not contribute to the virial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L196-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.accelerations" href="#Molly.accelerations"><code>Molly.accelerations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">accelerations(system, neighbors=nothing; n_threads=Threads.nthreads())</code></pre><p>Calculate the accelerations of all atoms in a system using the pairwise, specific and general interactions and Newton&#39;s second law of motion.</p><p>If the interactions use neighbor lists, the neighbors should be computed first and passed to the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/force.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.add_position_restraints-Tuple{Any, Any}" href="#Molly.add_position_restraints-Tuple{Any, Any}"><code>Molly.add_position_restraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_position_restraints(sys, k; atom_selector=is_any_atom, restrain_coords=sys.coords)</code></pre><p>Return a copy of a <a href="#Molly.System"><code>System</code></a> with <a href="#Molly.HarmonicPositionRestraint"><code>HarmonicPositionRestraint</code></a>s added to restrain the atoms.</p><p>The force constant <code>k</code> can be a single value or an array of equal length to the number of atoms in the system. The <code>atom_selector</code> function takes in each atom and atom data and determines whether to restrain that atom. For example, <a href="#Molly.is_heavy_atom-Tuple{Any, Any}"><code>is_heavy_atom</code></a> means non-hydrogen atoms are restrained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/setup.jl#L1345-L1356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.apply_constraints!-Tuple{Any, Any, Any}" href="#Molly.apply_constraints!-Tuple{Any, Any, Any}"><code>Molly.apply_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_constraints!(system, old_coords, dt)</code></pre><p>Applies all the bond and angle constraints associated with the <a href="#Molly.System"><code>System</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/constraints.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.apply_constraints!-Tuple{Any, SHAKE, Any, Any}" href="#Molly.apply_constraints!-Tuple{Any, SHAKE, Any, Any}"><code>Molly.apply_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_constraints!(sys, constraint, old_coords, dt)</code></pre><p>Updates the coordinates and/or velocities of a <a href="#Molly.System"><code>System</code></a> based on the constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/constraints.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.apply_coupling!-Tuple{Any, Union{Tuple, NamedTuple}, Any, Any, Any}" href="#Molly.apply_coupling!-Tuple{Any, Union{Tuple, NamedTuple}, Any, Any, Any}"><code>Molly.apply_coupling!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_coupling!(system, coupling, simulator, neighbors=nothing,
                step_n=0; n_threads=Threads.nthreads())</code></pre><p>Apply a coupler to modify a simulation.</p><p>Returns whether the coupling has invalidated the currently stored forces, for example by changing the coordinates. This information is useful for some simulators. If <code>coupling</code> is a tuple or named tuple then each coupler will be applied in turn. Custom couplers should implement this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/coupling.jl#L11-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.bond_angle-NTuple{4, Any}" href="#Molly.bond_angle-NTuple{4, Any}"><code>Molly.bond_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bond_angle(coord_i, coord_j, coord_k, boundary)
bond_angle(vec_ji, vec_jk)</code></pre><p>Calculate the bond or pseudo-bond angle in radians between three coordinates or two vectors.</p><p>The angle between j→i and j→k is returned in the range 0 to π.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L513-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.born_radii_and_grad-Tuple{ImplicitSolventOBC, Any, Any}" href="#Molly.born_radii_and_grad-Tuple{ImplicitSolventOBC, Any, Any}"><code>Molly.born_radii_and_grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">born_radii_and_grad(inter, coords, boundary)</code></pre><p>Calculate Born radii, gradients of Born radii and surface area overlap with respect to atomic distance.</p><p>Custom GBSA methods should implement this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/interactions/implicit_solvent.jl#L632-L639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.box_center-Tuple{Union{CubicBoundary, RectangularBoundary}}" href="#Molly.box_center-Tuple{Union{CubicBoundary, RectangularBoundary}}"><code>Molly.box_center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">box_center(boundary)</code></pre><p>Calculate the center of a bounding box.</p><p>Dimensions with infinite length return zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L231-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.box_volume-Tuple{Union{CubicBoundary, RectangularBoundary}}" href="#Molly.box_volume-Tuple{Union{CubicBoundary, RectangularBoundary}}"><code>Molly.box_volume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">box_volume(boundary)</code></pre><p>Calculate the volume of a 3D bounding box or the area of a 2D bounding box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L223-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.charge-Tuple{Any}" href="#Molly.charge-Tuple{Any}"><code>Molly.charge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">charge(atom)</code></pre><p>The partial charge of an <a href="#Molly.Atom"><code>Atom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L250-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.displacements-Tuple{Any, Any}" href="#Molly.displacements-Tuple{Any, Any}"><code>Molly.displacements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">displacements(coords, boundary)</code></pre><p>Calculate the pairwise vector displacements of a set of coordinates, accounting for the periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/analysis.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.distances-Tuple{Any, Any}" href="#Molly.distances-Tuple{Any, Any}"><code>Molly.distances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distances(coords, boundary)</code></pre><p>Calculate the pairwise distances of a set of coordinates, accounting for the periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/analysis.jl#L72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.extract_parameters-Tuple{Any, Any}" href="#Molly.extract_parameters-Tuple{Any, Any}"><code>Molly.extract_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">extract_parameters(system, force_field)</code></pre><p>Form a <code>Dict</code> of all parameters in a <a href="#Molly.System"><code>System</code></a>, allowing gradients to be tracked.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/gradients.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.find_neighbors-Tuple{System}" href="#Molly.find_neighbors-Tuple{System}"><code>Molly.find_neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_neighbors(system; n_threads=Threads.nthreads())
find_neighbors(system, neighbor_finder, current_neighbors=nothing, step_n=0,
               force_recompute=false; n_threads=Threads.nthreads())</code></pre><p>Obtain a list of close atoms in a <a href="#Molly.System"><code>System</code></a>.</p><p>Custom neighbor finders should implement this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/neighbors.jl#L20-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.float_type-Union{Tuple{Union{ReplicaSystem{D, G, T}, System{D, G, T}}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}" href="#Molly.float_type-Union{Tuple{Union{ReplicaSystem{D, G, T}, System{D, G, T}}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}"><code>Molly.float_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">float_type(sys)
float_type(boundary)</code></pre><p>The float type a <a href="#Molly.System"><code>System</code></a>, <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a> or bounding box uses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L926-L931">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.force-NTuple{8, Any}" href="#Molly.force-NTuple{8, Any}"><code>Molly.force</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">force(inter::PairwiseInteraction, vec_ij, coord_i, coord_j,
      atom_i, atom_j, boundary)
force(inter::PairwiseInteraction, vec_ij, coord_i, coord_j,
      atom_i, atom_j, boundary, special)
force(inter::SpecificInteraction, coord_i, coord_j,
      boundary)
force(inter::SpecificInteraction, coord_i, coord_j,
      coord_k, boundary)
force(inter::SpecificInteraction, coord_i, coord_j,
      coord_k, coord_l, boundary)</code></pre><p>Calculate the force between atoms due to a given interaction type.</p><p>For <a href="#Molly.PairwiseInteraction"><code>PairwiseInteraction</code></a>s returns a single force vector and for <a href="#Molly.SpecificInteraction"><code>SpecificInteraction</code></a>s returns a type such as <a href="#Molly.SpecificForce2Atoms"><code>SpecificForce2Atoms</code></a>. Custom pairwise and specific interaction types should implement this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/force.jl#L57-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.forces-Union{Tuple{System{D, false}}, Tuple{D}, Tuple{System{D, false}, Any}} where D" href="#Molly.forces-Union{Tuple{System{D, false}}, Tuple{D}, Tuple{System{D, false}, Any}} where D"><code>Molly.forces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">forces(system, neighbors=nothing; n_threads=Threads.nthreads())</code></pre><p>Calculate the forces on all atoms in a system using the pairwise, specific and general interactions.</p><p>If the interactions use neighbor lists, the neighbors should be computed first and passed to the function.</p><pre><code class="language-none">forces(inter, system, neighbors=nothing; n_threads=Threads.nthreads())</code></pre><p>Calculate the forces on all atoms in a system arising from a general interaction.</p><p>If the interaction uses neighbor lists, the neighbors should be computed first and passed to the function. Custom general interaction types should implement this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/force.jl#L152-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.inject_gradients-Union{Tuple{G}, Tuple{D}, Tuple{System{D, G}, Any}} where {D, G}" href="#Molly.inject_gradients-Union{Tuple{G}, Tuple{D}, Tuple{System{D, G}, Any}} where {D, G}"><code>Molly.inject_gradients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inject_gradients(sys, params_dic)</code></pre><p>Add parameters from a dictionary to a <a href="#Molly.System"><code>System</code></a>.</p><p>Allows gradients for individual parameters to be tracked. Returns atoms, pairwise interactions, specific interaction lists and general interactions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/gradients.jl#L83-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.is_any_atom-Tuple{Any, Any}" href="#Molly.is_any_atom-Tuple{Any, Any}"><code>Molly.is_any_atom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_any_atom(at, at_data)</code></pre><p>Placeholder function that returns <code>true</code>, used to select any <a href="#Molly.Atom"><code>Atom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/setup.jl#L1325-L1329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.is_heavy_atom-Tuple{Any, Any}" href="#Molly.is_heavy_atom-Tuple{Any, Any}"><code>Molly.is_heavy_atom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_heavy_atom(at, at_data)</code></pre><p>Determines whether an <a href="#Molly.Atom"><code>Atom</code></a> is a heavy atom, i.e. any element other than hydrogen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/setup.jl#L1332-L1336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.is_on_gpu-Union{Tuple{Union{ReplicaSystem{D, G}, System{D, G}}}, Tuple{G}, Tuple{D}} where {D, G}" href="#Molly.is_on_gpu-Union{Tuple{Union{ReplicaSystem{D, G}, System{D, G}}}, Tuple{G}, Tuple{D}} where {D, G}"><code>Molly.is_on_gpu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_on_gpu(sys)</code></pre><p>Whether a <a href="#Molly.System"><code>System</code></a> or <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a> is on the GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L919-L923">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.kinetic_energy-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}" href="#Molly.kinetic_energy-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}"><code>Molly.kinetic_energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kinetic_energy(system)</code></pre><p>Calculate the kinetic energy of a system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/energy.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.log_property!" href="#Molly.log_property!"><code>Molly.log_property!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">log_property!(logger, system, neighbors=nothing, step_n=0; n_threads=Threads.nthreads(), kwargs...)</code></pre><p>Log a property of a system throughout a simulation.</p><p>Custom loggers should implement this function. Additional keyword arguments can be passed to the logger if required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L65-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.mass-Tuple{Any}" href="#Molly.mass-Tuple{Any}"><code>Molly.mass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mass(atom)</code></pre><p>The mass of an <a href="#Molly.Atom"><code>Atom</code></a>.</p><p>Custom atom types should implement this function unless they have a <code>mass</code> field defined, which the function accesses by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L257-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.masses-Tuple{System}" href="#Molly.masses-Tuple{System}"><code>Molly.masses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">masses(sys)</code></pre><p>The masses of the atoms in a <a href="#Molly.System"><code>System</code></a> or <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L934-L938">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.maxwell_boltzmann-Tuple{Any, Any, Any}" href="#Molly.maxwell_boltzmann-Tuple{Any, Any, Any}"><code>Molly.maxwell_boltzmann</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">maxwell_boltzmann(mass, temperature; rng=Random.GLOBAL_RNG)
maxwell_boltzmann(mass, temperature, k; rng=Random.GLOBAL_RNG)</code></pre><p>Generate a random velocity along one dimension from the Maxwell-Boltzmann distribution, with optional custom Boltzmann constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L451-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.molecule_centers-Union{Tuple{C}, Tuple{D}, Tuple{AbstractArray{SVector{D, C}}, Any, Any}} where {D, C}" href="#Molly.molecule_centers-Union{Tuple{C}, Tuple{D}, Tuple{AbstractArray{SVector{D, C}}, Any, Any}} where {D, C}"><code>Molly.molecule_centers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">molecule_centers(coords, boundary, topology)</code></pre><p>Calculate the coordinates of the center of each molecule in a system.</p><p>Accounts for periodic boundary conditions by using the circular mean. If <code>topology=nothing</code> then the coordinates are returned.</p><p>Not currently compatible with <a href="#Molly.TriclinicBoundary"><code>TriclinicBoundary</code></a> if the topology is set. Not currently compatible with automatic differentiation using Zygote.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L704-L714">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.place_atoms-Tuple{Integer, Any}" href="#Molly.place_atoms-Tuple{Integer, Any}"><code>Molly.place_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">place_atoms(n_atoms, boundary; min_dist=nothing, max_attempts=100)</code></pre><p>Generate random coordinates.</p><p>Obtain <code>n_atoms</code> coordinates in bounding box <code>boundary</code> where no two points are closer than <code>min_dist</code>, accounting for periodic boundary conditions. The keyword argument <code>max_attempts</code> determines the number of failed tries after which to stop placing atoms. Can not be used if one or more dimensions has infinite boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/setup.jl#L16-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.place_diatomics-Tuple{Integer, Any, Any}" href="#Molly.place_diatomics-Tuple{Integer, Any, Any}"><code>Molly.place_diatomics</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">place_diatomics(n_molecules, boundary, bond_length; min_dist=nothing,
                max_attempts=100, aligned=false)</code></pre><p>Generate random diatomic molecule coordinates.</p><p>Obtain coordinates for <code>n_molecules</code> diatomics in bounding box <code>boundary</code> where no two points are closer than <code>min_dist</code> and the bond length is <code>bond_length</code>, accounting for periodic boundary conditions. The keyword argument <code>max_attempts</code> determines the number of failed tries after which to stop placing atoms. The keyword argument <code>aligned</code> determines whether the bonds all point the same direction (<code>true</code>) or random directions (<code>false</code>). Can not be used if one or more dimensions has infinite boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/setup.jl#L64-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.potential_energy-Union{Tuple{System{D, false, T}}, Tuple{T}, Tuple{D}, Tuple{System{D, false, T}, Any}} where {D, T}" href="#Molly.potential_energy-Union{Tuple{System{D, false, T}}, Tuple{T}, Tuple{D}, Tuple{System{D, false, T}, Any}} where {D, T}"><code>Molly.potential_energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">potential_energy(system, neighbors=nothing; n_threads=Threads.nthreads())</code></pre><p>Calculate the potential energy of a system using the pairwise, specific and general interactions.</p><p>If the interactions use neighbor lists, the neighbors should be computed first and passed to the function.</p><pre><code class="language-none">potential_energy(inter::PairwiseInteraction, vec_ij, coord_i, coord_j,
                 atom_i, atom_j, boundary)
potential_energy(inter::SpecificInteraction, coords_i, coords_j,
                 boundary)
potential_energy(inter::SpecificInteraction, coords_i, coords_j,
                 coords_k, boundary)
potential_energy(inter::SpecificInteraction, coords_i, coords_j,
                 coords_k, coords_l, boundary)
potential_energy(inter, system, neighbors=nothing; n_threads=Threads.nthreads())</code></pre><p>Calculate the potential energy due to a given interaction type.</p><p>Custom interaction types should implement this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/energy.jl#L75-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.pressure-Union{Tuple{AbstractSystem{D}}, Tuple{D}, Tuple{AbstractSystem{D}, Any}} where D" href="#Molly.pressure-Union{Tuple{AbstractSystem{D}}, Tuple{D}, Tuple{AbstractSystem{D}, Any}} where D"><code>Molly.pressure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pressure(sys, neighbors=nothing)</code></pre><p>Calculate the pressure of a system.</p><p>The pressure is defined as</p><p class="math-container">\[P = \frac{1}{V} \left( NkT - \frac{2}{D} \Xi \right)\]</p><p>where <code>V</code> is the system volume, <code>N</code> is the number of atoms, <code>k</code> is the Boltzmann constant, <code>T</code> is the system temperature, <code>D</code> is the number of dimensions and <code>Ξ</code> is the virial calculated using <a href="#Molly.virial"><code>virial</code></a>. If the interactions use neighbor lists, the neighbors should be computed first and passed to the function.</p><p>This should only be used on systems containing just pairwise interactions, or where the specific interactions, constraints and general interactions without <a href="#Molly.virial"><code>virial</code></a> defined do not contribute to the virial. Not compatible with infinite boundaries. Not currently compatible with automatic differentiation using Zygote when using pairwise interactions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L664-L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.radius_gyration-Tuple{Any, Any}" href="#Molly.radius_gyration-Tuple{Any, Any}"><code>Molly.radius_gyration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">radius_gyration(coords, atoms)</code></pre><p>Calculate the radius of gyration of a set of coordinates.</p><p>Assumes the coordinates do not cross the bounding box, i.e. all coordinates correspond to the same periodic image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/analysis.jl#L150-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.random_coord-Tuple{CubicBoundary}" href="#Molly.random_coord-Tuple{CubicBoundary}"><code>Molly.random_coord</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">random_coord(boundary)</code></pre><p>Generate a random coordinate uniformly distributed within a bounding box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L299-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.random_normal_translation!-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}" href="#Molly.random_normal_translation!-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}"><code>Molly.random_normal_translation!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">random_normal_translation!(sys::System; shift_size=oneunit(eltype(eltype(sys.coords))))</code></pre><p>Performs a random translation of the coordinates of a randomly selected atom in a <a href="#Molly.System"><code>System</code></a>.</p><p>The translation is generated using a uniformly chosen direction and length selected from the standard normal distribution i.e. with mean 0 and standard deviation 1, scaled by <code>shift_size</code> which should have appropriate length units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/simulators.jl#L912-L920">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.random_uniform_translation!-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}" href="#Molly.random_uniform_translation!-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}"><code>Molly.random_uniform_translation!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">random_uniform_translation!(sys::System; shift_size=oneunit(eltype(eltype(sys.coords))))</code></pre><p>Performs a random translation of the coordinates of a randomly selected atom in a <a href="#Molly.System"><code>System</code></a>.</p><p>The translation is generated using a uniformly selected direction and uniformly selected length in range [0, 1) scaled by <code>shift_size</code> which should have appropriate length units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/simulators.jl#L895-L902">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.random_velocities!-Tuple{Any, Any}" href="#Molly.random_velocities!-Tuple{Any, Any}"><code>Molly.random_velocities!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">random_velocities!(sys, temp)</code></pre><p>Set the velocities of a <a href="#Molly.System"><code>System</code></a> to random velocities generated from the Maxwell-Boltzmann distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L499-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.random_velocities-Tuple{AbstractSystem{3}, Any}" href="#Molly.random_velocities-Tuple{AbstractSystem{3}, Any}"><code>Molly.random_velocities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">random_velocities(sys, temp)</code></pre><p>Generate random velocities from the Maxwell-Boltzmann distribution for a <a href="#Molly.System"><code>System</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L469-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.random_velocity" href="#Molly.random_velocity"><code>Molly.random_velocity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_velocity(mass, temperature; dims=3)
random_velocity(mass, temperature, k; dims=3)</code></pre><p>Generate a random velocity from the Maxwell-Boltzmann distribution, with optional custom Boltzmann constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L424-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.rdf-Tuple{Any, Any}" href="#Molly.rdf-Tuple{Any, Any}"><code>Molly.rdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rdf(coords, boundary; npoints=200)</code></pre><p>Calculate the radial distribution function of a set of coordinates.</p><p>This describes how density varies as a function of distance from each atom. Returns a list of distance bin centers and a list of the corresponding densities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/analysis.jl#L80-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.remd_exchange!-Union{Tuple{T}, Tuple{G}, Tuple{D}, Tuple{ReplicaSystem{D, G, T}, TemperatureREMD, Integer, Integer}} where {D, G, T}" href="#Molly.remd_exchange!-Union{Tuple{T}, Tuple{G}, Tuple{D}, Tuple{ReplicaSystem{D, G, T}, TemperatureREMD, Integer, Integer}} where {D, G, T}"><code>Molly.remd_exchange!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">remd_exchange!(sys, sim, n, m; rng=Random.GLOBAL_RNG, n_threads=Threads.nthreads())</code></pre><p>Attempt an exchange of replicas <code>n</code> and <code>m</code> in a <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a> during a REMD simulation.</p><p>Successful exchanges should exchange coordinates and velocities as appropriate. Returns acceptance quantity <code>Δ</code> and a <code>Bool</code> indicating whether the exchange was successful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/simulators.jl#L640-L647">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.remove_CM_motion!-Tuple{Any}" href="#Molly.remove_CM_motion!-Tuple{Any}"><code>Molly.remove_CM_motion!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">remove_CM_motion!(system)</code></pre><p>Remove the center of mass motion from a <a href="#Molly.System"><code>System</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L562-L566">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.rmsd-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{SVector{D, T}}, AbstractArray{SVector{D, T}}}} where {D, T}" href="#Molly.rmsd-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{SVector{D, T}}, AbstractArray{SVector{D, T}}}} where {D, T}"><code>Molly.rmsd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rmsd(coords_1, coords_2)</code></pre><p>Calculate the root-mean-square deviation (RMSD) of two sets of 3D coordinates after superimposition by the Kabsch algorithm.</p><p>Assumes the coordinates do not cross the bounding box, i.e. all coordinates in each set correspond to the same periodic image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/analysis.jl#L121-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.run_loggers!" href="#Molly.run_loggers!"><code>Molly.run_loggers!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">run_loggers!(system, neighbors=nothing, step_n=0; n_threads=Threads.nthreads(), kwargs...)</code></pre><p>Run the loggers associated with a system.</p><p>Ignored for gradient calculation during automatic differentiation. Additional keyword arguments can be passed to the loggers if required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/loggers.jl#L23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.scale_boundary-Tuple{CubicBoundary, Any}" href="#Molly.scale_boundary-Tuple{CubicBoundary, Any}"><code>Molly.scale_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scale_boundary(boundary, scale_factor)</code></pre><p>Scale the sides of a bounding box by a scaling factor.</p><p>For a 3D bounding box the volume scales as the cube of the scaling factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L244-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.scale_coords!-Tuple{Any, Any}" href="#Molly.scale_coords!-Tuple{Any, Any}"><code>Molly.scale_coords!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scale_coords!(sys, scale_factor; ignore_molecules=false)</code></pre><p>Scale the coordinates and bounding box of a system by a scaling factor.</p><p>Velocities are not scaled. If the topology of the system is set then atoms in the same molecule will be moved by the same amount according to the center of coordinates of the molecule. This can be disabled with <code>ignore_molecules=true</code>.</p><p>Not currently compatible with <a href="#Molly.TriclinicBoundary"><code>TriclinicBoundary</code></a> if the topology is set. Not currently compatible with automatic differentiation using Zygote.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L746-L758">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.simulate!-Tuple{Any, SteepestDescentMinimizer}" href="#Molly.simulate!-Tuple{Any, SteepestDescentMinimizer}"><code>Molly.simulate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simulate!(system, simulator, n_steps; n_threads=Threads.nthreads(), run_loggers=true)
simulate!(system, simulator; n_threads=Threads.nthreads(), run_loggers=true)</code></pre><p>Run a simulation on a system according to the rules of the given simulator.</p><p><code>run_loggers</code> is <code>true</code> by default except for <a href="#Molly.SteepestDescentMinimizer"><code>SteepestDescentMinimizer</code></a>, where it is <code>false</code>. Custom simulators should implement this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/simulators.jl#L49-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.simulate_remd!-Tuple{ReplicaSystem, Any, Integer}" href="#Molly.simulate_remd!-Tuple{ReplicaSystem, Any, Integer}"><code>Molly.simulate_remd!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simulate_remd!(sys, remd_sim, n_steps; rng=Random.GLOBAL_RNG,
               n_threads=Threads.nthreads(), run_loggers=true)</code></pre><p>Run a REMD simulation on a <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a> using a REMD simulator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/simulators.jl#L776-L781">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.temperature-Tuple{Any}" href="#Molly.temperature-Tuple{Any}"><code>Molly.temperature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">temperature(system)</code></pre><p>Calculate the temperature of a system from the kinetic energy of the atoms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/energy.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.torsion_angle-NTuple{5, Any}" href="#Molly.torsion_angle-NTuple{5, Any}"><code>Molly.torsion_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">torsion_angle(coord_i, coord_j, coord_k, coord_l, boundary)
torsion_angle(vec_ij, vec_jk, vec_kl)</code></pre><p>Calculate the torsion angle in radians defined by four coordinates or three vectors.</p><p>The angle between the planes defined by atoms (i, j, k) and (j, k, l) is returned in the range -π to π.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L532-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.total_energy" href="#Molly.total_energy"><code>Molly.total_energy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">total_energy(system, neighbors=nothing; n_threads=Threads.nthreads())</code></pre><p>Calculate the total energy of a system as the sum of the <a href="#Molly.kinetic_energy-Union{Tuple{System{D, G, T}}, Tuple{T}, Tuple{G}, Tuple{D}} where {D, G, T}"><code>kinetic_energy</code></a> and the <a href="#Molly.potential_energy-Union{Tuple{System{D, false, T}}, Tuple{T}, Tuple{D}, Tuple{System{D, false, T}, Any}} where {D, T}"><code>potential_energy</code></a>.</p><p>If the interactions use neighbor lists, the neighbors should be computed first and passed to the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/energy.jl#L9-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.use_neighbors-Tuple{PairwiseInteraction}" href="#Molly.use_neighbors-Tuple{PairwiseInteraction}"><code>Molly.use_neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">use_neighbors(inter)</code></pre><p>Whether a pairwise interaction uses the neighbor list, default <code>false</code>.</p><p>Custom pairwise interactions can define a method for this function. For built-in interactions such as <a href="#Molly.LennardJones"><code>LennardJones</code></a> this function accesses the <code>use_neighbors</code> field of the struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/types.jl#L32-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.ustrip_vec-Tuple" href="#Molly.ustrip_vec-Tuple"><code>Molly.ustrip_vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ustrip_vec(x)
ustrip_vec(u, x)</code></pre><p>Broadcasted form of <code>ustrip</code> from Unitful.jl, allowing e.g. <code>ustrip_vec.(coords)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/force.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.vector-Tuple{Any, Any, Union{CubicBoundary, RectangularBoundary}}" href="#Molly.vector-Tuple{Any, Any, Union{CubicBoundary, RectangularBoundary}}"><code>Molly.vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector(c1, c2, boundary)</code></pre><p>Displacement between two coordinate values from c1 to c2, accounting for periodic boundary conditions.</p><p>The minimum image convention is used, so the displacement is to the closest version of the coordinates accounting for the periodic boundaries. For the <a href="#Molly.TriclinicBoundary"><code>TriclinicBoundary</code></a> an approximation is used to find the closest version by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L328-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.vector_1D-Tuple{Any, Any, Any}" href="#Molly.vector_1D-Tuple{Any, Any, Any}"><code>Molly.vector_1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_1D(c1, c2, side_length)</code></pre><p>Displacement between two 1D coordinate values from c1 to c2, accounting for periodic boundary conditions in a <a href="#Molly.CubicBoundary"><code>CubicBoundary</code></a> or <a href="#Molly.RectangularBoundary"><code>RectangularBoundary</code></a>.</p><p>The minimum image convention is used, so the displacement is to the closest version of the coordinate accounting for the periodic boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L311-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.velocity_autocorr-Union{Tuple{GeneralObservableLogger{T, typeof(Molly.velocities_wrapper)}}, Tuple{T}, Tuple{GeneralObservableLogger{T, typeof(Molly.velocities_wrapper)}, Integer}, Tuple{GeneralObservableLogger{T, typeof(Molly.velocities_wrapper)}, Integer, Integer}} where T" href="#Molly.velocity_autocorr-Union{Tuple{GeneralObservableLogger{T, typeof(Molly.velocities_wrapper)}}, Tuple{T}, Tuple{GeneralObservableLogger{T, typeof(Molly.velocities_wrapper)}, Integer}, Tuple{GeneralObservableLogger{T, typeof(Molly.velocities_wrapper)}, Integer, Integer}} where T"><code>Molly.velocity_autocorr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">velocity_autocorr(vl, first_ind, last_ind)</code></pre><p>Calculate the autocorrelation function of velocity from the velocity logger.</p><p>This characterizes the similarity between velocities observed at different time instances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/analysis.jl#L107-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.virial" href="#Molly.virial"><code>Molly.virial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">virial(sys, neighbors=nothing; n_threads=Threads.nthreads())
virial(inter, sys, neighbors=nothing; n_threads=Threads.nthreads())</code></pre><p>Calculate the virial of a system or the virial resulting from a general interaction.</p><p>The virial is defined as</p><p class="math-container">\[\Xi = -\frac{1}{2} \sum_{i,j&gt;i} r_{ij} \cdot F_{ij}\]</p><p>If the interactions use neighbor lists, the neighbors should be computed first and passed to the function. Custom general interaction types can implement this function.</p><p>This should only be used on systems containing just pairwise interactions, or where the specific interactions, constraints and general interactions without <a href="#Molly.virial"><code>virial</code></a> defined do not contribute to the virial. Not currently compatible with automatic differentiation using Zygote when using pairwise interactions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L575-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.visualize" href="#Molly.visualize"><code>Molly.visualize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize(coord_logger, boundary, out_filepath; &lt;keyword arguments&gt;)</code></pre><p>Visualize a simulation as an animation.</p><p>This function is only available when GLMakie is imported. GLMakie v0.8 or later should be used. It can take a while to run, depending on the length of the simulation and the number of atoms.</p><p><strong>Arguments</strong></p><ul><li><code>connections=Tuple{Int, Int}[]</code>: pairs of atoms indices to link with bonds.</li><li><code>connection_frames</code>: the frames in which bonds are shown. Should be a list of   the same length as the number of frames, where each item is a list of   <code>Bool</code>s of the same length as <code>connections</code>. Defaults to always <code>true</code>.</li><li><code>trails::Integer=0</code>: the number of preceding frames to show as transparent   trails.</li><li><code>framerate::Integer=30</code>: the frame rate of the animation.</li><li><code>color=:purple</code>: the color of the atoms. Can be a single color or a list of   colors of the same length as the number of atoms.</li><li><code>connection_color=:orange</code>: the color of the bonds. Can be a single color or a   list of colors of the same length as <code>connections</code>.</li><li><code>markersize=0.05</code>: the size of the atom markers, in the units of the data.</li><li><code>linewidth=2.0</code>: the width of the bond lines.</li><li><code>transparency=true</code>: whether transparency is active on the plot.</li><li><code>show_boundary::Bool=true</code>: whether to show the bounding box as lines.</li><li><code>boundary_linewidth=2.0</code>: the width of the boundary lines.</li><li><code>boundary_color=:black</code>: the color of the boundary lines.</li><li><code>kwargs...</code>: other keyword arguments are passed to the point plotting   function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/analysis.jl#L12-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.wrap_coord_1D-Tuple{Any, Any}" href="#Molly.wrap_coord_1D-Tuple{Any, Any}"><code>Molly.wrap_coord_1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wrap_coord_1D(c, side_length)</code></pre><p>Ensure a 1D coordinate is within the bounding box and return the coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L387-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Molly.wrap_coords-Tuple{Any, Union{CubicBoundary, RectangularBoundary}}" href="#Molly.wrap_coords-Tuple{Any, Union{CubicBoundary, RectangularBoundary}}"><code>Molly.wrap_coords</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wrap_coords(c, boundary)</code></pre><p>Ensure a coordinate is within the bounding box and return the coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/726388093a4633dc46892fa878f0fcfb3930cf05/src/spatial.jl#L400-L404">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../development/">« Development</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 29 June 2023 13:58">Thursday 29 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
