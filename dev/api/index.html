<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API ¬∑ Molly.jl</title><meta name="title" content="API ¬∑ Molly.jl"/><meta property="og:title" content="API ¬∑ Molly.jl"/><meta property="twitter:title" content="API ¬∑ Molly.jl"/><meta name="description" content="Documentation for Molly.jl."/><meta property="og:description" content="Documentation for Molly.jl."/><meta property="twitter:description" content="Documentation for Molly.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Molly.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Molly.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../documentation/">Documentation</a></li><li><a class="tocitem" href="../differentiable/">Differentiable simulation</a></li><li><a class="tocitem" href="../free_energy/">Free energy</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../exercises/">Exercises</a></li><li><a class="tocitem" href="../publications/">Publications</a></li><li><a class="tocitem" href="../related/">Related software</a></li><li><a class="tocitem" href="../developer/">Developer documentation</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Exported-names"><span>Exported names</span></a></li><li><a class="tocitem" href="#Docstrings"><span>Docstrings</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/Molly.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/Molly.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Molly-API"><a class="docs-heading-anchor" href="#Molly-API">Molly API</a><a id="Molly-API-1"></a><a class="docs-heading-anchor-permalink" href="#Molly-API" title="Permalink"></a></h1><p>The API reference can be found here.</p><p>Molly re-exports <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a> and <a href="https://github.com/PainterQubits/Unitful.jl">Unitful.jl</a>, making the likes of <code>SVector</code> and <code>1.0u&quot;nm&quot;</code> available when you call <code>using Molly</code>.</p><p>Package extensions are used in order to reduce the number of dependencies:</p><ul><li>To use <a href="#Molly.visualize"><code>visualize</code></a>, call <code>using GLMakie</code>.</li><li>To use <a href="#Molly.ASECalculator"><code>ASECalculator</code></a>, call <code>using PythonCall</code>.</li><li>To use <a href="#Molly.rdf"><code>rdf</code></a>, call <code>using KernelDensity</code>.</li></ul><h2 id="Exported-names"><a class="docs-heading-anchor" href="#Exported-names">Exported names</a><a id="Exported-names-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-names" title="Permalink"></a></h2><ul><li><a href="#Molly.ASECalculator"><code>Molly.ASECalculator</code></a></li><li><a href="#Molly.AndersenThermostat"><code>Molly.AndersenThermostat</code></a></li><li><a href="#Molly.AngleConstraint"><code>Molly.AngleConstraint</code></a></li><li><a href="#Molly.AshbaughHatch"><code>Molly.AshbaughHatch</code></a></li><li><a href="#Molly.Atom"><code>Molly.Atom</code></a></li><li><a href="#Molly.AtomData"><code>Molly.AtomData</code></a></li><li><a href="#Molly.AverageObservableLogger"><code>Molly.AverageObservableLogger</code></a></li><li><a href="#Molly.BerendsenBarostat"><code>Molly.BerendsenBarostat</code></a></li><li><a href="#Molly.BerendsenThermostat"><code>Molly.BerendsenThermostat</code></a></li><li><a href="#Molly.BiasPotential"><code>Molly.BiasPotential</code></a></li><li><a href="#Molly.Buckingham"><code>Molly.Buckingham</code></a></li><li><a href="#Molly.CRescaleBarostat"><code>Molly.CRescaleBarostat</code></a></li><li><a href="#Molly.CalcCMDist"><code>Molly.CalcCMDist</code></a></li><li><a href="#Molly.CalcDist"><code>Molly.CalcDist</code></a></li><li><a href="#Molly.CalcMaxDist"><code>Molly.CalcMaxDist</code></a></li><li><a href="#Molly.CalcMinDist"><code>Molly.CalcMinDist</code></a></li><li><a href="#Molly.CalcRMSD"><code>Molly.CalcRMSD</code></a></li><li><a href="#Molly.CalcRg"><code>Molly.CalcRg</code></a></li><li><a href="#Molly.CalcSingleDist"><code>Molly.CalcSingleDist</code></a></li><li><a href="#Molly.CellListMapNeighborFinder"><code>Molly.CellListMapNeighborFinder</code></a></li><li><a href="#Molly.CosineAngle"><code>Molly.CosineAngle</code></a></li><li><a href="#Molly.Coulomb"><code>Molly.Coulomb</code></a></li><li><a href="#Molly.CoulombEwald"><code>Molly.CoulombEwald</code></a></li><li><a href="#Molly.CoulombReactionField"><code>Molly.CoulombReactionField</code></a></li><li><a href="#Molly.CoulombSoftCoreBeutler"><code>Molly.CoulombSoftCoreBeutler</code></a></li><li><a href="#Molly.CoulombSoftCoreGapsys"><code>Molly.CoulombSoftCoreGapsys</code></a></li><li><a href="#Molly.CubicBoundary"><code>Molly.CubicBoundary</code></a></li><li><a href="#Molly.CubicSplineCutoff"><code>Molly.CubicSplineCutoff</code></a></li><li><a href="#Molly.DisplacementsLogger"><code>Molly.DisplacementsLogger</code></a></li><li><a href="#Molly.DistanceConstraint"><code>Molly.DistanceConstraint</code></a></li><li><a href="#Molly.DistanceCutoff"><code>Molly.DistanceCutoff</code></a></li><li><a href="#Molly.DistanceNeighborFinder"><code>Molly.DistanceNeighborFinder</code></a></li><li><a href="#Molly.EnsembleSystem"><code>Molly.EnsembleSystem</code></a></li><li><a href="#Molly.Ewald"><code>Molly.Ewald</code></a></li><li><a href="#Molly.FENEBond"><code>Molly.FENEBond</code></a></li><li><a href="#Molly.FlatBottomSquareBias"><code>Molly.FlatBottomSquareBias</code></a></li><li><a href="#Molly.GPUNeighborFinder"><code>Molly.GPUNeighborFinder</code></a></li><li><a href="#Molly.GeneralObservableLogger"><code>Molly.GeneralObservableLogger</code></a></li><li><a href="#Molly.Gravity"><code>Molly.Gravity</code></a></li><li><a href="#Molly.HamiltonianREMD"><code>Molly.HamiltonianREMD</code></a></li><li><a href="#Molly.HarmonicAngle"><code>Molly.HarmonicAngle</code></a></li><li><a href="#Molly.HarmonicBond"><code>Molly.HarmonicBond</code></a></li><li><a href="#Molly.HarmonicPositionRestraint"><code>Molly.HarmonicPositionRestraint</code></a></li><li><a href="#Molly.ImmediateThermostat"><code>Molly.ImmediateThermostat</code></a></li><li><a href="#Molly.ImplicitSolventGBN2"><code>Molly.ImplicitSolventGBN2</code></a></li><li><a href="#Molly.ImplicitSolventOBC"><code>Molly.ImplicitSolventOBC</code></a></li><li><a href="#Molly.InteractionList1Atoms"><code>Molly.InteractionList1Atoms</code></a></li><li><a href="#Molly.InteractionList2Atoms"><code>Molly.InteractionList2Atoms</code></a></li><li><a href="#Molly.InteractionList3Atoms"><code>Molly.InteractionList3Atoms</code></a></li><li><a href="#Molly.InteractionList4Atoms"><code>Molly.InteractionList4Atoms</code></a></li><li><a href="#Molly.Langevin"><code>Molly.Langevin</code></a></li><li><a href="#Molly.LangevinSplitting"><code>Molly.LangevinSplitting</code></a></li><li><a href="#Molly.LennardJones"><code>Molly.LennardJones</code></a></li><li><a href="#Molly.LennardJonesSoftCoreBeutler"><code>Molly.LennardJonesSoftCoreBeutler</code></a></li><li><a href="#Molly.LennardJonesSoftCoreGapsys"><code>Molly.LennardJonesSoftCoreGapsys</code></a></li><li><a href="#Molly.LinearBias"><code>Molly.LinearBias</code></a></li><li><a href="#Molly.MetropolisMonteCarlo"><code>Molly.MetropolisMonteCarlo</code></a></li><li><a href="#Molly.Mie"><code>Molly.Mie</code></a></li><li><a href="#Molly.MolecularForceField"><code>Molly.MolecularForceField</code></a></li><li><a href="#Molly.MolecularTopology"><code>Molly.MolecularTopology</code></a></li><li><a href="#Molly.MollyCalculator"><code>Molly.MollyCalculator</code></a></li><li><a href="#Molly.MonteCarloBarostat"><code>Molly.MonteCarloBarostat</code></a></li><li><a href="#Molly.MonteCarloLogger"><code>Molly.MonteCarloLogger</code></a></li><li><a href="#Molly.MorseBond"><code>Molly.MorseBond</code></a></li><li><a href="#Molly.MullerBrown"><code>Molly.MullerBrown</code></a></li><li><a href="#Molly.NeighborList"><code>Molly.NeighborList</code></a></li><li><a href="#Molly.NoCoupling"><code>Molly.NoCoupling</code></a></li><li><a href="#Molly.NoCutoff"><code>Molly.NoCutoff</code></a></li><li><a href="#Molly.NoNeighborFinder"><code>Molly.NoNeighborFinder</code></a></li><li><a href="#Molly.NoseHoover"><code>Molly.NoseHoover</code></a></li><li><a href="#Molly.OverdampedLangevin"><code>Molly.OverdampedLangevin</code></a></li><li><a href="#Molly.PME"><code>Molly.PME</code></a></li><li><a href="#Molly.PairwiseInteraction"><code>Molly.PairwiseInteraction</code></a></li><li><a href="#Molly.PeriodicTorsion"><code>Molly.PeriodicTorsion</code></a></li><li><a href="#Molly.RBTorsion"><code>Molly.RBTorsion</code></a></li><li><a href="#Molly.RectangularBoundary"><code>Molly.RectangularBoundary</code></a></li><li><a href="#Molly.ReplicaExchangeLogger"><code>Molly.ReplicaExchangeLogger</code></a></li><li><a href="#Molly.ReplicaSystem"><code>Molly.ReplicaSystem</code></a></li><li><a href="#Molly.SHAKE_RATTLE"><code>Molly.SHAKE_RATTLE</code></a></li><li><a href="#Molly.ShiftedForceCutoff"><code>Molly.ShiftedForceCutoff</code></a></li><li><a href="#Molly.ShiftedPotentialCutoff"><code>Molly.ShiftedPotentialCutoff</code></a></li><li><a href="#Molly.SoftSphere"><code>Molly.SoftSphere</code></a></li><li><a href="#Molly.SpecificForce1Atoms"><code>Molly.SpecificForce1Atoms</code></a></li><li><a href="#Molly.SpecificForce2Atoms"><code>Molly.SpecificForce2Atoms</code></a></li><li><a href="#Molly.SpecificForce3Atoms"><code>Molly.SpecificForce3Atoms</code></a></li><li><a href="#Molly.SpecificForce4Atoms"><code>Molly.SpecificForce4Atoms</code></a></li><li><a href="#Molly.SquareBias"><code>Molly.SquareBias</code></a></li><li><a href="#Molly.SteepestDescentMinimizer"><code>Molly.SteepestDescentMinimizer</code></a></li><li><a href="#Molly.StormerVerlet"><code>Molly.StormerVerlet</code></a></li><li><a href="#Molly.System-Union{Tuple{AtomsBase.AbstractSystem{D}}, Tuple{D}} where D"><code>Molly.System</code></a></li><li><a href="#Molly.System-Union{Tuple{SimpleCrystals.Crystal{D, A, B} where {A, B&lt;:(AbstractVector{&lt;:SimpleCrystals.Atom{D}})}}, Tuple{D}} where D"><code>Molly.System</code></a></li><li><a href="#Molly.System-Union{Tuple{AT}, Tuple{AbstractString, MolecularForceField}} where AT&lt;:AbstractArray"><code>Molly.System</code></a></li><li><a href="#Molly.System-Tuple{System}"><code>Molly.System</code></a></li><li><a href="#Molly.System"><code>Molly.System</code></a></li><li><a href="#Molly.TemperatureREMD"><code>Molly.TemperatureREMD</code></a></li><li><a href="#Molly.ThermoState"><code>Molly.ThermoState</code></a></li><li><a href="#Molly.TimeCorrelationLogger"><code>Molly.TimeCorrelationLogger</code></a></li><li><a href="#Molly.TrajectoryWriter"><code>Molly.TrajectoryWriter</code></a></li><li><a href="#Molly.TreeNeighborFinder"><code>Molly.TreeNeighborFinder</code></a></li><li><a href="#Molly.TriclinicBoundary"><code>Molly.TriclinicBoundary</code></a></li><li><a href="#Molly.UreyBradley"><code>Molly.UreyBradley</code></a></li><li><a href="#Molly.VelocityRescaleThermostat"><code>Molly.VelocityRescaleThermostat</code></a></li><li><a href="#Molly.VelocityVerlet"><code>Molly.VelocityVerlet</code></a></li><li><a href="#Molly.Verlet"><code>Molly.Verlet</code></a></li><li><a href="#Molly.Yukawa"><code>Molly.Yukawa</code></a></li><li><a href="#Base.values-Tuple{GeneralObservableLogger}"><code>Base.values</code></a></li><li><a href="#Molly.AutoCorrelationLogger-Tuple{Any, Any, Integer, Integer}"><code>Molly.AutoCorrelationLogger</code></a></li><li><a href="#Molly.CoordinatesLogger-Tuple{Any, Integer}"><code>Molly.CoordinatesLogger</code></a></li><li><a href="#Molly.DensityLogger-Tuple{Type, Integer}"><code>Molly.DensityLogger</code></a></li><li><a href="#Molly.ForcesLogger-Tuple{Any, Integer}"><code>Molly.ForcesLogger</code></a></li><li><a href="#Molly.KineticEnergyLogger-Tuple{Type, Integer}"><code>Molly.KineticEnergyLogger</code></a></li><li><a href="#Molly.OneParticleSite"><code>Molly.OneParticleSite</code></a></li><li><a href="#Molly.OutOfPlaneSite-Union{Tuple{T}, Tuple{Integer, Integer, Integer, Integer, T, T, Any}} where T"><code>Molly.OutOfPlaneSite</code></a></li><li><a href="#Molly.PotentialEnergyLogger-Tuple{Type, Integer}"><code>Molly.PotentialEnergyLogger</code></a></li><li><a href="#Molly.PressureLogger-Tuple{Type, Integer}"><code>Molly.PressureLogger</code></a></li><li><a href="#Molly.ScalarPressureLogger-Tuple{Type, Integer}"><code>Molly.ScalarPressureLogger</code></a></li><li><a href="#Molly.ScalarVirialLogger-Tuple{Type, Integer}"><code>Molly.ScalarVirialLogger</code></a></li><li><a href="#Molly.TemperatureLogger-Tuple{DataType, Integer}"><code>Molly.TemperatureLogger</code></a></li><li><a href="#Molly.ThreeParticleAverageSite-Union{Tuple{T}, Tuple{Integer, Integer, Integer, Integer, T, T, T}, Tuple{Integer, Integer, Integer, Integer, T, T, T, Any}} where T"><code>Molly.ThreeParticleAverageSite</code></a></li><li><a href="#Molly.TotalEnergyLogger-Tuple{DataType, Any}"><code>Molly.TotalEnergyLogger</code></a></li><li><a href="#Molly.TwoParticleAverageSite-Union{Tuple{T}, Tuple{Integer, Integer, Integer, T, T}, Tuple{Integer, Integer, Integer, T, T, Any}} where T"><code>Molly.TwoParticleAverageSite</code></a></li><li><a href="#Molly.VelocitiesLogger-Tuple{Any, Integer}"><code>Molly.VelocitiesLogger</code></a></li><li><a href="#Molly.VirialLogger-Tuple{Type, Integer}"><code>Molly.VirialLogger</code></a></li><li><a href="#Molly.VolumeLogger-Tuple{Type, Integer}"><code>Molly.VolumeLogger</code></a></li><li><a href="#Molly.accelerations-Tuple{Any}"><code>Molly.accelerations</code></a></li><li><a href="#Molly.add_position_restraints-Union{Tuple{AT}, Tuple{System{&lt;:Any, AT}, Any}} where AT"><code>Molly.add_position_restraints</code></a></li><li><a href="#Molly.apply_coupling!-Tuple{Any, Any, Union{Tuple, NamedTuple}, Any, Any, Any}"><code>Molly.apply_coupling!</code></a></li><li><a href="#Molly.apply_loggers!"><code>Molly.apply_loggers!</code></a></li><li><a href="#Molly.apply_position_constraints!-Tuple{Any, Any}"><code>Molly.apply_position_constraints!</code></a></li><li><a href="#Molly.apply_velocity_constraints!-Tuple{Any}"><code>Molly.apply_velocity_constraints!</code></a></li><li><a href="#Molly.array_type-Tuple{AT} where AT"><code>Molly.array_type</code></a></li><li><a href="#Molly.assemble_mbar_inputs-Tuple{Any, Any, Vector{ThermoState}}"><code>Molly.assemble_mbar_inputs</code></a></li><li><a href="#Molly.bond_angle-NTuple{4, Any}"><code>Molly.bond_angle</code></a></li><li><a href="#Molly.box_center-Tuple{Union{CubicBoundary, RectangularBoundary}}"><code>Molly.box_center</code></a></li><li><a href="#Molly.calculate_cv-Tuple{CalcDist, Any, Any, Any, Vararg{Any}}"><code>Molly.calculate_cv</code></a></li><li><a href="#Molly.charge-Tuple{Any}"><code>Molly.charge</code></a></li><li><a href="#Molly.charges-Tuple{Union{ReplicaSystem, System}}"><code>Molly.charges</code></a></li><li><a href="#Molly.check_constraints-Tuple{Any}"><code>Molly.check_constraints</code></a></li><li><a href="#Molly.check_position_constraints-Tuple{Any}"><code>Molly.check_position_constraints</code></a></li><li><a href="#Molly.check_velocity_constraints-Tuple{Any}"><code>Molly.check_velocity_constraints</code></a></li><li><a href="#Molly.density-Tuple{Any}"><code>Molly.density</code></a></li><li><a href="#Molly.dipole_moment-Tuple{Any}"><code>Molly.dipole_moment</code></a></li><li><a href="#Molly.displacements-Tuple{Any, Any}"><code>Molly.displacements</code></a></li><li><a href="#Molly.distances-Tuple{Any, Any}"><code>Molly.distances</code></a></li><li><a href="#Molly.find_neighbors-Tuple{System}"><code>Molly.find_neighbors</code></a></li><li><a href="#Molly.float_type-Union{Tuple{Union{ReplicaSystem{&lt;:Any, &lt;:Any, T}, System{&lt;:Any, &lt;:Any, T}}}, Tuple{T}} where T"><code>Molly.float_type</code></a></li><li><a href="#Molly.force"><code>Molly.force</code></a></li><li><a href="#Molly.forces-Tuple{Any}"><code>Molly.forces</code></a></li><li><a href="#Molly.forces_virial-Tuple{Any}"><code>Molly.forces_virial</code></a></li><li><a href="#Molly.hydrodynamic_radius-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{SVector{D, T}}, Any}} where {D, T}"><code>Molly.hydrodynamic_radius</code></a></li><li><a href="#Molly.is_any_atom-Tuple{Any, Any}"><code>Molly.is_any_atom</code></a></li><li><a href="#Molly.is_heavy_atom-Tuple{Any, Any}"><code>Molly.is_heavy_atom</code></a></li><li><a href="#Molly.is_on_gpu-Union{Tuple{Union{ReplicaSystem{&lt;:Any, AT}, System{&lt;:Any, AT}, AT}}, Tuple{AT}} where AT"><code>Molly.is_on_gpu</code></a></li><li><a href="#Molly.iterate_mbar-Tuple{Any, Any, Any}"><code>Molly.iterate_mbar</code></a></li><li><a href="#Molly.kinetic_energy-Tuple{Any}"><code>Molly.kinetic_energy</code></a></li><li><a href="#Molly.kinetic_energy_tensor-Union{Tuple{System{D}}, Tuple{D}} where D"><code>Molly.kinetic_energy_tensor</code></a></li><li><a href="#Molly.log_property!"><code>Molly.log_property!</code></a></li><li><a href="#Molly.mass-Tuple{Any}"><code>Molly.mass</code></a></li><li><a href="#Molly.masses-Tuple{System}"><code>Molly.masses</code></a></li><li><a href="#Molly.maxwell_boltzmann"><code>Molly.maxwell_boltzmann</code></a></li><li><a href="#Molly.mbar_weights-Tuple{AbstractMatrix, Vararg{AbstractVector, 4}}"><code>Molly.mbar_weights</code></a></li><li><a href="#Molly.mbar_weights-Tuple{Molly.MBARInput}"><code>Molly.mbar_weights</code></a></li><li><a href="#Molly.pairwise_force"><code>Molly.pairwise_force</code></a></li><li><a href="#Molly.pairwise_pe"><code>Molly.pairwise_pe</code></a></li><li><a href="#Molly.place_atoms-Tuple{Integer, Any}"><code>Molly.place_atoms</code></a></li><li><a href="#Molly.place_diatomics-Tuple{Integer, Any, Any}"><code>Molly.place_diatomics</code></a></li><li><a href="#Molly.place_virtual_sites!"><code>Molly.place_virtual_sites!</code></a></li><li><a href="#Molly.pmf_with_uncertainty-Tuple{AbstractVector, AbstractVector, Vector{ThermoState}, ThermoState, AbstractVector}"><code>Molly.pmf_with_uncertainty</code></a></li><li><a href="#Molly.pmf_with_uncertainty-Tuple{AbstractMatrix, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Vector}"><code>Molly.pmf_with_uncertainty</code></a></li><li><a href="#Molly.potential_energy-Tuple{Any}"><code>Molly.potential_energy</code></a></li><li><a href="#Molly.pressure-Tuple{Any}"><code>Molly.pressure</code></a></li><li><a href="#Molly.radius_gyration-Tuple{Any, Any}"><code>Molly.radius_gyration</code></a></li><li><a href="#Molly.random_coord-Union{Tuple{CubicBoundary{3, T}}, Tuple{T}} where T"><code>Molly.random_coord</code></a></li><li><a href="#Molly.random_normal_translation!-Union{Tuple{System{D, &lt;:Any, T}}, Tuple{T}, Tuple{D}} where {D, T}"><code>Molly.random_normal_translation!</code></a></li><li><a href="#Molly.random_uniform_translation!-Union{Tuple{System{D, &lt;:Any, T}}, Tuple{T}, Tuple{D}} where {D, T}"><code>Molly.random_uniform_translation!</code></a></li><li><a href="#Molly.random_velocities-Union{Tuple{AT}, Tuple{System{3, AT}, Any}} where AT"><code>Molly.random_velocities</code></a></li><li><a href="#Molly.random_velocities!-Tuple{Any, Any}"><code>Molly.random_velocities!</code></a></li><li><a href="#Molly.random_velocity-Tuple{Union{Level{L, S, Quantity{T, ùêå, U}} where {T, U, L, S}, Level{L, S, Quantity{T, ùêå ùêç^-1, U}} where {T, U, L, S}, Quantity{T, ùêå} where T, Quantity{T, ùêå ùêç^-1} where T}, Union{Quantity{T, ùöØ, U}, Level{L, S, Quantity{T, ùöØ, U}} where {L, S}} where {T, U}}"><code>Molly.random_velocity</code></a></li><li><a href="#Molly.rdf"><code>Molly.rdf</code></a></li><li><a href="#Molly.read_frame!-Union{Tuple{T}, Tuple{AT}, Tuple{D}, Tuple{EnsembleSystem{&lt;:System{D, AT, T}}, Integer}} where {D, AT, T}"><code>Molly.read_frame!</code></a></li><li><a href="#Molly.remd_exchange!-Tuple{ReplicaSystem, TemperatureREMD, Integer, Integer}"><code>Molly.remd_exchange!</code></a></li><li><a href="#Molly.remove_CM_motion!-Tuple{Any}"><code>Molly.remove_CM_motion!</code></a></li><li><a href="#Molly.rmsd-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{SVector{D, T}}, AbstractArray{SVector{D, T}}}} where {D, T}"><code>Molly.rmsd</code></a></li><li><a href="#Molly.scalar_pressure-Tuple{Any}"><code>Molly.scalar_pressure</code></a></li><li><a href="#Molly.scalar_virial-Tuple{Any}"><code>Molly.scalar_virial</code></a></li><li><a href="#Molly.scale_boundary-Tuple{CubicBoundary, Any}"><code>Molly.scale_boundary</code></a></li><li><a href="#Molly.scale_coords!-Union{Tuple{D}, Tuple{AT}, Tuple{System{&lt;:Any, AT}, SMatrix{D, D}}} where {AT, D}"><code>Molly.scale_coords!</code></a></li><li><a href="#Molly.simulate!-Tuple{Any, SteepestDescentMinimizer}"><code>Molly.simulate!</code></a></li><li><a href="#Molly.simulate_remd!-Tuple{ReplicaSystem, Any, Integer}"><code>Molly.simulate_remd!</code></a></li><li><a href="#Molly.statistical_inefficiency-Tuple{AbstractVector}"><code>Molly.statistical_inefficiency</code></a></li><li><a href="#Molly.temperature-Union{Tuple{System{D}}, Tuple{D}} where D"><code>Molly.temperature</code></a></li><li><a href="#Molly.torsion_angle-NTuple{5, Any}"><code>Molly.torsion_angle</code></a></li><li><a href="#Molly.total_energy-Tuple{Any}"><code>Molly.total_energy</code></a></li><li><a href="#Molly.use_neighbors-Tuple{Any}"><code>Molly.use_neighbors</code></a></li><li><a href="#Molly.ustrip_vec-Tuple"><code>Molly.ustrip_vec</code></a></li><li><a href="#Molly.vector-Tuple{Any, Any, CubicBoundary}"><code>Molly.vector</code></a></li><li><a href="#Molly.vector_1D-Tuple{Any, Any, Any}"><code>Molly.vector_1D</code></a></li><li><a href="#Molly.virial-Tuple{Any}"><code>Molly.virial</code></a></li><li><a href="#Molly.visualize"><code>Molly.visualize</code></a></li><li><a href="#Molly.volume-Tuple{Any}"><code>Molly.volume</code></a></li><li><a href="#Molly.wrap_coord_1D-Tuple{Any, Any}"><code>Molly.wrap_coord_1D</code></a></li><li><a href="#Molly.wrap_coords-Tuple{Any, Union{CubicBoundary, RectangularBoundary}}"><code>Molly.wrap_coords</code></a></li><li><a href="#Molly.write_structure-Tuple{Any, Any}"><code>Molly.write_structure</code></a></li></ul><h2 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Molly.ASECalculator"><a class="docstring-binding" href="#Molly.ASECalculator"><code>Molly.ASECalculator</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ASECalculator(; &lt;keyword arguments&gt;)</code></pre><p>A Python <a href="https://wiki.fysik.dtu.dk/ase">ASE</a> calculator.</p><p>This calculator is only available when PythonCall is imported. It is the user&#39;s responsibility to have the required Python packages installed. This includes ASE and any packages providing the calculator.</p><p>Contrary to the rest of Molly, unitless quantities are assumed to have ASE units: ‚Ñ´ for length, eV for energy, u for mass, and √Ö sqrt(u/eV) for time. Unitful quantities will be converted as appropriate.</p><p>Not currently compatible with <a href="#Molly.TriclinicBoundary"><code>TriclinicBoundary</code></a>. Not currently compatible with virial calculation.</p><p><strong>Arguments</strong></p><ul><li><code>ase_calc</code>: the ASE calculator created with PythonCall.</li><li><code>atoms</code>: the atoms, or atom equivalents, in the system.</li><li><code>coords</code>: the coordinates of the atoms in the system. Typically a   vector of <code>SVector</code>s of 2 or 3 dimensions.</li><li><code>boundary</code>: the bounding box in which the simulation takes place.</li><li><code>elements=nothing</code>: vector of atom elements as a string, either <code>elements</code> or   <code>atoms_data</code> (which contains element data) must be provided.</li><li><code>atoms_data=nothing</code>: other data associated with the atoms.</li><li><code>velocities=nothing</code>: the velocities of the atoms in the system, only required   if the velocities contribute to the potential energy or forces.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L1568-L1595">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.AndersenThermostat"><a class="docstring-binding" href="#Molly.AndersenThermostat"><code>Molly.AndersenThermostat</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AndersenThermostat(temperature, coupling_const)</code></pre><p>The Andersen thermostat for controlling temperature.</p><p>The velocity of each atom is randomly changed each time step with probability <code>dt / coupling_const</code> to a velocity drawn from the Maxwell-Boltzmann distribution. See <a href="https://doi.org/10.1063/1.439486">Andersen 1980</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/coupling.jl#L152-L160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.AngleConstraint"><a class="docstring-binding" href="#Molly.AngleConstraint"><code>Molly.AngleConstraint</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AngleConstraint(i, j, k, angle_ijk, dist_ij, dist_jk)</code></pre><p>Constraint between three atoms that maintains a fixed angle and two bond lengths.</p><p>Atoms <code>i</code> and <code>k</code> should be connected to central atom <code>j</code> with fixed bond distances given by <code>dist_ij</code> and <code>dist_jk</code>, forming the angle <code>angle_ijk</code> in radians. Internally, an <code>AngleConstraint</code> is converted into 3 distance constraints. None of the atoms in this constraint should be constrained with atoms not part of this constraint.</p><p>For example, a water molecule can be defined as <code>AngleConstraint(1, 2, 3, deg2rad(104.5), 0.9572u&quot;√Ö&quot;, 0.9572u&quot;√Ö&quot;)</code> where atom 2 is oxygen and atoms 1/3 are hydrogen.</p><p>Linear molecules like CO2 can not be constrained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/constraints/constraints.jl#L21-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.AshbaughHatch"><a class="docstring-binding" href="#Molly.AshbaughHatch"><code>Molly.AshbaughHatch</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AshbaughHatch(; cutoff, use_neighbors, shortcut, œµ_mixing, œÉ_mixing,
              Œª_mixing, weight_special)</code></pre><p>The Ashbaugh-Hatch potential (<span>$V_{\text{AH}}$</span>) is a modified Lennard-Jones (<span>$V_{\text{LJ}}$</span>) 6-12 interaction between two atoms.</p><p>The potential energy is defined as</p><p class="math-container">\[V_{\text{LJ}}(r_{ij}) = 4\varepsilon_{ij} \left[\left(\frac{\sigma_{ij}}{r_{ij}}\right)^{12} - \left(\frac{\sigma_{ij}}{r_{ij}}\right)^{6}\right] \\\]</p><p class="math-container">\[V_{\text{AH}}(r_{ij}) =
    \begin{cases}
      V_{\text{LJ}}(r_{ij}) +\varepsilon_{ij}(1-Œª_{ij}) &amp;,  r_{ij}\leq  2^{1/6}œÉ  \\
       Œª_{ij}V_{\text{LJ}}(r_{ij})  &amp;,  2^{1/6}œÉ \leq r_{ij}
    \end{cases}\]</p><p>and the force on each atom by</p><p class="math-container">\[\vec{F}_{\text{AH}} =
    \begin{cases}
      F_{\text{LJ}}(r_{ij})  &amp;,  r_{ij} \leq  2^{1/6}œÉ  \\
       Œª_{ij}F_{\text{LJ}}(r_{ij})  &amp;,  2^{1/6}œÉ \leq r_{ij}
    \end{cases}\]</p><p>where</p><p class="math-container">\[\begin{aligned}
\vec{F}_{\text{LJ}}\
&amp;= \frac{24\varepsilon_{ij}}{r_{ij}^2} \left[2\left(\frac{\sigma_{ij}}{r_{ij}}\right)^{12} -\left(\frac{\sigma_{ij}}{r_{ij}}\right)^{6}\right]  \vec{r_{ij}}
\end{aligned}\]</p><p>If <span>$\lambda$</span> is one this gives the standard <a href="#Molly.LennardJones"><code>LennardJones</code></a> potential.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/lennard_jones.jl#L437-L472">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.Atom"><a class="docstring-binding" href="#Molly.Atom"><code>Molly.Atom</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Atom(; &lt;keyword arguments&gt;)</code></pre><p>An atom and its associated information.</p><p>Properties unused in the simulation or in analysis can be left with their default values. The types used should be bits types if the GPU is going to be used.</p><p><strong>Arguments</strong></p><ul><li><code>index::Int=1</code>: the index of the atom in the system. This only needs to be set if   it is used in the interactions. The order of atoms is determined by their order   in the atom vector.</li><li><code>atom_type::T=1</code>: the type of the atom. This only needs to be set if   it is used in the interactions.</li><li><code>mass::M=1.0u&quot;g/mol&quot;</code>: the mass of the atom.</li><li><code>charge::C=0.0</code>: the charge of the atom, used for electrostatic interactions.</li><li><code>œÉ::S=0.0u&quot;nm&quot;</code>: the Lennard-Jones finite distance at which the inter-particle   potential is zero.</li><li><code>œµ::E=0.0u&quot;kJ * mol^-1&quot;</code>: the Lennard-Jones depth of the potential well.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L229-L249">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.AtomData"><a class="docstring-binding" href="#Molly.AtomData"><code>Molly.AtomData</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AtomData(; atom_type=&quot;?&quot;, atom_name=&quot;?&quot;, res_number=1, res_name=&quot;???&quot;,
         chain_id=&quot;A&quot;, element=&quot;?&quot;, hetero_atom=false)</code></pre><p>Data associated with an atom.</p><p>Storing this separately allows the <a href="#Molly.Atom"><code>Atom</code></a> types to be bits types and hence work on the GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L342-L350">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.AverageObservableLogger"><a class="docstring-binding" href="#Molly.AverageObservableLogger"><code>Molly.AverageObservableLogger</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AverageObservableLogger(observable::Function, T::DataType, n_steps::Integer;
                        n_blocks::Integer=1024)</code></pre><p>A logger that periodically records observations of a system and keeps a running empirical average.</p><p>While <a href="#Molly.GeneralObservableLogger"><code>GeneralObservableLogger</code></a> holds a full record of observations, <a href="#Molly.AverageObservableLogger"><code>AverageObservableLogger</code></a> does not. In addition, calling <code>values(logger::AverageObservableLogger; std::Bool=true)</code> returns two values: the current running average, and an estimate of the standard deviation for this average based on the block averaging method described in <a href="https://doi.org/10.1063/1.457480">Flyvbjerg and Petersen 1989</a>.</p><p><strong>Arguments</strong></p><ul><li><code>observable::Function</code>: the observable whose mean is recorded, must support   the method <code>observable(s::System, neighbors; n_threads::Integer)</code>.</li><li><code>T::DataType</code>: the type returned by <code>observable</code>.</li><li><code>n_steps::Integer</code>: number of simulation steps between observations.</li><li><code>n_blocks::Integer=1024</code>: the number of blocks used in the block averaging   method, should be an even number.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L907-L928">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.BerendsenBarostat"><a class="docstring-binding" href="#Molly.BerendsenBarostat"><code>Molly.BerendsenBarostat</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BerendsenBarostat(pressure, coupling_const;
                  coupling_type=:isotropic,
                  compressibility=4.6e-5u&quot;bar^-1&quot;,
                  max_scale_frac=0.1, n_steps=1)</code></pre><p>The Berendsen barostat for controlling pressure.</p><p>The scaling factor for the box every <code>n_steps</code> steps is</p><p class="math-container">\[\mu_{ij} = \delta_{ij} - \frac{\Delta t}{3\, \tau_p} \kappa_{ij} \left(P_{0ij} - P_{ij}(t) \right).\]</p><p>with the fractional change limited to <code>max_scale_frac</code>.</p><p>The scaling factor <span>$\mu$</span> is a matrix and <span>$\delta$</span> is a Kronecker delta, allowing non-isotropic pressure control. Available options are <code>:isotropic</code>, <code>:semiisotropic</code> and <code>:anisotropic</code>.</p><p>This barostat should be used with caution as it known not to properly sample isobaric ensembles and therefore can lead to simulation artifacts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/coupling.jl#L220-L240">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.BerendsenThermostat"><a class="docstring-binding" href="#Molly.BerendsenThermostat"><code>Molly.BerendsenThermostat</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BerendsenThermostat(temperature, coupling_const)</code></pre><p>The Berendsen thermostat for controlling temperature.</p><p>The scaling factor for the velocities each step is</p><p class="math-container">\[\lambda^2 = 1 + \frac{\delta t}{\tau} \left( \frac{T_0}{T} - 1 \right)\]</p><p>This thermostat should be used with caution as it can lead to simulation artifacts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/coupling.jl#L194-L206">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.BiasPotential"><a class="docstring-binding" href="#Molly.BiasPotential"><code>Molly.BiasPotential</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BiasPotential(cv_type, bias_type)</code></pre><p>A potential to bias a simulation along a collective variable (CV), implemented as an AtomsCalculators.jl calculator.</p><p>The <code>cv_type</code> could for example be <a href="#Molly.CalcDist"><code>CalcDist</code></a> and the <code>bias_type</code> could be <a href="#Molly.LinearBias"><code>LinearBias</code></a>.</p><p>Forces resulting from the bias potential are evaluated in two steps, specfically by (1) calculating the gradient of the bias potential with respect to the value of the CV, and (2) calculating the gradient of the CV with respect to the atomic coordinates.</p><p>Gradients can be calculated with either automatic differentiation or explicitly defined gradient functions. Enzyme should be imported in the first case.</p><p>Not currently compatible with virial calculation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/bias/bias.jl#L97-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.Buckingham"><a class="docstring-binding" href="#Molly.Buckingham"><code>Molly.Buckingham</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Buckingham(; cutoff, use_neighbors, shortcut, A_mixing, B_mixing,
           C_mixing, weight_special)</code></pre><p>The Buckingham interaction between two atoms.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = A_{ij} \exp(-B_{ij} r_{ij}) - \frac{C_{ij}}{r_{ij}^6}\]</p><p>and the force on each atom by</p><p class="math-container">\[\vec{F}_i = \left( A_{ij} B_{ij} \exp(-B_{ij} r_{ij}) - 6 \frac{C_{ij}}{r_{ij}^7} \right) \frac{\vec{r}_{ij}}{r_{ij}}\]</p><p>The parameters are derived from the atom parameters according to</p><p class="math-container">\[\begin{aligned}
A_{ij} &amp;= (A_{ii} A_{jj})^{1/2} \\
B_{ij} &amp;= \frac{2}{\frac{1}{B_{ii}} + \frac{1}{B_{jj}}} \\
C_{ij} &amp;= (C_{ii} C_{jj})^{1/2}
\end{aligned}\]</p><p>so atoms that use this interaction should have fields <code>A</code>, <code>B</code> and <code>C</code> available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/buckingham.jl#L24-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CRescaleBarostat"><a class="docstring-binding" href="#Molly.CRescaleBarostat"><code>Molly.CRescaleBarostat</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CRescaleBarostat(pressure, coupling_const;
                 coupling_type=:isotropic,
                 compressibility=4.6e-5u&quot;bar^-1&quot;,
                 max_scale_frac=0.1, n_steps=1)</code></pre><p>The stochastic cell rescale barostat.</p><p>See [Bernetti and Bussi 2020] (https://doi.org/10.1063/5.0020514) and [Del Tatto et al. 2022] (https://doi.org/10.3390/app12031139). In brief, this is an extension of the Berendsen barostat that includes a stochastic term to the scaling matrix. This allows proper sampling of isobaric ensembles.</p><p class="math-container">\[\mu = \rm{exp}\left[ \frac{-\kappa_T \cdot \Delta t}{\tau_P} \cdot (P(t) - P_0) + \sqrt{\frac{2 \cdot k_BT \cdot \kappa_T \cdot dt}{V(t) \cdot \tau_P}} \cdot dW \right]\]</p><p>where <span>$\kappa_T$</span> is the isothermal compressibility, <span>$\tau_P$</span> is the barostat coupling constant and <span>$\rm{dW}$</span> represents a Wiener process.</p><p>The scaling factor <span>$\mu$</span> is a matrix, allowing non-isotropic pressure control. Available options are <code>:isotropic</code>, <code>:semiisotropic</code> and <code>:anisotropic</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/coupling.jl#L439-L462">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CalcCMDist"><a class="docstring-binding" href="#Molly.CalcCMDist"><code>Molly.CalcCMDist</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CalcCMDist(calc_type=:closest)</code></pre><p>Bias the distance between the centers of mass of two groups of atoms.</p><p>Given as an argument to <a href="#Molly.CalcDist"><code>CalcDist</code></a>. By default, distances are calculated between the closest periodic images. Setting <code>calc_type=:raw</code> means that distances are calculated ignoring PBCs.</p><p>Should generally be used with molecule unwrapping since it assumes that the atoms within each group are in the same periodic box. If distances are evaluated using the minimum image convention on an unwrapped system, raw coordinates must be within a distance of 1.5x the box length of each other to ensure correct results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/bias/cv.jl#L97-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CalcDist"><a class="docstring-binding" href="#Molly.CalcDist"><code>Molly.CalcDist</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CalcDist(atom_inds_1, atom_inds_2, dist_type=CalcMinDist(), correction=:pbc)</code></pre><p>Bias the distance between two atoms or groups of atoms.</p><p>Given as an argument to <a href="#Molly.BiasPotential"><code>BiasPotential</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>atom_inds_1</code>: indices of the atom(s) in the first group.</li><li><code>atom_inds_2</code>: indices of the atom(s) in the second group.</li><li><code>dist_type=CalcMinDist()</code>: type of distance to calculate.</li><li><code>correction=:pbc</code>: the correction to be applied to the molecules. <code>:pbc</code> keeps molecules   whole, <code>:wrap</code> wraps all atoms inside the simulation box. If using multiple atoms in   a group, they should generally be in the same molecule and <code>:pbc</code> should be used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/bias/cv.jl#L168-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CalcMaxDist"><a class="docstring-binding" href="#Molly.CalcMaxDist"><code>Molly.CalcMaxDist</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CalcMaxDist(calc_type=:closest)</code></pre><p>Bias the maximum distance between two groups of atoms.</p><p>Given as an argument to <a href="#Molly.CalcDist"><code>CalcDist</code></a>. By default, distances are calculated between the closest periodic images. Setting <code>calc_type=:raw</code> means that distances are calculated ignoring PBCs.</p><p>If distances are evaluated using the minimum image convention on an unwrapped system, raw coordinates must be within a distance of 1.5x the box length of each other to ensure correct results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/bias/cv.jl#L70-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CalcMinDist"><a class="docstring-binding" href="#Molly.CalcMinDist"><code>Molly.CalcMinDist</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CalcMinDist(calc_type=:closest)</code></pre><p>Bias the minimum distance between two groups of atoms.</p><p>Given as an argument to <a href="#Molly.CalcDist"><code>CalcDist</code></a>. By default, distances are calculated between the closest periodic images. Setting <code>calc_type=:raw</code> means that distances are calculated ignoring PBCs.</p><p>If distances are evaluated using the minimum image convention on an unwrapped system, raw coordinates must be within a distance of 1.5x the box length of each other to ensure correct results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/bias/cv.jl#L43-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CalcRMSD"><a class="docstring-binding" href="#Molly.CalcRMSD"><code>Molly.CalcRMSD</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CalcRMSD(ref_coords, atom_inds=[], ref_atom_inds=[], correction=:pbc)</code></pre><p>Bias the root-mean-square deviation (RMSD) between the coordinates of a group of atoms and a set of reference coordinates.</p><p>Given as an argument to <a href="#Molly.BiasPotential"><code>BiasPotential</code></a>. The two sets of coordinates are superimposed using the Kabsch algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>ref_coords</code>: reference coordinates.</li><li><code>atom_inds=[]</code>: indices of the atoms in the group, <code>[]</code> uses all atoms.</li><li><code>ref_atom_inds=[]</code>: indices of the reference coordinates to use, <code>[]</code> uses all coordinates.</li><li><code>correction=:pbc</code>: the correction to be applied to the molecules. <code>:pbc</code> keeps molecules   whole, <code>:wrap</code> wraps all atoms inside the simulation box. Generally atoms in a group   should be in the same molecule and <code>:pbc</code> should be used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/bias/cv.jl#L248-L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CalcRg"><a class="docstring-binding" href="#Molly.CalcRg"><code>Molly.CalcRg</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CalcRg(atom_inds=[], correction=:pbc)</code></pre><p>Bias the radius of gyration of a group of atoms.</p><p>Given as an argument to <a href="#Molly.BiasPotential"><code>BiasPotential</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>atom_inds=[]</code>: indices of the atoms in the group, <code>[]</code> uses all atoms.</li><li><code>correction=:pbc</code>: the correction to be applied to the molecules. <code>:pbc</code> keeps molecules   whole, <code>:wrap</code> wraps all atoms inside the simulation box. Generally atoms in a group   should be in the same molecule and <code>:pbc</code> should be used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/bias/cv.jl#L217-L229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CalcSingleDist"><a class="docstring-binding" href="#Molly.CalcSingleDist"><code>Molly.CalcSingleDist</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CalcSingleDist(calc_type=:closest)</code></pre><p>Bias the distance between two atoms.</p><p>Given as an argument to <a href="#Molly.CalcDist"><code>CalcDist</code></a>. By default, distances are calculated between the closest periodic images. Setting <code>calc_type=:raw</code> means that distances are calculated ignoring PBCs.</p><p>If distances are evaluated using the minimum image convention on an unwrapped system, raw coordinates must be within a distance of 1.5x the box length of each other to ensure correct results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/bias/cv.jl#L133-L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CellListMapNeighborFinder"><a class="docstring-binding" href="#Molly.CellListMapNeighborFinder"><code>Molly.CellListMapNeighborFinder</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CellListMapNeighborFinder(; eligible, dist_cutoff, special, n_steps, x0,
                          unit_cell, dims)</code></pre><p>Find close atoms by distance using a cell list algorithm from CellListMap.jl.</p><p>This is the recommended neighbor finder on CPU. <code>x0</code> and <code>unit_cell</code> are optional initial coordinates and system unit cell that improve the first approximation of the cell list structure. The number of dimensions <code>dims</code> is inferred from <code>unit_cell</code> or <code>x0</code>, or assumed to be 3 otherwise.</p><p>Can not be used if one or more dimensions has infinite boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/neighbors.jl#L255-L268">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CosineAngle"><a class="docstring-binding" href="#Molly.CosineAngle"><code>Molly.CosineAngle</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CosineAngle(; k, Œ∏0)</code></pre><p>A cosine bond angle between three atoms.</p><p><code>Œ∏0</code> is in radians. The potential energy is defined as</p><p class="math-container">\[V(\theta) = k(1 + \cos(\theta - \theta_0))\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/cosine_angle.jl#L3-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.Coulomb"><a class="docstring-binding" href="#Molly.Coulomb"><code>Molly.Coulomb</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Coulomb(; cutoff, use_neighbors, weight_special, coulomb_const)</code></pre><p>The Coulomb electrostatic interaction between two atoms.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = \frac{q_i q_j}{4 \pi \varepsilon_0 r_{ij}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/coulomb.jl#L11-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CoulombEwald"><a class="docstring-binding" href="#Molly.CoulombEwald"><code>Molly.CoulombEwald</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CoulombEwald(; dist_cutoff, error_tol=0.0005, use_neighbors=false, weight_special=1,
             coulomb_const=coulomb_const, approximate_erfc=true)</code></pre><p>The short range Ewald electrostatic interaction between two atoms.</p><p>Should be used alongside the <a href="#Molly.Ewald"><code>Ewald</code></a> or <a href="#Molly.PME"><code>PME</code></a> general interaction, which provide the long-range term. <code>dist_cutoff</code> and <code>error_tol</code> should match the general interaction.</p><p><code>dist_cutoff</code> is the cutoff distance for short range interactions. <code>approximate_erfc</code> determines whether to use a fast approximation to the erfc function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/coulomb.jl#L495-L507">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CoulombReactionField"><a class="docstring-binding" href="#Molly.CoulombReactionField"><code>Molly.CoulombReactionField</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CoulombReactionField(; dist_cutoff, solvent_dielectric, use_neighbors, weight_special,
                        coulomb_const)</code></pre><p>The Coulomb electrostatic interaction modified using the reaction field approximation between two atoms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/coulomb.jl#L378-L384">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CoulombSoftCoreBeutler"><a class="docstring-binding" href="#Molly.CoulombSoftCoreBeutler"><code>Molly.CoulombSoftCoreBeutler</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CoulombSoftCoreBeutler(; cutoff, Œ±, Œª, use_neighbors, œÉ_mixing, œµ_mixing,
                       weight_special, coulomb_const)</code></pre><p>The Coulomb electrostatic interaction between two atoms with a soft core, used for the appearing and disappearing of atoms.</p><p>See <a href="https://doi.org/10.1016/0009-2614(94)00397-1">Beutler et al. 1994</a>. The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = \lambda \frac{1}{4\pi\epsilon_0} \frac{q_iq_j}{r_Q^{1/6}}\]</p><p>and the force on each atom by</p><p class="math-container">\[\vec{F}_i = \lambda \frac{1}{4\pi\epsilon_0} \frac{q_iq_jr_{ij}^5}{r_Q^{7/6}}\frac{\vec{r_{ij}}}{r_{ij}}\]</p><p>where</p><p class="math-container">\[r_{Q} = \left(\frac{\alpha(1-\lambda)C^{(12)}}{C^{(6)}}\right)+r_{ij}^6\]</p><p>and</p><p class="math-container">\[C^{(12)} = 4\epsilon\sigma^{12}
C^{(6)} = 4\epsilon\sigma^{6}\]</p><p>If <span>$\lambda$</span> is 1.0, this gives the standard <a href="#Molly.Coulomb"><code>Coulomb</code></a> potential and means the atom is fully turned on. If <span>$\lambda$</span> is zero the interaction is turned off. <span>$\alpha$</span> determines the strength of softening the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/coulomb.jl#L111-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CoulombSoftCoreGapsys"><a class="docstring-binding" href="#Molly.CoulombSoftCoreGapsys"><code>Molly.CoulombSoftCoreGapsys</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CoulombSoftCoreGapsys(; cutoff, Œ±, Œª, œÉQ, use_neighbors, weight_special, coulomb_const)</code></pre><p>The Coulomb electrostatic interaction between two atoms with a soft core, used for the appearing and disappearing of atoms.</p><p>See <a href="https://doi.org/10.1021/ct300220p">Gapsys et al. 2012</a>. The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = \left\{ \begin{array}{cl}
\lambda \frac{1}{4\pi\epsilon_0} \frac{q_iq_j}{r_{ij}}, &amp; \text{if} &amp; r \ge r_{LJ} \\
\lambda \frac{1}{4\pi\epsilon_0} (\frac{q_iq_j}{r_{Q}^3}r_{ij}^2-\frac{3q_iq_j}{r_{Q}^2}r_{ij}+\frac{3q_iq_j}{r_{Q}}), &amp; \text{if} &amp; r \lt r_{LJ} \\
\end{array} \right.\]</p><p>and the force on each atom by</p><p class="math-container">\[\vec{F}_i = \left\{ \begin{array}{cl}
\lambda \frac{1}{4\pi\epsilon_0} \frac{q_iq_j}{r_{ij}^2}\frac{\vec{r_{ij}}}{r_{ij}}, &amp; \text{if} &amp; r \ge r_{LJ} \\
\lambda \frac{1}{4\pi\epsilon_0} (\frac{-2q_iq_j}{r_{Q}^3}r_{ij}+\frac{3q_iq_j}{r_{Q}^2})\frac{\vec{r_{ij}}}{r_{ij}}, &amp; \text{if} &amp; r \lt r_{LJ} \\
\end{array} \right.\]</p><p>where</p><p class="math-container">\[r_{Q} = \alpha(1-\lambda)^{1/6}(1+œÉ_Q|qi*qj|)\]</p><p>If <span>$\lambda$</span> is 1.0, this gives the standard <a href="#Molly.Coulomb"><code>Coulomb</code></a> potential and means the atom is fully turned on. If <span>$\lambda$</span> is zero the interaction is turned off. <span>$\alpha$</span> determines the strength of softening the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/coulomb.jl#L243-L273">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CubicBoundary"><a class="docstring-binding" href="#Molly.CubicBoundary"><code>Molly.CubicBoundary</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CubicBoundary(x, y, z)
CubicBoundary(x)</code></pre><p>Cubic 3D bounding box defined by three side lengths.</p><p>If one length is given then all three sides will have that length. Setting one or more values to <code>Inf</code> gives no boundary in that dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L31-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CubicSplineCutoff"><a class="docstring-binding" href="#Molly.CubicSplineCutoff"><code>Molly.CubicSplineCutoff</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CubicSplineCutoff(dist_activation, dist_cutoff)</code></pre><p>Cutoff that interpolates between the true potential at an activation distance and zero at a cutoff distance using a cubic Hermite spline.</p><p class="math-container">\[\begin{aligned}
V_c(r) &amp;= \begin{cases}
V(r), r \le r_a \\
(2t^3 - 3t^2 + 1) V(r_a) + (t^3 - 2t^2 + t) (r_c - r_a) V&#39;(r_a), r_a &lt; r \le r_c \\
0, r &gt; r_c
\end{cases} \\
F_c(r) &amp;= \begin{cases}
F(r), r \le r_a \\
\frac{-(6t^2 - 6t) V(r_a)}{r_c - r_a} - (3t^2 - 4t + 1) V&#39;(r_a), r_a &lt; r \le r_c \\
0, r &gt; r_c
\end{cases} \\
t &amp;= \frac{r - r_a}{r_c - r_a}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/cutoffs.jl#L151-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.DisplacementsLogger"><a class="docstring-binding" href="#Molly.DisplacementsLogger"><code>Molly.DisplacementsLogger</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DisplacementsLogger(n_steps, coords_start; n_steps_update::Integer=10)</code></pre><p>Log the displacements of atoms in a system throughout a simulation, useful for calculating properties like mean square displacement in periodic systems.</p><p>Displacements are updated every <code>n_steps_update</code> steps and a copy is saved every <code>n_steps</code> steps. <code>coords_start</code> are the initial reference positions and should match the coordinate type in the system.</p><p>It is assumed that a particle does not cross half the box size in <code>n_steps_update</code> steps. By default <code>n_steps_update</code> is set to 10 to mitigate this assumption, but it can be set to a higher value to reduce cost. <code>n_steps</code> must be a multiple of <code>n_steps_update</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L398-L413">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.DistanceConstraint"><a class="docstring-binding" href="#Molly.DistanceConstraint"><code>Molly.DistanceConstraint</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DistanceConstraint(i, j, dist)</code></pre><p>Constraint between two atoms that maintains a fixed distance between the atoms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/constraints/constraints.jl#L10-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.DistanceCutoff"><a class="docstring-binding" href="#Molly.DistanceCutoff"><code>Molly.DistanceCutoff</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DistanceCutoff(dist_cutoff)</code></pre><p>Cutoff that sets the potential and force to be zero past a specified cutoff distance.</p><p class="math-container">\[\begin{aligned}
V_c(r) &amp;= \begin{cases}
V(r), r \le r_c \\
0, r &gt; r_c
\end{cases} \\
F_c(r) &amp;= \begin{cases}
F(r), r \le r_c \\
0, r &gt; r_c
\end{cases}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/cutoffs.jl#L53-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.DistanceNeighborFinder"><a class="docstring-binding" href="#Molly.DistanceNeighborFinder"><code>Molly.DistanceNeighborFinder</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DistanceNeighborFinder(; eligible, dist_cutoff, special, n_steps)</code></pre><p>Find close atoms by distance.</p><p>This is the recommended neighbor finder on non-NVIDIA GPUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/neighbors.jl#L84-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.EnsembleSystem"><a class="docstring-binding" href="#Molly.EnsembleSystem"><code>Molly.EnsembleSystem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EnsembleSystem(coordinate_file, trajectory_file, force_field; &lt;keyword arguments&gt;)
EnsembleSystem(system, trajectory_file)</code></pre><p>An object allowing data to be read from a trajectory or ensemble associated with a <a href="#Molly.System"><code>System</code></a>.</p><p>The keyword arguments are the same as <a href="#Molly.System"><code>System</code></a> setup from a file. In the case of passing a <a href="#Molly.System"><code>System</code></a> directly, a copy of the system is made.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/trajectory.jl#L5-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.Ewald"><a class="docstring-binding" href="#Molly.Ewald"><code>Molly.Ewald</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Ewald(dist_cutoff; error_tol=0.0005, eligible=nothing, special=nothing)</code></pre><p>Ewald summation for long range electrostatics implemented as an AtomsCalculators.jl calculator.</p><p>Should be used alongside the <a href="#Molly.CoulombEwald"><code>CoulombEwald</code></a> pairwise interaction, which provide the short range term. <code>dist_cutoff</code> and <code>error_tol</code> should match <a href="#Molly.CoulombEwald"><code>CoulombEwald</code></a>.</p><p><code>dist_cutoff</code> is the cutoff distance for short range interactions. <code>eligible</code> indicates pairs eligible for short range interaction, and can be a matrix like the neighbor list or <code>nothing</code> to indicate that all pairs are eligible. <code>special</code> should also be given where relevant, as these interactions are excluded from long range calculation.</p><p>This algorithm is O(N^2) and in general <a href="#Molly.PME"><code>PME</code></a> should be used instead. Only compatible with 3D systems and <a href="#Molly.CubicBoundary"><code>CubicBoundary</code></a>. Not compatible with infinite boundaries. Runs on the CPU, even for GPU systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/ewald.jl#L157-L178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.FENEBond"><a class="docstring-binding" href="#Molly.FENEBond"><code>Molly.FENEBond</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FENEBond(; k, r0, œÉ, œµ)</code></pre><p>A finitely extensible non-linear elastic (FENE) bond between two atoms, see <a href="https://doi.org/10.1063/1.458541">Kremer and Grest 1990</a>.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r) = -\frac{1}{2} k r^2_0 \ln \left( 1 - \left( \frac{r}{r_0} \right) ^2 \right) + V_{\text{WCA}}(r)\]</p><p>where the WCA contribution is given by</p><p class="math-container">\[V_{\text{WCA}}(r) =
    \begin{cases}
      4\varepsilon \left[ \left( \frac{\sigma}{r} \right) ^{12} - \left( \frac{\sigma}{r} \right) ^6 \right] + \varepsilon &amp; r &lt; 2^{1/6}\sigma\\
      0 &amp; r \geq 2^{1/6}\sigma\\
    \end{cases}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/fene_bond.jl#L3-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.FlatBottomSquareBias"><a class="docstring-binding" href="#Molly.FlatBottomSquareBias"><code>Molly.FlatBottomSquareBias</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FlatBottomSquareBias(k, r_fb, cv_target)</code></pre><p>A flat-bottomed square (harmonic) bias on a collective variable (CV) towards a target value.</p><p>The bias is zero when the value of the collective variable does not deviate from <code>cv_target</code> by more than <code>r_fb</code>, and is square (harmonic) outside this range.</p><p>The potential energy is defined as</p><p class="math-container">\[V(\boldsymbol{s}) = \frac{1}{2} k (|\boldsymbol{s} - \boldsymbol{s}_t| - r_{fb})^2 H\]</p><p>where <span>$s$</span> and <span>$s_t$</span> are the system and target CV values respectively, and</p><p class="math-container">\[H = \left\{ \begin{array}{cl}
0 &amp; \text{if} &amp; |\boldsymbol{s} - \boldsymbol{s}_t| &lt; r_{fb} \\
1 &amp; \text{if} &amp; |\boldsymbol{s} - \boldsymbol{s}_t| \geq r_{fb} \\
\end{array} \right.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/bias/bias.jl#L58-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.GPUNeighborFinder"><a class="docstring-binding" href="#Molly.GPUNeighborFinder"><code>Molly.GPUNeighborFinder</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GPUNeighborFinder(; eligible, dist_cutoff, special, n_steps_reorder, initialized)</code></pre><p>Use the non-bonded forces/potential energy algorithm from <a href="https://doi.org/10.1002/jcc.21413">Eastman and Pande 2010</a> to avoid calculating a neighbor list.</p><p>This is the recommended neighbor finder on NVIDIA GPUs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/neighbors.jl#L49-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.GeneralObservableLogger"><a class="docstring-binding" href="#Molly.GeneralObservableLogger"><code>Molly.GeneralObservableLogger</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GeneralObservableLogger(observable::Function, T, n_steps)</code></pre><p>A logger which holds a record of regularly sampled observations of a system.</p><p><code>observable</code> should return an object of type <code>T</code> and support the method <code>observable(s::System, neighbors; n_threads::Integer)::T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L54-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.Gravity"><a class="docstring-binding" href="#Molly.Gravity"><code>Molly.Gravity</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Gravity(; cutoff, G, use_neighbors)</code></pre><p>The gravitational interaction between two atoms.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = -\frac{G m_i m_j}{r_{ij}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/gravity.jl#L3-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.HamiltonianREMD"><a class="docstring-binding" href="#Molly.HamiltonianREMD"><code>Molly.HamiltonianREMD</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HamiltonianREMD(; &lt;keyword arguments&gt;)</code></pre><p>A simulator for a parallel Hamiltonian replica exchange MD (H-REMD) simulation on a <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a>.</p><p>The replicas are expected to have different Hamiltonians, i.e. different interactions. When calling <a href="#Molly.simulate!-Tuple{Any, SteepestDescentMinimizer}"><code>simulate!</code></a>, the <code>assign_velocities</code> keyword argument determines whether to assign random velocities at the appropriate temperature for each replica.</p><p><strong>Arguments</strong></p><ul><li><code>dt::DT</code>: the time step of the simulation.</li><li><code>temperature::T</code>: the temperatures of the simulation.</li><li><code>simulators::ST</code>: individual simulators for simulating each replica.</li><li><code>exchange_time::ET</code>: the time interval between replica exchange attempts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L877-L892">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.HarmonicAngle"><a class="docstring-binding" href="#Molly.HarmonicAngle"><code>Molly.HarmonicAngle</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HarmonicAngle(; k, Œ∏0)</code></pre><p>A harmonic bond angle between three atoms.</p><p><code>Œ∏0</code> is in radians. The second atom is the middle atom. The potential energy is defined as</p><p class="math-container">\[V(\theta) = \frac{1}{2} k (\theta - \theta_0)^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/harmonic_angle.jl#L3-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.HarmonicBond"><a class="docstring-binding" href="#Molly.HarmonicBond"><code>Molly.HarmonicBond</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HarmonicBond(; k, r0)</code></pre><p>A harmonic bond between two atoms.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r) = \frac{1}{2} k (r - r_0)^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/harmonic_bond.jl#L3-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.HarmonicPositionRestraint"><a class="docstring-binding" href="#Molly.HarmonicPositionRestraint"><code>Molly.HarmonicPositionRestraint</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HarmonicPositionRestraint(; k, x0)</code></pre><p>A harmonic position restraint on an atom to coordinate <code>x0</code>.</p><p>The potential energy is defined as</p><p class="math-container">\[V(\boldsymbol{x}) = \frac{1}{2} k |\boldsymbol{x} - \boldsymbol{x}_0|^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/harmonic_position_restraint.jl#L3-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.ImmediateThermostat"><a class="docstring-binding" href="#Molly.ImmediateThermostat"><code>Molly.ImmediateThermostat</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ImmediateThermostat(temperature)</code></pre><p>The immediate velocity rescaling thermostat for controlling temperature.</p><p>Velocities are immediately rescaled to match a target temperature. The scaling factor for the velocities each step is</p><p class="math-container">\[\lambda = \sqrt{\frac{T_0}{T}}\]</p><p>This thermostat should be used with caution as it can lead to simulation artifacts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/coupling.jl#L50-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.ImplicitSolventGBN2"><a class="docstring-binding" href="#Molly.ImplicitSolventGBN2"><code>Molly.ImplicitSolventGBN2</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ImplicitSolventGBN2(atoms, atoms_data, bonds)</code></pre><p>GBn2 solvation model implemented as an AtomsCalculators.jl calculator.</p><p>Should be used along with a Coulomb interaction.</p><p>Not currently compatible with virial calculation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/implicit_solvent.jl#L434-L442">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.ImplicitSolventOBC"><a class="docstring-binding" href="#Molly.ImplicitSolventOBC"><code>Molly.ImplicitSolventOBC</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ImplicitSolventOBC(atoms, atoms_data, bonds)</code></pre><p>Onufriev-Bashford-Case GBSA model implemented as an AtomsCalculators.jl calculator.</p><p>Should be used along with a Coulomb interaction. The keyword argument <code>use_OBC2</code> determines whether to use parameter set I (<code>false</code>, the default) or II (<code>true</code>).</p><p>Not currently compatible with virial calculation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/implicit_solvent.jl#L326-L336">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.InteractionList1Atoms"><a class="docstring-binding" href="#Molly.InteractionList1Atoms"><code>Molly.InteractionList1Atoms</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InteractionList1Atoms(is, inters)
InteractionList1Atoms(is, inters, types)
InteractionList1Atoms(inter_type)</code></pre><p>A list of specific interactions that involve one atom such as position restraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L47-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.InteractionList2Atoms"><a class="docstring-binding" href="#Molly.InteractionList2Atoms"><code>Molly.InteractionList2Atoms</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InteractionList2Atoms(is, js, inters)
InteractionList2Atoms(is, js, inters, types)
InteractionList2Atoms(inter_type)</code></pre><p>A list of specific interactions that involve two atoms such as bond potentials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L60-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.InteractionList3Atoms"><a class="docstring-binding" href="#Molly.InteractionList3Atoms"><code>Molly.InteractionList3Atoms</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InteractionList3Atoms(is, js, ks, inters)
InteractionList3Atoms(is, js, ks, inters, types)
InteractionList3Atoms(inter_type)</code></pre><p>A list of specific interactions that involve three atoms such as bond angle potentials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L74-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.InteractionList4Atoms"><a class="docstring-binding" href="#Molly.InteractionList4Atoms"><code>Molly.InteractionList4Atoms</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InteractionList4Atoms(is, js, ks, ls, inters)
InteractionList4Atoms(is, js, ks, ls, inters, types)
InteractionList4Atoms(inter_type)</code></pre><p>A list of specific interactions that involve four atoms such as torsion potentials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L89-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.Langevin"><a class="docstring-binding" href="#Molly.Langevin"><code>Molly.Langevin</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Langevin(; &lt;keyword arguments&gt;)</code></pre><p>The Langevin integrator, based on the Langevin Middle Integrator in OpenMM.</p><p>See <a href="https://doi.org/10.1021/acs.jpca.9b02771">Zhang et al. 2019</a>. This is a leapfrog integrator, so the velocities are offset by half a time step behind the positions.</p><p><strong>Arguments</strong></p><ul><li><code>dt::S</code>: the time step of the simulation.</li><li><code>temperature::K</code>: the equilibrium temperature of the simulation.</li><li><code>friction::F</code>: the friction coefficient of the simulation.</li><li><code>coupling::C=NoCoupling()</code>: the coupling which applies during the simulation.</li><li><code>remove_CM_motion=1</code>: remove the center of mass motion every this number of steps,   set to <code>false</code> or <code>0</code> to not remove center of mass motion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L365-L381">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.LangevinSplitting"><a class="docstring-binding" href="#Molly.LangevinSplitting"><code>Molly.LangevinSplitting</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LangevinSplitting(; &lt;keyword arguments&gt;)</code></pre><p>The Langevin simulator using a general splitting scheme.</p><p>This consists of a succession of <strong>A</strong>, <strong>B</strong> and <strong>O</strong> steps, corresponding respectively to updates in position, velocity for the potential part, and velocity for the thermal fluctuation-dissipation part. The <a href="#Molly.Langevin"><code>Langevin</code></a> and <a href="#Molly.VelocityVerlet"><code>VelocityVerlet</code></a> simulators without coupling correspond to the <strong>BAOA</strong> and <strong>BAB</strong> schemes respectively. For more information on the sampling properties of splitting schemes, see <a href="https://doi.org/10.3390/e20050318">Fass et al. 2018</a>.</p><p>Not currently compatible with constraints, will print a warning and continue without applying constraints.</p><p><strong>Arguments</strong></p><ul><li><code>dt::S</code>: the time step of the simulation.</li><li><code>temperature::K</code>: the equilibrium temperature of the simulation.</li><li><code>friction::F</code>: the friction coefficient. If units are used, it should have a   dimensionality of mass per time.</li><li><code>splitting::W</code>: the splitting specifier. Should be a string consisting of the   characters <code>A</code>, <code>B</code> and <code>O</code>. Strings with no <code>O</code>s reduce to deterministic   symplectic schemes.</li><li><code>remove_CM_motion=1</code>: remove the center of mass motion every this number of steps,   set to <code>false</code> or <code>0</code> to not remove center of mass motion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L461-L487">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.LennardJones"><a class="docstring-binding" href="#Molly.LennardJones"><code>Molly.LennardJones</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LennardJones(; cutoff, use_neighbors, shortcut, œÉ_mixing, œµ_mixing, weight_special)</code></pre><p>The Lennard-Jones 6-12 interaction between two atoms.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = 4\varepsilon_{ij} \left[\left(\frac{\sigma_{ij}}{r_{ij}}\right)^{12} - \left(\frac{\sigma_{ij}}{r_{ij}}\right)^{6}\right]\]</p><p>and the force on each atom by</p><p class="math-container">\[\begin{aligned}
\vec{F}_i &amp;= 24\varepsilon_{ij} \left(2\frac{\sigma_{ij}^{12}}{r_{ij}^{13}} - \frac{\sigma_{ij}^6}{r_{ij}^{7}}\right) \frac{\vec{r}_{ij}}{r_{ij}} \\
&amp;= \frac{24\varepsilon_{ij}}{r_{ij}^2} \left[2\left(\frac{\sigma_{ij}}{r_{ij}}\right)^{12} -\left(\frac{\sigma_{ij}}{r_{ij}}\right)^{6}\right] \vec{r}_{ij}
\end{aligned}\]</p><p>The potential energy does not include the long range dispersion correction present in some other implementations that approximately represents contributions from beyond the cutoff distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/lennard_jones.jl#L7-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.LennardJonesSoftCoreBeutler"><a class="docstring-binding" href="#Molly.LennardJonesSoftCoreBeutler"><code>Molly.LennardJonesSoftCoreBeutler</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LennardJonesSoftCoreBeutler(; cutoff, Œ±, Œª, use_neighbors, shortcut, œÉ_mixing,
                            œµ_mixing, weight_special)</code></pre><p>The Lennard-Jones 6-12 interaction between two atoms with a soft core, used for the appearing and disappearing of atoms.</p><p>See <a href="https://doi.org/10.1016/0009-2614(94)00397-1">Beutler et al. 1994</a>. The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = \lambda \left(\frac{C^{(12)}}{r_{LJ}^{12}} - \frac{C^{(6)}}{r_{LJ}^{6}}\right)\]</p><p>and the force on each atom by</p><p class="math-container">\[\vec{F}_i = \lambda \left(\left(\frac{12C^{(12)}}{r_{LJ}^{13}} - \frac{6C^{(6)}}{r_{LJ}^7}\right)\left(\frac{r_{ij}}{r_{LJ}}\right)^5\right) \frac{\vec{r_{ij}}}{r_{ij}}\]</p><p>where</p><p class="math-container">\[r_{LJ} = \left(\frac{\alpha(1-\lambda)C^{(12)}}{C^{(6)}}+r^6\right)^{1/6}\]</p><p>and</p><p class="math-container">\[C^{(12)} = 4\epsilon\sigma^{12}
C^{(6)} = 4\epsilon\sigma^{6}\]</p><p>If <span>$\lambda$</span> is 1.0, this gives the standard <a href="#Molly.LennardJones"><code>LennardJones</code></a> potential and means the atom is fully turned on. If <span>$\lambda$</span> is zero the interaction is turned off. <span>$\alpha$</span> determines the strength of softening the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/lennard_jones.jl#L142-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.LennardJonesSoftCoreGapsys"><a class="docstring-binding" href="#Molly.LennardJonesSoftCoreGapsys"><code>Molly.LennardJonesSoftCoreGapsys</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LennardJonesSoftCoreGapsys(; cutoff, Œ±, Œª, use_neighbors, shortcut, œÉ_mixing,
                           œµ_mixing, weight_special)</code></pre><p>The Lennard-Jones 6-12 interaction between two atoms with a soft core potential, used for the appearing and disappearing of atoms.</p><p>See <a href="https://doi.org/10.1021/ct300220p">Gapsys et al. 2012</a>. The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = \left\{ \begin{array}{cl}
\lambda \left( \frac{C^{(12)}}{r_{ij}^{12}} - \frac{C^{(6)}}{r_{ij}^{6}} \right), &amp; \text{if} &amp; r \ge r_{LJ} \\
\lambda \left( (\frac{78C^{(12)}}{r_{LJ}^{14}}-\frac{21C^{(6)}}{r_{LJ}^{8}})r_{ij}^2 - (\frac{168C^{(12)}}{r_{LJ}^{13}}-\frac{48C^{(6)}}{r_{LJ}^{7}})r_{ij} + \frac{91C^{(12)}}{r_{LJ}^{12}}-\frac{28C^{(6)}}{r_{LJ}^{6}} \right), &amp; \text{if} &amp; r \lt r_{LJ} \\
\end{array} \right.\]</p><p>and the force on each atom by</p><p class="math-container">\[\vec{F}_i = \left\{ \begin{array}{cl}
\lambda \left( \frac{12C^{(12)}}{r_{ij}^{13}} - \frac{6C^{(6)}}{r_{ij}^{7}} \right)\frac{\vec{r_{ij}}}{r_{ij}}, &amp; \text{if} &amp; r \ge r_{LJ} \\
\lambda \left( (\frac{-156C^{(12)}}{r_{LJ}^{14}}+\frac{42C^{(6)}}{r_{LJ}^{8}})r_{ij} - (\frac{168C^{(12)}}{r_{LJ}^{13}}-\frac{48C^{(6)}}{r_{LJ}^{7}}) \right)\frac{\vec{r_{ij}}}{r_{ij}}, &amp; \text{if} &amp; r \lt r_{LJ} \\
\end{array} \right.\]</p><p>where</p><p class="math-container">\[r_{LJ} = \alpha \left( \frac{26C^{(12)}(1-\lambda)}{7C^{(6)}} \right)^{\frac{1}{6}}\]</p><p>and</p><p class="math-container">\[C^{(12)} = 4\epsilon\sigma^{12}
C^{(6)} = 4\epsilon\sigma^{6}\]</p><p>If <span>$\lambda$</span> is 1.0, this gives the standard <a href="#Molly.LennardJones"><code>LennardJones</code></a> potential and means the atom is fully turned on. If <span>$\lambda$</span> is zero the interaction is turned off. <span>$\alpha$</span> determines the strength of softening the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/lennard_jones.jl#L279-L315">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.LinearBias"><a class="docstring-binding" href="#Molly.LinearBias"><code>Molly.LinearBias</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearBias(k, cv_target)</code></pre><p>A linear bias on a collective variable (CV) towards a target value.</p><p>The potential energy is defined as</p><p class="math-container">\[V(\boldsymbol{s}) = k |\boldsymbol{s} - \boldsymbol{s}_t|\]</p><p>where <span>$s$</span> and <span>$s_t$</span> are the system and target CV values respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/bias/bias.jl#L10-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.MetropolisMonteCarlo"><a class="docstring-binding" href="#Molly.MetropolisMonteCarlo"><code>Molly.MetropolisMonteCarlo</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MetropolisMonteCarlo(; &lt;keyword arguments&gt;)</code></pre><p>A Monte Carlo simulator that uses the Metropolis algorithm to sample the configuration space.</p><p><strong>Arguments</strong></p><ul><li><code>temperature::T</code>: the temperature of the system.</li><li><code>trial_moves::M</code>: a function that performs the trial moves.</li><li><code>trial_args::Dict</code>: a dictionary of arguments to be passed to the trial move function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L1044-L1053">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.Mie"><a class="docstring-binding" href="#Molly.Mie"><code>Molly.Mie</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Mie(; m, n, cutoff, use_neighbors, shortcut, œÉ_mixing, œµ_mixing, weight_special)</code></pre><p>The Mie generalized interaction between two atoms.</p><p>When <code>m</code> equals 6 and <code>n</code> equals 12 this is equivalent to the Lennard-Jones interaction. The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = C \varepsilon_{ij} \left[\left(\frac{\sigma_{ij}}{r_{ij}}\right)^n - \left(\frac{\sigma_{ij}}{r_{ij}}\right)^m\right]\]</p><p>where</p><p class="math-container">\[C = \frac{n}{n - m} \left( \frac{n}{m} \right) ^\frac{m}{n - m}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/mie.jl#L3-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.MolecularForceField"><a class="docstring-binding" href="#Molly.MolecularForceField"><code>Molly.MolecularForceField</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MolecularForceField(ff_files...; units=true, custom_residue_templates=nothing,
                    custom_renaming_scheme=nothing)
MolecularForceField(T, ff_files...; units=true, custom_residue_templates=nothing,
                    custom_renaming_scheme=nothing)
MolecularForceField(atom_types, residue_types, bond_types, angle_types,
                    torsion_types, torsion_order, weight_14_coulomb,
                    weight_14_lj, attributes_from_residue,
                    residue_name_replacements, atom_name_replacements,
                    standard_bonds)</code></pre><p>A molecular force field.</p><p>Read one or more OpenMM force field XML files by passing them to the constructor. See the <a href="https://docs.openmm.org/latest/userguide/application/06_creating_ffs.html">OpenMM documentation</a> for how these files are formatted.</p><p>In order to assign force field parameters to the atoms in the simulation, the residues determined from a structure file are matched to templates provided by the force field file, as well as a template dictionary in XML format, which defines the standard topology (bonds) of the residues to be found in the simulation. At the moment, Molly provides a dictionary for all standard amino acids, nucleic acids and water for this purpose. If the system to be simulated contains other molecules, their template topologies must be defined either through <code>CONECT</code> records in the PDB file or by providing an extra custom template file with the <code>custom_residue_templates</code> keyword.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/force_field.jl#L237-L263">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.MolecularTopology"><a class="docstring-binding" href="#Molly.MolecularTopology"><code>Molly.MolecularTopology</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MolecularTopology(bond_is, bond_js, n_atoms)
MolecularTopology(atom_molecule_inds, molecule_atom_counts, bonded_atoms=[])</code></pre><p>Topology information for a system.</p><p>Stores the index of the molecule each atom belongs to, the number of atoms in each molecule and the list of bonded atom pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L361-L369">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.MollyCalculator"><a class="docstring-binding" href="#Molly.MollyCalculator"><code>Molly.MollyCalculator</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MollyCalculator(; &lt;keyword arguments&gt;)</code></pre><p>A calculator for use with the AtomsCalculators.jl interface.</p><p><code>neighbors</code> can optionally be given as a keyword argument when calling the calculation functions to save on computation when the neighbors are the same for multiple calls. In a similar way, <code>n_threads</code> can be given to determine the number of threads to use when running the calculation function. Note that this calculator is designed for using Molly in other contexts; if you want to use another calculator in Molly it can be given as <code>general_inters</code> when creating a <a href="#Molly.System"><code>System</code></a>.</p><p>Not currently compatible with virial calculation. Not currently compatible with using atom properties such as <code>œÉ</code> and <code>œµ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>pairwise_inters::PI=()</code>: the pairwise interactions in the system, i.e.   interactions between all or most atom pairs such as electrostatics.   Should be a <code>Tuple</code> or <code>NamedTuple</code> of <code>PairwiseInteraction</code>s.</li><li><code>specific_inter_lists::SI=()</code>: the specific interactions in the system,   i.e. interactions between specific atoms such as bonds or angles.   Should be a <code>Tuple</code> or <code>NamedTuple</code>.</li><li><code>general_inters::GI=()</code>: the general interactions in the system,   i.e. interactions involving all atoms such as implicit solvent. Each should   implement the AtomsCalculators.jl interface. Should be a <code>Tuple</code> or <code>NamedTuple</code>.</li><li><code>neighbor_finder::NF=NoNeighborFinder()</code>: the neighbor finder used to find   close atoms and save on computation.</li><li><code>force_units::F=u&quot;kJ * mol^-1 * nm^-1&quot;</code>: the units of force of the system.   Should be set to <code>NoUnits</code> if units are not being used.</li><li><code>energy_units::E=u&quot;kJ * mol^-1&quot;</code>: the units of energy of the system. Should   be set to <code>NoUnits</code> if units are not being used.</li><li><code>k::K=Unitful.k</code> or <code>Unitful.k * Unitful.Na</code>: the Boltzmann constant, which may be   modified in some simulations. <code>k</code> is chosen based on the <code>energy_units</code> given.</li><li><code>dims::Integer=3</code>: the number of dimensions in the system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L1450-L1486">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.MonteCarloBarostat"><a class="docstring-binding" href="#Molly.MonteCarloBarostat"><code>Molly.MonteCarloBarostat</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MonteCarloBarostat(pressure, temperature, boundary; coupling_type=:isotropic,
                   n_steps=30, n_iterations=1,
                   scale_factor=0.01, scale_increment=1.1, max_volume_frac=0.3,
                   trial_find_neighbors=false)</code></pre><p>The Monte Carlo barostat for controlling pressure.</p><p>See <a href="https://doi.org/10.1016/0010-4655(95)00059-O">Chow and Ferguson 1995</a>, <a href="https://doi.org/10.1016/j.cplett.2003.12.039">‚Ñ´qvist et al. 2004</a> and the OpenMM source code. At regular intervals a Monte Carlo step is attempted by scaling the coordinates and the bounding box by a randomly chosen amount. The step is accepted or rejected based on</p><p class="math-container">\[\Delta G = \Delta E + \Delta W - N k_B T \ln \left( \frac{V + \Delta V}{V} \right)\]</p><p>where <code>ŒîE</code> is the change in potential energy, <code>ŒîV</code> is the change in volume, <code>N</code> is the number of molecules in the system, <code>T</code> is the equilibrium temperature and <code>V</code> is the system volume. <code>ŒîW</code> is the work done by scaling the simulation box and its specific form changes depending on the type of scaling applied. In general and in the absence of shear stress:</p><p class="math-container">\[\Delta W = (V + \Delta V) \cdot \sum w_i \cdot  P_{i,i} \cdot \ln \left ( {\frac{V + \Delta V}{V}} \right )\]</p><p>where <code>w_i</code> is the proportional scaling along a specific box axis.</p><p>If <code>ŒîG ‚â§ 0</code> the step is always accepted, if <code>ŒîG &gt; 0</code> the step is accepted with probability <code>exp(-ŒîG/kT)</code>.</p><p>The scale factor is modified over time to maintain an acceptance rate of around half. If the topology of the system is set then molecules are moved as a unit so properties such as bond lengths do not change.</p><p>The barostat assumes that the simulation is being run at a constant temperature but does not actively control the temperature. It should be used alongside a temperature coupling method such as the <a href="#Molly.Langevin"><code>Langevin</code></a> simulator or <a href="#Molly.AndersenThermostat"><code>AndersenThermostat</code></a> coupling. The neighbor list is not updated when making trial moves or after accepted moves. Note that the barostat can change the bounding box of the system. Does not currently work with shear stresses, the anisotropic variant only applies independent linear scaling of the box vectors. If shear deformation is required the <a href="#Molly.BerendsenBarostat"><code>BerendsenBarostat</code></a> or, preferably, the <a href="#Molly.CRescaleBarostat"><code>CRescaleBarostat</code></a> should be used instead. Due to the stochastic nature of the Monte Carlo acceptance criteria, this barostat may not propagate gradients correctly with differentiable simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/coupling.jl#L684-L731">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.MonteCarloLogger"><a class="docstring-binding" href="#Molly.MonteCarloLogger"><code>Molly.MonteCarloLogger</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MonteCarloLogger()
MonteCarloLogger(T)</code></pre><p>A logger that records acceptances in a Monte Carlo simulation.</p><p>The logged quantities include the number of new selections (<code>n_select</code>), the number of successful acceptances (<code>n_accept</code>), an array named <code>energy_rates</code> which stores the value of <span>$\frac{E}{k_B T}$</span> i.e. the argument of the Boltzmann factor for the states, and a <code>BitVector</code> named <code>state_changed</code> that stores whether a new state was accepted for the logged step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L1027-L1038">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.MorseBond"><a class="docstring-binding" href="#Molly.MorseBond"><code>Molly.MorseBond</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MorseBond(; D, a, r0)</code></pre><p>A Morse potential bond between two atoms.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r) = D(1 - e^{-a(r - r_0)})^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/morse_bond.jl#L3-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.MullerBrown"><a class="docstring-binding" href="#Molly.MullerBrown"><code>Molly.MullerBrown</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MullerBrown(; A, a, b, c, x0, y0, force_units, energy_units)</code></pre><p>The M√ºller-Brown potential energy surface implemented as an AtomsCalculators.jl calculator.</p><p>The potential energy is defined as</p><p class="math-container">\[V(x,y) = \sum_{n=1}^{4} A_k \exp[a_k(x-x_k^0)^2 + b_k(x-x_k^0)(y-y_k^0) + c_k(y-y_k^0)^2]\]</p><p>where <code>A</code>, <code>a</code>, <code>b</code>, <code>c</code>, <code>x0</code>, <code>y0</code> are 4-element <code>SVector</code>s with standard defaults.</p><p>This potential is only compatible with 2D systems. It is often used for testing algorithms that find transition states or explore minimum energy pathways. There are 3 minima and 2 saddle points with the default parameters.</p><p>Not currently compatible with virial calculation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/muller_brown.jl#L3-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.NeighborList"><a class="docstring-binding" href="#Molly.NeighborList"><code>Molly.NeighborList</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NeighborList(n, list)
NeighborList()</code></pre><p>Structure to contain neighbor lists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L400-L405">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.NoCoupling"><a class="docstring-binding" href="#Molly.NoCoupling"><code>Molly.NoCoupling</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NoCoupling()</code></pre><p>Placeholder coupler that does nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/coupling.jl#L41-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.NoCutoff"><a class="docstring-binding" href="#Molly.NoCutoff"><code>Molly.NoCutoff</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NoCutoff()</code></pre><p>Placeholder cutoff that does not alter the potential or force.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/cutoffs.jl#L46-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.NoNeighborFinder"><a class="docstring-binding" href="#Molly.NoNeighborFinder"><code>Molly.NoNeighborFinder</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NoNeighborFinder()</code></pre><p>Placeholder neighbor finder that returns no neighbors.</p><p>When using this neighbor finder, ensure that <a href="#Molly.use_neighbors-Tuple{Any}"><code>use_neighbors</code></a> for the interactions returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/neighbors.jl#L23-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.NoseHoover"><a class="docstring-binding" href="#Molly.NoseHoover"><code>Molly.NoseHoover</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NoseHoover(; &lt;keyword arguments&gt;)</code></pre><p>The Nos√©-Hoover integrator, a NVT simulator that extends velocity Verlet to control the temperature of the system.</p><p>See <a href="https://doi.org/10.1063/1.449071">Evans and Holian 1985</a>. The current implementation is limited to ergodic systems.</p><p>Not currently compatible with constraints, will print a warning and continue without applying constraints.</p><p><strong>Arguments</strong></p><ul><li><code>dt::T</code>: the time step of the simulation.</li><li><code>temperature::K</code>: the equilibrium temperature of the simulation.</li><li><code>damping::D=100*dt</code>: the temperature damping time scale.</li><li><code>coupling::C=NoCoupling()</code>: the coupling which applies during the simulation.</li><li><code>remove_CM_motion=1</code>: remove the center of mass motion every this number of steps,   set to <code>false</code> or <code>0</code> to not remove center of mass motion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L669-L688">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.OverdampedLangevin"><a class="docstring-binding" href="#Molly.OverdampedLangevin"><code>Molly.OverdampedLangevin</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OverdampedLangevin(; &lt;keyword arguments&gt;)</code></pre><p>Simulates the overdamped Langevin equation using the Euler-Maruyama method.</p><p>Not currently compatible with constraints, will print a warning and continue without applying constraints.</p><p><strong>Arguments</strong></p><ul><li><code>dt::S</code>: the time step of the simulation.</li><li><code>temperature::K</code>: the equilibrium temperature of the simulation.</li><li><code>friction::F</code>: the friction coefficient of the simulation.</li><li><code>remove_CM_motion=1</code>: remove the center of mass motion every this number of steps,   set to <code>false</code> or <code>0</code> to not remove center of mass motion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L600-L614">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.PME"><a class="docstring-binding" href="#Molly.PME"><code>Molly.PME</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PME(dist_cutoff, atoms, boundary; error_tol=0.0005, order=5,
    œµr=1.0, fixed_charges=true, eligible=nothing, special=nothing,
    grad_safe=false, n_threads=Threads.nthreads())</code></pre><p>Particle mesh Ewald summation for long range electrostatics implemented as an AtomsCalculators.jl calculator.</p><p>Should be used alongside the <a href="#Molly.CoulombEwald"><code>CoulombEwald</code></a> pairwise interaction, which provide the short range term. <code>dist_cutoff</code> and <code>error_tol</code> should match <a href="#Molly.CoulombEwald"><code>CoulombEwald</code></a>.</p><p><code>dist_cutoff</code> is the cutoff distance for short range interactions. <code>eligible</code> indicates pairs eligible for short range interaction, and can be a matrix like the neighbor list or <code>nothing</code> to indicate that all pairs are eligible. <code>special</code> should also be given where relevant, as these interactions are excluded from long range calculation. <code>fixed_charges</code> should be set to <code>false</code> if the partial charges can change, for example when using a polarizable force field. <code>grad_safe</code> should be set to <code>true</code> if gradients are going to be calculated with Enzyme.jl. <code>n_threads</code> is used to pre-allocate memory on CPU.</p><p>This implementation is based on the implementation in OpenMM, which is based on the smooth PME algorithm from <a href="https://doi.org/10.1063/1.470117">Essmann et al. 1995</a>.</p><p>Only compatible with 3D systems. Not compatible with infinite boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/ewald.jl#L353-L383">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.PairwiseInteraction"><a class="docstring-binding" href="#Molly.PairwiseInteraction"><code>Molly.PairwiseInteraction</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Base type for pairwise interactions.</p><p>An alias for NBodyInteraction{2}. Custom pairwise interactions should subtype this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L39-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.PeriodicTorsion"><a class="docstring-binding" href="#Molly.PeriodicTorsion"><code>Molly.PeriodicTorsion</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PeriodicTorsion(; periodicities, phases, ks, proper)</code></pre><p>A periodic torsion angle between four atoms.</p><p><code>phases</code> are in radians. The potential energy is defined as</p><p class="math-container">\[V(\phi) = \sum_{n=1}^N k_n (1 + \cos(n \phi - \phi_{s,n}))\]</p><p>Only compatible with 3D systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/periodic_torsion.jl#L3-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.RBTorsion"><a class="docstring-binding" href="#Molly.RBTorsion"><code>Molly.RBTorsion</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RBTorsion(; f1, f2, f3, f4)</code></pre><p>A Ryckaert-Bellemans torsion angle between four atoms.</p><p>Only compatible with 3D systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/rb_torsion.jl#L3-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.RectangularBoundary"><a class="docstring-binding" href="#Molly.RectangularBoundary"><code>Molly.RectangularBoundary</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RectangularBoundary(x, y)
RectangularBoundary(x)</code></pre><p>Rectangular 2D bounding box defined by two side lengths.</p><p>If one length is given then both sides will have that length. Setting one or more values to <code>Inf</code> gives no boundary in that dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L85-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.ReplicaExchangeLogger"><a class="docstring-binding" href="#Molly.ReplicaExchangeLogger"><code>Molly.ReplicaExchangeLogger</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ReplicaExchangeLogger(n_replicas)
ReplicaExchangeLogger(T, n_replicas)</code></pre><p>A logger that records exchanges in a replica exchange simulation.</p><p>The logged quantities include the number of exchange attempts (<code>n_attempts</code>), number of successful exchanges (<code>n_exchanges</code>), exchanged replica indices (<code>indices</code>), exchange steps (<code>steps</code>) and the value of Œî i.e. the argument of Metropolis rate for the exchanges (<code>deltas</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L980-L990">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.ReplicaSystem"><a class="docstring-binding" href="#Molly.ReplicaSystem"><code>Molly.ReplicaSystem</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ReplicaSystem(; &lt;keyword arguments&gt;)</code></pre><p>A wrapper for replicas in a replica exchange simulation.</p><p>Each individual replica is a <a href="#Molly.System"><code>System</code></a>. Properties unused in the simulation or in analysis can be left with their default values. The minimal required arguments are <code>atoms</code>, <code>replica_coords</code>, <code>boundary</code> and <code>n_replicas</code>. <code>atoms</code> and the elements in <code>replica_coords</code> should have the same length, along with <code>atoms_data</code> and the elements in <code>replica_velocities</code> if these are provided. The number of elements in <code>replica_coords</code>, <code>replica_boundaries</code>, <code>replica_velocities</code>, <code>replica_loggers</code> and the interaction arguments <code>replica_pairwise_inters</code>, <code>replica_specific_inter_lists</code>, <code>replica_general_inters</code> and <code>replica_constraints</code> should be equal to <code>n_replicas</code> if used. This is a sub-type of <code>AbstractSystem</code> from AtomsBase.jl and implements the interface described there.</p><p>When using <code>ReplicaSystem</code> with <a href="#Molly.CellListMapNeighborFinder"><code>CellListMapNeighborFinder</code></a>, the number of threads used for both the simulation of replicas and the neighbor finder should be set to be the same. This can be done by passing <code>nbatches=(min(n, 8), n)</code> to <a href="#Molly.CellListMapNeighborFinder"><code>CellListMapNeighborFinder</code></a> during construction where <code>n</code> is the number of threads to be used per replica.</p><p><strong>Arguments</strong></p><ul><li><code>atoms::A</code>: the atoms, or atom equivalents, in the system. Can be   of any type but should be a bits type if the GPU is used.</li><li><code>replica_coords</code>: the coordinates of the atoms in each replica.</li><li><code>n_replicas::Integer</code>: the number of replicas of the system.</li><li><code>boundary=nothing</code>: the bounding box in which the simulation takes place. This is only   used if no value is passed to the argument <code>replica_pairwise_inters</code>.</li><li><code>replica_boundaries=nothing</code>: the bounding box for each replica.</li><li><code>replica_velocities=[zero(replica_coords[1]) * u&quot;ps^-1&quot; for _ in 1:n_replicas]</code>:   the velocities of the atoms in each replica.</li><li><code>atoms_data::AD</code>: other data associated with the atoms, allowing the atoms to   be bits types and hence work on the GPU.</li><li><code>topology::TO=nothing</code>: topological information about the system such as which   atoms are in the same molecule (to be used if the same for all replicas).   This is only used if no value is passed to the argument <code>replica_topology</code>.</li><li><code>replica_topology=[nothing for _ in 1:n_replicas]</code>: the topological information for   each replica.</li><li><code>pairwise_inters=()</code>: the pairwise interactions in the system, i.e. interactions   between all or most atom pairs such as electrostatics (to be used if the same for all replicas).   Should be a <code>Tuple</code> or <code>NamedTuple</code> of <code>PairwiseInteraction</code>s. This is only used if no   value is passed to the argument <code>replica_pairwise_inters</code>.</li><li><code>replica_pairwise_inters=[() for _ in 1:n_replicas]</code>: the pairwise interactions for   each replica.</li><li><code>specific_inter_lists=()</code>: the specific interactions in the system, i.e. interactions   between specific atoms such as bonds or angles (to be used if the same for all replicas).   Should be a <code>Tuple</code> or <code>NamedTuple</code>. This is only used if no value is passed to the argument   <code>replica_specific_inter_lists</code>.</li><li><code>replica_specific_inter_lists=[() for _ in 1:n_replicas]</code>: the specific interactions in   each replica.</li><li><code>general_inters=()</code>: the general interactions in the system, i.e. interactions involving   all atoms such as implicit solvent (to be used if the same for all replicas). Each should   implement the AtomsCalculators.jl interface. Should be a <code>Tuple</code> or <code>NamedTuple</code>. This is   only used if no value is passed to the argument <code>replica_general_inters</code>.</li><li><code>replica_general_inters=[() for _ in 1:n_replicas]</code>: the general interactions for   each replica.</li><li><code>constraints::CN=()</code>: the constraints for bonds and angles in the system (to be used if the same   for all replicas). Should be a <code>Tuple</code> or <code>NamedTuple</code>. This is only used if no value is   passed to the argument <code>replica_constraints</code>.</li><li><code>replica_constraints=[() for _ in 1:n_replicas]</code>: the constraints for bonds and angles in each   replica.</li><li><code>virtual_sites::VS=[]</code>: the virtual sites present in the system (to be used if the same for all   replicas); these are mass-less particles determined by the positions of other atoms. This is   only used if no value is passed to the argument <code>replica_virtual_sites</code>.</li><li><code>replica_virtual_sites=[[] for _ in 1:n_replicas]</code>: the virtual_sites in each   replica.</li><li><code>neighbor_finder::NF=NoNeighborFinder()</code>: the neighbor finder used to find   close atoms and save on computation. It is duplicated for each replica.</li><li><code>replica_loggers=[() for _ in 1:n_replicas]</code>: the loggers for each replica   that record properties of interest during a simulation.</li><li><code>exchange_logger::EL=ReplicaExchangeLogger(n_replicas)</code>: the logger used to record   the exchange of replicas.</li><li><code>force_units::F=u&quot;kJ * mol^-1 * nm^-1&quot;</code>: the units of force of the system.   Should be set to <code>NoUnits</code> if units are not being used.</li><li><code>energy_units::E=u&quot;kJ * mol^-1&quot;</code>: the units of energy of the system. Should   be set to <code>NoUnits</code> if units are not being used.</li><li><code>k::K=Unitful.k</code> or <code>Unitful.k * Unitful.Na</code>: the Boltzmann constant, which may be   modified in some simulations. <code>k</code> is chosen based on the <code>energy_units</code> given.</li><li><code>data::DA=nothing</code>: arbitrary data associated with the replica system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L886-L966">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.SHAKE_RATTLE"><a class="docstring-binding" href="#Molly.SHAKE_RATTLE"><code>Molly.SHAKE_RATTLE</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SHAKE_RATTLE(n_atoms, dist_tolerance=1e-8u&quot;nm&quot;, vel_tolerance=1e-8u&quot;nm^2 * ps^-1&quot;;
             dist_constraints=nothing, angle_constraints=nothing,
             gpu_block_size=128, max_iters=25)</code></pre><p>Constrain distances during a simulation using the SHAKE and RATTLE algorithms. Either or both of <code>dist_constraints</code> and <code>angle_constraints</code> must be given.</p><p>Velocity constraints will be imposed for simulators that integrate velocities such as <a href="#Molly.VelocityVerlet"><code>VelocityVerlet</code></a>. See <a href="https://doi.org/10.1016/0021-9991(77)90098-5">Ryckaert et al. 1977</a> for SHAKE, <a href="https://doi.org/10.1016/0021-9991(83)90014-1">Andersen 1983</a> for RATTLE, <a href="https://doi.org/10.1140/epjst/e2011-01525-9">Elber et al. 2011</a> for a derivation of the linear system solved to satisfy the RATTLE algorithm, and <a href="https://doi.org/10.1002/1096-987X(20010415)22:5%3C501::AID-JCC1021%3E3.0.CO;2-V">Krautler et al. 2000</a> for the M-SHAKE algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>n_atoms</code>: number of atoms in the system.</li><li><code>dist_tolerance=1e-8u&quot;nm&quot;</code>: the tolerance used to end the iterative procedure when calculating   position constraints, should have the same units as the coordinates.</li><li><code>vel_tolerance=1e-8u&quot;nm^2 * ps^-1&quot;</code>: the tolerance used to end the iterative procedure when   calculating velocity constraints, should have the same units as the velocities times the   coordinates.</li><li><code>dist_constraints=nothing</code>: a vector of <a href="#Molly.DistanceConstraint"><code>DistanceConstraint</code></a> objects that define the   distance constraints to be applied. If <code>nothing</code>, no distance constraints are applied.</li><li><code>angle_constraints=nothing</code>: a vector of <a href="#Molly.AngleConstraint"><code>AngleConstraint</code></a> objects that define the   angle constraints to be applied. If <code>nothing</code>, no angle constraints are applied.</li><li><code>gpu_block_size=128</code>: the number of threads per block to use for GPU calculations.</li><li><code>max_iters=25</code>: the maximum number of iterations to perform when doing SHAKE. If this   number if iterations is reached, some constraints may not be satisfied.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/constraints/shake.jl#L3-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.ShiftedForceCutoff"><a class="docstring-binding" href="#Molly.ShiftedForceCutoff"><code>Molly.ShiftedForceCutoff</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ShiftedForceCutoff(dist_cutoff)</code></pre><p>Cutoff that shifts the force to be continuous at a specified cutoff distance.</p><p class="math-container">\[\begin{aligned}
V_c(r) &amp;= \begin{cases}
V(r) - (r-r_c) V&#39;(r_c) - V(r_c), r \le r_c \\
0, r &gt; r_c
\end{cases} \\
F_c(r) &amp;= \begin{cases}
F(r) - F(r_c), r \le r_c \\
0, r &gt; r_c
\end{cases}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/cutoffs.jl#L114-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.ShiftedPotentialCutoff"><a class="docstring-binding" href="#Molly.ShiftedPotentialCutoff"><code>Molly.ShiftedPotentialCutoff</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ShiftedPotentialCutoff(dist_cutoff)</code></pre><p>Cutoff that shifts the potential to be continuous at a specified cutoff distance.</p><p class="math-container">\[\begin{aligned}
V_c(r) &amp;= \begin{cases}
V(r) - V(r_c), r \le r_c \\
0, r &gt; r_c
\end{cases} \\
F_c(r) &amp;= \begin{cases}
F(r), r \le r_c \\
0, r &gt; r_c
\end{cases}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/cutoffs.jl#L80-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.SoftSphere"><a class="docstring-binding" href="#Molly.SoftSphere"><code>Molly.SoftSphere</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SoftSphere(; cutoff, use_neighbors, shortcut, œÉ_mixing, œµ_mixing)</code></pre><p>The soft-sphere potential.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = 4\varepsilon_{ij} \left(\frac{\sigma_{ij}}{r_{ij}}\right)^{12}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/soft_sphere.jl#L3-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.SpecificForce1Atoms"><a class="docstring-binding" href="#Molly.SpecificForce1Atoms"><code>Molly.SpecificForce1Atoms</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpecificForce1Atoms(f1)</code></pre><p>Force on one atom arising from an interaction such as a position restraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/force.jl#L72-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.SpecificForce2Atoms"><a class="docstring-binding" href="#Molly.SpecificForce2Atoms"><code>Molly.SpecificForce2Atoms</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpecificForce2Atoms(f1, f2)</code></pre><p>Forces on two atoms arising from an interaction such as a bond potential.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/force.jl#L81-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.SpecificForce3Atoms"><a class="docstring-binding" href="#Molly.SpecificForce3Atoms"><code>Molly.SpecificForce3Atoms</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpecificForce3Atoms(f1, f2, f3)</code></pre><p>Forces on three atoms arising from an interaction such as a bond angle potential.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/force.jl#L91-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.SpecificForce4Atoms"><a class="docstring-binding" href="#Molly.SpecificForce4Atoms"><code>Molly.SpecificForce4Atoms</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpecificForce4Atoms(f1, f2, f3, f4)</code></pre><p>Forces on four atoms arising from an interaction such as a torsion potential.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/force.jl#L102-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.SquareBias"><a class="docstring-binding" href="#Molly.SquareBias"><code>Molly.SquareBias</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SquareBias(k, cv_target)</code></pre><p>A square (harmonic) bias on a collective variable (CV) towards a target value.</p><p>The potential energy is defined as</p><p class="math-container">\[V(\boldsymbol{s}) = \frac{1}{2} k (\boldsymbol{s} - \boldsymbol{s}_t)^2\]</p><p>where <span>$s$</span> and <span>$s_t$</span> are the system and target CV values respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/bias/bias.jl#L34-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.SteepestDescentMinimizer"><a class="docstring-binding" href="#Molly.SteepestDescentMinimizer"><code>Molly.SteepestDescentMinimizer</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SteepestDescentMinimizer(; &lt;keyword arguments&gt;)</code></pre><p>Steepest descent energy minimization.</p><p><strong>Arguments</strong></p><ul><li><code>step_size::D=0.01u&quot;nm&quot;</code>: the initial maximum displacement.</li><li><code>max_steps::Int=1000</code>: the maximum number of steps.</li><li><code>tol::F=1000.0u&quot;kJ * mol^-1 * nm^-1&quot;</code>: the maximum force below which to   finish minimization.</li><li><code>log_stream::L=devnull</code>: stream to print minimization progress to.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L21-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.StormerVerlet"><a class="docstring-binding" href="#Molly.StormerVerlet"><code>Molly.StormerVerlet</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StormerVerlet(; &lt;keyword arguments&gt;)</code></pre><p>The St√∂rmer-Verlet integrator.</p><p>The velocity calculation is accurate to O(dt).</p><p>Does not currently work with coupling methods that alter the velocity. Does not currently remove the center of mass motion.</p><p><strong>Arguments</strong></p><ul><li><code>dt::T</code>: the time step of the simulation.</li><li><code>coupling::C=NoCoupling()</code>: the coupling which applies during the simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L290-L303">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.System"><a class="docstring-binding" href="#Molly.System"><code>Molly.System</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">System(; &lt;keyword arguments&gt;)</code></pre><p>A physical system to be simulated.</p><p>Properties unused in the simulation or in analysis can be left with their default values. The minimal required arguments are <code>atoms</code>, <code>coords</code> and <code>boundary</code>. <code>atoms</code> and <code>coords</code> should have the same length, along with <code>velocities</code> and <code>atoms_data</code> if these are provided. This is a sub-type of <code>AbstractSystem</code> from AtomsBase.jl and implements the interface described there.</p><p><strong>Arguments</strong></p><ul><li><code>atoms::A</code>: the atoms, or atom equivalents, in the system. Can be   of any type but should be a bits type if the GPU is used.</li><li><code>coords::C</code>: the coordinates of the atoms in the system. Typically a   vector of <code>SVector</code>s of 2 or 3 dimensions.</li><li><code>boundary::B</code>: the bounding box in which the simulation takes place.</li><li><code>velocities::V=zero(coords) * u&quot;ps^-1&quot;</code>: the velocities of the atoms in the   system.</li><li><code>atoms_data::AD=[]</code>: other data associated with the atoms, allowing the atoms to   be bits types and hence work on the GPU.</li><li><code>topology::TO=nothing</code>: topological information about the system such as which   atoms are in the same molecule.</li><li><code>pairwise_inters::PI=()</code>: the pairwise interactions in the system, i.e.   interactions between all or most atom pairs such as electrostatics.   Should be a <code>Tuple</code> or <code>NamedTuple</code> of <code>PairwiseInteraction</code>s.</li><li><code>specific_inter_lists::SI=()</code>: the specific interactions in the system,   i.e. interactions between specific atoms such as bonds or angles.   Should be a <code>Tuple</code> or <code>NamedTuple</code>.</li><li><code>general_inters::GI=()</code>: the general interactions in the system,   i.e. interactions involving all atoms such as implicit solvent. Each should   implement the AtomsCalculators.jl interface. Should be a <code>Tuple</code> or <code>NamedTuple</code>.</li><li><code>constraints::CN=()</code>: the constraints for bonds and angles in the system.   Should be a <code>Tuple</code> or <code>NamedTuple</code>.</li><li><code>virtual_sites::VS=[]</code>: the virtual sites present in the system; these are   mass-less particles determined by the positions of other atoms.</li><li><code>neighbor_finder::NF=NoNeighborFinder()</code>: the neighbor finder used to find   close atoms and save on computation.</li><li><code>loggers::L=()</code>: the loggers that record properties of interest during a   simulation.</li><li><code>force_units::F=u&quot;kJ * mol^-1 * nm^-1&quot;</code>: the units of force of the system.   Should be set to <code>NoUnits</code> if units are not being used.</li><li><code>energy_units::E=u&quot;kJ * mol^-1&quot;</code>: the units of energy of the system. Should   be set to <code>NoUnits</code> if units are not being used.</li><li><code>k::K=Unitful.k</code> or <code>Unitful.k * Unitful.Na</code>: the Boltzmann constant, which may be   modified in some simulations. <code>k</code> is chosen based on the <code>energy_units</code> given.</li><li><code>data::DA=nothing</code>: arbitrary data associated with the system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L470-L519">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.System-Tuple{System}"><a class="docstring-binding" href="#Molly.System-Tuple{System}"><code>Molly.System</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">System(sys; &lt;keyword arguments&gt;)</code></pre><p>Convenience constructor for changing properties in a <code>System</code>.</p><p>The <code>System</code> is returned with the provided keyword arguments modified. Give <code>deepcopy(sys)</code> as the argument to make a new copy of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L699-L706">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.System-Union{Tuple{AT}, Tuple{AbstractString, MolecularForceField}} where AT&lt;:AbstractArray"><a class="docstring-binding" href="#Molly.System-Union{Tuple{AT}, Tuple{AbstractString, MolecularForceField}} where AT&lt;:AbstractArray"><code>Molly.System</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">System(coordinate_file, force_field; &lt;keyword arguments&gt;)</code></pre><p>Read a coordinate file in a file format readable by Chemfiles and apply a force field to it.</p><p>Atom names should exactly match residue templates - no searching of residue templates is carried out.</p><pre><code class="language-julia hljs">System(coordinate_file, topology_file; &lt;keyword arguments&gt;)
System(T, coordinate_file, topology_file; &lt;keyword arguments&gt;)</code></pre><p>Read a Gromacs coordinate file and a Gromacs topology file with all includes collapsed into one file.</p><p>Gromacs file reading should be considered experimental.</p><p><strong>Arguments</strong></p><ul><li><code>boundary=nothing</code>: the bounding box used for simulation, read from the   file by default.</li><li><code>velocities=nothing</code>: the velocities of the atoms in the system, set to   zero by default.</li><li><code>loggers=()</code>: the loggers that record properties of interest during a   simulation.</li><li><code>units::Bool=true</code>: whether to use Unitful quantities.</li><li><code>array_type=Array</code>: the array type for the simulation, for example   use <code>CuArray</code> or <code>ROCArray</code> for GPU support.</li><li><code>dist_cutoff=1.0u&quot;nm&quot;</code>: cutoff distance for long-range interactions.</li><li><code>dist_buffer=0.2u&quot;nm&quot;</code>: distance added to <code>dist_cutoff</code> when calculating   neighbors every few steps. Not relevant if <a href="#Molly.GPUNeighborFinder"><code>GPUNeighborFinder</code></a> is   used since the neighbors are calculated each step.</li><li><code>constraints=:none</code>: which constraints to apply during the simulation, options   are <code>:none</code>, <code>:hbonds</code> (bonds involving hydrogen), <code>:allbonds</code> and <code>:hangles</code>   (all bonds plus H-X-H and H-O-X angles). Note that not all options may be   supported depending on the bonding topology.</li><li><code>rigid_water=false</code>: whether to constrain the bonds and angle in water   molecules. Applied on top of <code>constraints</code>, so <code>constraints=:hangles</code> and   <code>rigid_water=false</code> gives rigid water.</li><li><code>nonbonded_method=:none</code>: method for long range interaction summation,   options are <code>:none</code> (short range only), <code>:cutoff</code> (reaction field method),   <code>:pme</code> (particle mesh Ewald summation) and <code>:ewald</code> (Ewald summation, slow).</li><li><code>ewald_error_tol=0.0005</code>: the error tolerance for Ewald summation, used when   <code>nonbonded_method</code> is <code>:pme</code> or <code>:ewald</code>.</li><li><code>approximate_pme=true</code>: whether to use a fast approximation to the erfc   function, used when <code>nonbonded_method</code> is <code>:pme</code>.</li><li><code>center_coords::Bool=true</code>: whether to center the coordinates in the   simulation box.</li><li><code>neighbor_finder_type</code>: which neighbor finder to use, default is   <a href="#Molly.CellListMapNeighborFinder"><code>CellListMapNeighborFinder</code></a> on CPU, <a href="#Molly.GPUNeighborFinder"><code>GPUNeighborFinder</code></a>   on CUDA compatible GPUs and <a href="#Molly.DistanceNeighborFinder"><code>DistanceNeighborFinder</code></a> on non-CUDA   compatible GPUs.</li><li><code>data=nothing</code>: arbitrary data associated with the system.</li><li><code>implicit_solvent=:none</code>: the implicit solvent model to use, options are   <code>:none</code>, <code>:obc1</code>, <code>:obc2</code> and <code>:gbn2</code>.</li><li><code>kappa=0.0u&quot;nm^-1&quot;</code>: the kappa value for the implicit solvent model if one   is used.</li><li><code>disulfide_bonds=true</code>: whether or not to look for disulfide bonds between CYS   residues in the structure file and add them to the topology. Uses geometric   arguments to assign them.</li><li><code>grad_safe=false</code>: should be set to <code>true</code> if the system is going to be used   with Enzyme.jl and <code>nonbonded_method</code> is <code>:pme</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/setup.jl#L358-L419">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.System-Union{Tuple{AtomsBase.AbstractSystem{D}}, Tuple{D}} where D"><a class="docstring-binding" href="#Molly.System-Union{Tuple{AtomsBase.AbstractSystem{D}}, Tuple{D}} where D"><code>Molly.System</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">System(abstract_system; &lt;keyword arguments&gt;)</code></pre><p>Convert an AtomsBase <code>AbstractSystem</code> to a Molly <code>System</code>.</p><p>The keyword arguments <code>force_units</code> and <code>energy_units</code> should be set as appropriate. Other keyword arguments are the same as for the main <code>System</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L1343-L1350">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.System-Union{Tuple{SimpleCrystals.Crystal{D, A, B} where {A, B&lt;:(AbstractVector{&lt;:SimpleCrystals.Atom{D}})}}, Tuple{D}} where D"><a class="docstring-binding" href="#Molly.System-Union{Tuple{SimpleCrystals.Crystal{D, A, B} where {A, B&lt;:(AbstractVector{&lt;:SimpleCrystals.Atom{D}})}}, Tuple{D}} where D"><code>Molly.System</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">System(crystal; &lt;keyword arguments&gt;)</code></pre><p>Construct a <code>System</code> from a SimpleCrystals.jl <code>Crystal</code> struct.</p><p>Properties unused in the simulation or in analysis can be left with their default values. <code>atoms</code>, <code>atoms_data</code>, <code>coords</code> and <code>boundary</code> are automatically calculated from the <code>Crystal</code> struct. Extra atom paramaters like <code>œÉ</code> have to be added manually after construction using the convenience constructor <code>System(sys; &lt;keyword arguments&gt;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L746-L757">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.TemperatureREMD"><a class="docstring-binding" href="#Molly.TemperatureREMD"><code>Molly.TemperatureREMD</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TemperatureREMD(; &lt;keyword arguments&gt;)</code></pre><p>A simulator for a parallel temperature replica exchange MD (T-REMD) simulation on a <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a>.</p><p>See <a href="https://doi.org/10.1016/S0009-2614(99)01123-9">Sugita and Okamoto 1999</a>. The corresponding <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a> should have the same number of replicas as the number of temperatures in the simulator. When calling <a href="#Molly.simulate!-Tuple{Any, SteepestDescentMinimizer}"><code>simulate!</code></a>, the <code>assign_velocities</code> keyword argument determines whether to assign random velocities at the appropriate temperature for each replica.</p><p><strong>Arguments</strong></p><ul><li><code>dt::DT</code>: the time step of the simulation.</li><li><code>temperatures::TP</code>: the temperatures corresponding to the replicas.</li><li><code>simulators::ST</code>: individual simulators for simulating each replica.</li><li><code>exchange_time::ET</code>: the time interval between replica exchange attempts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L769-L786">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.ThermoState"><a class="docstring-binding" href="#Molly.ThermoState"><code>Molly.ThermoState</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ThermoState(name::AbstractString, Œ≤, p, system)
ThermoState(system::System, Œ≤, p; name::Union{Nothing, AbstractString}=nothing)</code></pre><p>Thermodynamic state wrapper carrying inverse temperature <code>Œ≤ = 1/kBT</code>, pressure <code>p</code>, and the <a href="#Molly.System"><code>System</code></a> used to evaluate energies.</p><p>Fields:</p><ul><li><code>name::String</code> - label for the state.</li><li><code>Œ≤</code> - inverse temperature with units compatible with <code>1/system.energy_units</code>.</li><li><code>p</code> - pressure <code>Quantity</code> or <code>nothing</code>.</li><li><code>system::System</code> - simulation system used to compute potential energy.</li></ul><p>The second constructor checks unit consistency for <code>Œ≤</code> and <code>p</code> and sets a default <code>name</code> when not provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/free_energy/mbar.jl#L11-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.TimeCorrelationLogger"><a class="docstring-binding" href="#Molly.TimeCorrelationLogger"><code>Molly.TimeCorrelationLogger</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TimeCorrelationLogger(observableA::Function, observableB::Function,
                        TA::DataType, TB::DataType,
                        observable_length::Integer, n_correlation::Integer)</code></pre><p>A time correlation logger.</p><p>Estimates statistical correlations of normalized form</p><p class="math-container">\[C(t)=\frac{\langle A_t\cdot B_0\rangle -\langle A\rangle\cdot \langle B\rangle}{\sqrt{\langle |A|^2\rangle\langle |B|^2\rangle}}\]</p><p>or unnormalized form</p><p class="math-container">\[C(t)=\langle A_t\cdot B_0\rangle -\langle A \rangle\cdot \langle B\rangle\]</p><p>These can be used to estimate statistical error, or to compute transport coefficients from Green-Kubo type formulas. <em>A</em> and <em>B</em> are observables, functions of the form <code>observable(sys::System, neighbors; n_threads::Integer)</code>. The return values of <em>A</em> and <em>B</em> can be of scalar or vector type (including <code>Vector{SVector{...}}</code>, like positions or velocities) and must implement <code>dot</code>.</p><p><code>n_correlation</code> should typically be chosen so that <code>dt * n_correlation &gt; t_corr</code>, where <code>dt</code> is the simulation timestep and <code>t_corr</code> is the decorrelation time for the considered system and observables. For the purpose of numerical stability, the logger internally records sums instead of running averages. The normalized and unnormalized form of the correlation function can be retrieved through <code>values(logger::TimeCorrelationLogger; normalize::Bool)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>observableA::Function</code>: the function corresponding to observable A.</li><li><code>observableB::Function</code>: the function corresponding to observable B.</li><li><code>TA::DataType</code>: the type returned by <code>observableA</code>, supporting <code>zero(TA)</code>.</li><li><code>TB::DataType</code>: the type returned by <code>observableB</code>, supporting <code>zero(TB)</code>.</li><li><code>observable_length::Integer</code>: the length of the observables if they are   vectors, or <code>1</code> if they are scalar-valued.</li><li><code>n_correlation::Integer</code>: the length of the computed correlation vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L749-L787">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.TrajectoryWriter"><a class="docstring-binding" href="#Molly.TrajectoryWriter"><code>Molly.TrajectoryWriter</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TrajectoryWriter(n_steps, filepath; format=&quot;&quot;, correction=:pbc, atom_inds=[],
                 excluded_res=String[], write_velocities=false, write_boundary=true)</code></pre><p>Write 3D structures to a file throughout a simulation.</p><p>Uses Chemfiles.jl to write to one of a variety of formats including DCD, XTC, PDB, CIF, MOL2, SDF, TRR and XYZ. The full list of file formats can be found in the <a href="https://chemfiles.org/chemfiles/latest/formats.html#list-of-supported-formats">Chemfiles docs</a>. By default the format is guessed from the file extension but it can also be given as a string, e.g. <code>format=&quot;DCD&quot;</code>. BioStructures.jl is used to write to the PDB format.</p><p>The atom indices to be written can be given as a list or range to <code>atom_inds</code>, with all atoms being written by default. Residue names to be excluded can be given as <code>excluded_res</code>. Velocities can be written in addition to coordinates by setting <code>write_velocities=true</code>. Chemfiles does not support writing velocities to all file formats. The correction to be applied to the molecules is chosen with <code>correction</code>. <code>:pbc</code>, the default, keeps molecules whole, whereas <code>:wrap</code> wraps all atoms inside the simulation box regardless of connectivity.</p><p>The <a href="#Molly.System"><code>System</code></a> should have <code>atoms_data</code> defined, and <code>topology</code> if bonding information is required. The file will be appended to, so should be deleted before simulation if it already exists.</p><p>Not compatible with 2D systems. For the PDB format, the box size for the CRYST1 record is taken from the first snapshot; different box sizes at later snapshots will not be recorded. The CRYST1 record is not written for infinite boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L647-L680">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.TreeNeighborFinder"><a class="docstring-binding" href="#Molly.TreeNeighborFinder"><code>Molly.TreeNeighborFinder</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TreeNeighborFinder(; eligible, dist_cutoff, special, n_steps)</code></pre><p>Find close atoms by distance using a tree search.</p><p>Can not be used if one or more dimensions has infinite boundaries. Can not be used with <a href="#Molly.TriclinicBoundary"><code>TriclinicBoundary</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/neighbors.jl#L194-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.TriclinicBoundary"><a class="docstring-binding" href="#Molly.TriclinicBoundary"><code>Molly.TriclinicBoundary</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TriclinicBoundary(v1, v2, v3; approx_images=true)
TriclinicBoundary(SVector(v1, v2, v3); approx_images=true)
TriclinicBoundary(SVector(l1, l2, l3), SVector(Œ±, Œ≤, Œ≥); approx_images=true)
TriclinicBoundary(arr; approx_images=true)</code></pre><p>Triclinic 3D bounding box defined by 3 <code>SVector{3}</code> basis vectors or basis vector lengths and angles Œ±/Œ≤/Œ≥ in radians.</p><p>The first basis vector must point along the x-axis and the second must lie in the xy plane. An approximation is used to find the closest periodic image when using the minimum image convention. The approximation is correct for distances shorter than half the shortest box height/width. Setting the keyword argument <code>approx_images</code> to <code>false</code> means the exact closest image is found, which is slower.</p><p>Not currently compatible with infinite boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L130-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.UreyBradley"><a class="docstring-binding" href="#Molly.UreyBradley"><code>Molly.UreyBradley</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UreyBradley(; kangle, Œ∏0, kbond, r0)</code></pre><p>An interaction between three atoms consisting of a harmonic bond angle and a harmonic bond between the outer atoms.</p><p><code>Œ∏0</code> is in radians. The second atom is the middle atom. The potential energy is defined as</p><p class="math-container">\[V(\theta, r) = \frac{1}{2} k_a (\theta - \theta_0)^2 + \frac{1}{2} k_b (r - r_0)^2\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/urey_bradley.jl#L3-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.VelocityRescaleThermostat"><a class="docstring-binding" href="#Molly.VelocityRescaleThermostat"><code>Molly.VelocityRescaleThermostat</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VelocityRescaleThermostat(temperature, coupling_const; n_steps=1)</code></pre><p>The stochastic velocity rescaling thermostat.</p><p>See <a href="https://doi.org/10.1063/1.2408420">Bussi et al. 2007</a>. In brief, acts like the <a href="#Molly.BerendsenThermostat"><code>BerendsenThermostat</code></a> but adds an stochastic term, allowing correct sampling of isothermal ensembles.</p><p>Let <code>Œît</code> be the simulation timestep, <code>Nf</code> the kinetic DOFs used to calculate the instantaneous temperature of the system. Then, <span>$K = \frac{1}{2} \cdot \sum m \cdot v^2$</span> is the current kinetic energy, and <span>$KÃÑ = \frac{1}{2} Nf k_B T_0$</span> is the target kinetic energy for a reference temperature <code>T_0</code>.</p><p>Define <span>$c = e^{-Œît/œÑ}$</span>. Draw <span>$R \sim ùí©(0,1)$</span> and <span>$S \sim \chi^{2}_{Nf-1}$</span>. Then</p><p class="math-container">\[\lambda^2 = c + (1-c) \cdot \frac{\bar K}{N_f K} \cdot (R^2 + S)\;+\;
            2 \cdot \sqrt{c(1-c) \frac{\bar K}{N_f K}} \cdot R,
\qquad v&#39; = \lambda\,v .\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/coupling.jl#L75-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.VelocityVerlet"><a class="docstring-binding" href="#Molly.VelocityVerlet"><code>Molly.VelocityVerlet</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VelocityVerlet(; &lt;keyword arguments&gt;)</code></pre><p>The velocity Verlet integrator.</p><p><strong>Arguments</strong></p><ul><li><code>dt::T</code>: the time step of the simulation.</li><li><code>coupling::C=NoCoupling()</code>: the coupling which applies during the simulation.</li><li><code>remove_CM_motion=1</code>: remove the center of mass motion every this number of steps,   set to <code>false</code> or <code>0</code> to not remove center of mass motion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L123-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.Verlet"><a class="docstring-binding" href="#Molly.Verlet"><code>Molly.Verlet</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Verlet(; &lt;keyword arguments&gt;)</code></pre><p>The leapfrog Verlet integrator.</p><p>This is a leapfrog integrator, so the velocities are offset by half a time step behind the positions.</p><p><strong>Arguments</strong></p><ul><li><code>dt::T</code>: the time step of the simulation.</li><li><code>coupling::C=NoCoupling()</code>: the coupling which applies during the simulation.</li><li><code>remove_CM_motion=1</code>: remove the center of mass motion every this number of steps,   set to <code>false</code> or <code>0</code> to not remove center of mass motion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L210-L223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.Yukawa"><a class="docstring-binding" href="#Molly.Yukawa"><code>Molly.Yukawa</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Yukawa(; cutoff, use_neighbors, weight_special, coulomb_const, kappa)</code></pre><p>The Yukawa electrostatic interaction between two atoms.</p><p>The potential energy is defined as</p><p class="math-container">\[V(r_{ij}) = \frac{q_i q_j}{4 \pi \varepsilon_0 r_{ij}} \exp(-\kappa r_{ij})\]</p><p>and the force on each atom by</p><p class="math-container">\[F(r_{ij}) = \frac{q_i q_j}{4 \pi \varepsilon_0 r_{ij}^2} \exp(-\kappa r_{ij})\left(\kappa r_{ij} + 1\right) \vec{r}_{ij}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/interactions/coulomb.jl#L631-L644">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.values-Tuple{GeneralObservableLogger}"><a class="docstring-binding" href="#Base.values-Tuple{GeneralObservableLogger}"><code>Base.values</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">values(logger)
values(logger::TimeCorrelationLogger; normalize::Bool=true)
values(logger::AverageObservableLogger; std::Bool=true)</code></pre><p>Access the stored observations in a logger.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L72-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.AutoCorrelationLogger-Tuple{Any, Any, Integer, Integer}"><a class="docstring-binding" href="#Molly.AutoCorrelationLogger-Tuple{Any, Any, Integer, Integer}"><code>Molly.AutoCorrelationLogger</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AutoCorrelationLogger(observable::Function, TA::DataType,
                        observable_length::Integer, n_correlation::Integer)</code></pre><p>An autocorrelation logger, equivalent to a <a href="#Molly.TimeCorrelationLogger"><code>TimeCorrelationLogger</code></a> in the case that <code>observableA == observableB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L834-L840">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.CoordinatesLogger-Tuple{Any, Integer}"><a class="docstring-binding" href="#Molly.CoordinatesLogger-Tuple{Any, Integer}"><code>Molly.CoordinatesLogger</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CoordinatesLogger(n_steps; dims=3)
CoordinatesLogger(T, n_steps; dims=3)</code></pre><p>Log the coordinates throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L125-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.DensityLogger-Tuple{Type, Integer}"><a class="docstring-binding" href="#Molly.DensityLogger-Tuple{Type, Integer}"><code>Molly.DensityLogger</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DensityLogger(n_steps)
DensityLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.density-Tuple{Any}"><code>density</code></a> of a system throughout a simulation.</p><p>Not compatible with infinite boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L288-L295">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.ForcesLogger-Tuple{Any, Integer}"><a class="docstring-binding" href="#Molly.ForcesLogger-Tuple{Any, Integer}"><code>Molly.ForcesLogger</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ForcesLogger(n_steps; dims=3)
ForcesLogger(T, n_steps; dims=3)</code></pre><p>Log the <a href="#Molly.forces-Tuple{Any}"><code>forces</code></a> throughout a simulation.</p><p>The forces are those from the interactions and do not include forces applied by stochastic simulators such as <a href="#Molly.Langevin"><code>Langevin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L243-L251">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.KineticEnergyLogger-Tuple{Type, Integer}"><a class="docstring-binding" href="#Molly.KineticEnergyLogger-Tuple{Type, Integer}"><code>Molly.KineticEnergyLogger</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">KineticEnergyLogger(n_steps)
KineticEnergyLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.kinetic_energy-Tuple{Any}"><code>kinetic_energy</code></a> of a system throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L173-L178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.OneParticleSite"><a class="docstring-binding" href="#Molly.OneParticleSite"><code>Molly.OneParticleSite</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">OneParticleSite(atom_ind, atom_1)</code></pre><p>A virtual site defined to have the same coordinates as another atom.</p><p>Returns a <code>VirtualSite</code> defined by:</p><p class="math-container">\[\mathbf{r} = \mathbf{r}_1\]</p><p>This can be useful in alchemical simulations when multiple versions of an atom are required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/virtual.jl#L38-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.OutOfPlaneSite-Union{Tuple{T}, Tuple{Integer, Integer, Integer, Integer, T, T, Any}} where T"><a class="docstring-binding" href="#Molly.OutOfPlaneSite-Union{Tuple{T}, Tuple{Integer, Integer, Integer, Integer, T, T, Any}} where T"><code>Molly.OutOfPlaneSite</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">OutOfPlaneSite(atom_ind, atom_1, atom_2, atom_3, weight_12, weight_13, weight_cross)</code></pre><p>A virtual site defined by the weighted average of the coordinates of three atoms and the cross product of their relative displacements.</p><p>Returns a <code>VirtualSite</code> defined by:</p><p class="math-container">\[\mathbf{r} = \mathbf{r}_1 + w_{12} \mathbf{r}_{12} + w_{13} \mathbf{r}_{13} + w_{\mathrm{cross}} (\mathbf{r}_{12} \times \mathbf{r}_{13})\]</p><p>Only compatible with 3D systems. Not currently compatible with virial calculation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/virtual.jl#L100-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.PotentialEnergyLogger-Tuple{Type, Integer}"><a class="docstring-binding" href="#Molly.PotentialEnergyLogger-Tuple{Type, Integer}"><code>Molly.PotentialEnergyLogger</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PotentialEnergyLogger(n_steps)
PotentialEnergyLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.potential_energy-Tuple{Any}"><code>potential_energy</code></a> of a system throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L199-L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.PressureLogger-Tuple{Type, Integer}"><a class="docstring-binding" href="#Molly.PressureLogger-Tuple{Type, Integer}"><code>Molly.PressureLogger</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PressureLogger(n_steps)
PressureLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.pressure-Tuple{Any}"><code>pressure</code></a> tensor of a system throughout a simulation.</p><p>This should only be used on 3-dimensional systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L357-L364">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.ScalarPressureLogger-Tuple{Type, Integer}"><a class="docstring-binding" href="#Molly.ScalarPressureLogger-Tuple{Type, Integer}"><code>Molly.ScalarPressureLogger</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ScalarPressureLogger(n_steps)
ScalarPressureLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.scalar_pressure-Tuple{Any}"><code>scalar_pressure</code></a> of a system throughout a simulation.</p><p>This should only be used on 3-dimensional systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L382-L389">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.ScalarVirialLogger-Tuple{Type, Integer}"><a class="docstring-binding" href="#Molly.ScalarVirialLogger-Tuple{Type, Integer}"><code>Molly.ScalarVirialLogger</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ScalarVirialLogger(n_steps)
ScalarVirialLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.scalar_virial-Tuple{Any}"><code>scalar_virial</code></a> tensor of a system throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L334-L339">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.TemperatureLogger-Tuple{DataType, Integer}"><a class="docstring-binding" href="#Molly.TemperatureLogger-Tuple{DataType, Integer}"><code>Molly.TemperatureLogger</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TemperatureLogger(n_steps)
TemperatureLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.temperature-Union{Tuple{System{D}}, Tuple{D}} where D"><code>temperature</code></a> throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L106-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.ThreeParticleAverageSite-Union{Tuple{T}, Tuple{Integer, Integer, Integer, Integer, T, T, T}, Tuple{Integer, Integer, Integer, Integer, T, T, T, Any}} where T"><a class="docstring-binding" href="#Molly.ThreeParticleAverageSite-Union{Tuple{T}, Tuple{Integer, Integer, Integer, Integer, T, T, T}, Tuple{Integer, Integer, Integer, Integer, T, T, T, Any}} where T"><code>Molly.ThreeParticleAverageSite</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ThreeParticleAverageSite(atom_ind, atom_1, atom_2, atom_3, weight_1, weight_2, weight_3)</code></pre><p>A virtual site defined by the weighted average of the coordinates of three atoms.</p><p>Returns a <code>VirtualSite</code> defined by:</p><p class="math-container">\[\mathbf{r} = w_1 \mathbf{r}_1 + w_2 \mathbf{r}_2 + w_3 \mathbf{r}_3\]</p><p>where <span>$w_1 + w_2 + w_3$</span> must equal 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/virtual.jl#L78-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.TotalEnergyLogger-Tuple{DataType, Any}"><a class="docstring-binding" href="#Molly.TotalEnergyLogger-Tuple{DataType, Any}"><code>Molly.TotalEnergyLogger</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TotalEnergyLogger(n_steps)
TotalEnergyLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.total_energy-Tuple{Any}"><code>total_energy</code></a> of a system throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L220-L225">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.TwoParticleAverageSite-Union{Tuple{T}, Tuple{Integer, Integer, Integer, T, T}, Tuple{Integer, Integer, Integer, T, T, Any}} where T"><a class="docstring-binding" href="#Molly.TwoParticleAverageSite-Union{Tuple{T}, Tuple{Integer, Integer, Integer, T, T}, Tuple{Integer, Integer, Integer, T, T, Any}} where T"><code>Molly.TwoParticleAverageSite</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TwoParticleAverageSite(atom_ind, atom_1, atom_2, weight_1, weight_2)</code></pre><p>A virtual site defined by the weighted average of the coordinates of two atoms.</p><p>Returns a <code>VirtualSite</code> defined by:</p><p class="math-container">\[\mathbf{r} = w_1 \mathbf{r}_1 + w_2 \mathbf{r}_2\]</p><p>where <span>$w_1 + w_2$</span> must equal 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/virtual.jl#L57-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.VelocitiesLogger-Tuple{Any, Integer}"><a class="docstring-binding" href="#Molly.VelocitiesLogger-Tuple{Any, Integer}"><code>Molly.VelocitiesLogger</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VelocitiesLogger(n_steps; dims=3)
VelocitiesLogger(T, n_steps; dims=3)</code></pre><p>Log the velocities throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L149-L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.VirialLogger-Tuple{Type, Integer}"><a class="docstring-binding" href="#Molly.VirialLogger-Tuple{Type, Integer}"><code>Molly.VirialLogger</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VirialLogger(n_steps)
VirialLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.virial-Tuple{Any}"><code>virial</code></a> tensor of a system throughout a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L312-L317">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.VolumeLogger-Tuple{Type, Integer}"><a class="docstring-binding" href="#Molly.VolumeLogger-Tuple{Type, Integer}"><code>Molly.VolumeLogger</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VolumeLogger(n_steps)
VolumeLogger(T, n_steps)</code></pre><p>Log the <a href="#Molly.volume-Tuple{Any}"><code>volume</code></a> of a system throughout a simulation.</p><p>Not compatible with infinite boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L270-L277">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.accelerations-Tuple{Any}"><a class="docstring-binding" href="#Molly.accelerations-Tuple{Any}"><code>Molly.accelerations</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">accelerations(system, neighbors=find_neighbors(system), step_n=0;
              n_threads=Threads.nthreads())</code></pre><p>Calculate the accelerations of all atoms in a system using the pairwise, specific and general interactions and Newton&#39;s second law of motion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/force.jl#L18-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.add_position_restraints-Union{Tuple{AT}, Tuple{System{&lt;:Any, AT}, Any}} where AT"><a class="docstring-binding" href="#Molly.add_position_restraints-Union{Tuple{AT}, Tuple{System{&lt;:Any, AT}, Any}} where AT"><code>Molly.add_position_restraints</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_position_restraints(sys, k; atom_selector=is_any_atom, restrain_coords=sys.coords)</code></pre><p>Return a copy of a <a href="#Molly.System"><code>System</code></a> with <a href="#Molly.HarmonicPositionRestraint"><code>HarmonicPositionRestraint</code></a>s added to restrain the atoms.</p><p>The force constant <code>k</code> can be a single value or an array of equal length to the number of atoms in the system. The <code>atom_selector</code> function takes in each atom and atom data and determines whether to restrain that atom. For example, <a href="#Molly.is_heavy_atom-Tuple{Any, Any}"><code>is_heavy_atom</code></a> means non-hydrogen atoms are restrained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/setup.jl#L1478-L1489">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.apply_coupling!-Tuple{Any, Any, Union{Tuple, NamedTuple}, Any, Any, Any}"><a class="docstring-binding" href="#Molly.apply_coupling!-Tuple{Any, Any, Union{Tuple, NamedTuple}, Any, Any, Any}"><code>Molly.apply_coupling!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_coupling!(system, buffers, coupling, simulator, neighbors=nothing, step_n=0;
                n_threads=Threads.nthreads(), rng=Random.default_rng())</code></pre><p>Apply a coupler to modify a simulation.</p><p>Returns whether the coupling has invalidated the currently stored forces, for example by changing the coordinates. This information is useful for some simulators. If <code>coupling</code> is a tuple or named tuple then each coupler will be applied in turn. Custom couplers should implement this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/coupling.jl#L14-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.apply_loggers!"><a class="docstring-binding" href="#Molly.apply_loggers!"><code>Molly.apply_loggers!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">apply_loggers!(system, buffers, neighbors=nothing, step_n=0, run_loggers=true;
               n_threads=Threads.nthreads(), kwargs...)</code></pre><p>Run the loggers associated with a system.</p><p><code>run_loggers</code> can be <code>true</code>, <code>false</code> or <code>:skipzero</code>, in which case the loggers are not run before the first step. Additional keyword arguments can be passed to the loggers if required. Ignored for gradient calculation during automatic differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L30-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.apply_position_constraints!-Tuple{Any, Any}"><a class="docstring-binding" href="#Molly.apply_position_constraints!-Tuple{Any, Any}"><code>Molly.apply_position_constraints!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_position_constraints!(sys, coord_storage)
apply_position_constraints!(sys, coord_storage, vel_storage, dt)</code></pre><p>Apply the coordinate constraints to the system.</p><p>If <code>vel_storage</code> and <code>dt</code> are provided then velocity constraints are applied as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/constraints/constraints.jl#L293-L300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.apply_velocity_constraints!-Tuple{Any}"><a class="docstring-binding" href="#Molly.apply_velocity_constraints!-Tuple{Any}"><code>Molly.apply_velocity_constraints!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_velocity_constraints!(sys)</code></pre><p>Apply the velocity constraints to the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/constraints/constraints.jl#L321-L325">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.array_type-Tuple{AT} where AT"><a class="docstring-binding" href="#Molly.array_type-Tuple{AT} where AT"><code>Molly.array_type</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">array_type(sys)
array_type(arr)</code></pre><p>The array type of a <a href="#Molly.System"><code>System</code></a>, <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a> or array, for example <code>Array</code> for systems on CPU or <code>CuArray</code> for systems on a NVIDIA GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L1183-L1189">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.assemble_mbar_inputs-Tuple{Any, Any, Vector{ThermoState}}"><a class="docstring-binding" href="#Molly.assemble_mbar_inputs-Tuple{Any, Any, Vector{ThermoState}}"><code>Molly.assemble_mbar_inputs</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assemble_mbar_inputs(coords_k, boundaries_k, states;
                     target_state=nothing, shift=false)</code></pre><p>Assemble the reduced potentials matrix <code>u</code> (size <code>N√óK</code>) for MBAR from per-window coordinates and boundaries.</p><p><strong>Arguments</strong></p><ul><li><code>coords_k::Vector{&lt;:Vector}</code> - subsampled coordinates for each window <code>k</code>.</li><li><code>boundaries_k::Vector{&lt;:Vector}</code> - subsampled boundaries for each window <code>k</code> (same lengths as <code>coords_k[k]</code>).</li><li><code>states::Vector{ThermoState}</code> - thermodynamic states for each window.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>target_state::Union{Nothing, ThermoState}</code> - if set, also compute <code>u_target</code> for that state.</li><li><code>shift::Bool=false</code> - if <code>true</code>, subtract per-frame row minima from <code>u</code> and return the <code>shifts</code>.</li></ul><p><strong>Returns</strong></p><p>MBARInput with:</p><ul><li><code>u::Matrix{Float64}</code> - <code>N√óK</code> reduced potentials.</li><li><code>u_target::Union{Vector{Float64}, Nothing}</code> - reduced potential at <code>target_state</code> or <code>nothing</code>.</li><li><code>N::Vector{Int}</code> - sample counts per window.</li><li><code>win_of::Vector{Int}</code> - window index for each frame.</li><li><code>shifts::Union{Vector{Float64},Nothing}</code> - per-frame shifts when <code>shift=true</code>, else <code>nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/free_energy/mbar.jl#L71-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.bond_angle-NTuple{4, Any}"><a class="docstring-binding" href="#Molly.bond_angle-NTuple{4, Any}"><code>Molly.bond_angle</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bond_angle(coord_i, coord_j, coord_k, boundary)
bond_angle(vec_ji, vec_jk)</code></pre><p>Calculate the bond or pseudo-bond angle in radians between three coordinates or two vectors.</p><p>The angle between j‚Üíi and j‚Üík is returned in the range 0 to œÄ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L865-L873">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.box_center-Tuple{Union{CubicBoundary, RectangularBoundary}}"><a class="docstring-binding" href="#Molly.box_center-Tuple{Union{CubicBoundary, RectangularBoundary}}"><code>Molly.box_center</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">box_center(boundary)</code></pre><p>Calculate the center of a bounding box.</p><p>Dimensions with infinite length return zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L410-L416">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.calculate_cv-Tuple{CalcDist, Any, Any, Any, Vararg{Any}}"><a class="docstring-binding" href="#Molly.calculate_cv-Tuple{CalcDist, Any, Any, Any, Vararg{Any}}"><code>Molly.calculate_cv</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_cv(cv, coords, atoms, boundary, velocities; kwargs...)</code></pre><p>Calculate the value of a collective variable (CV) with the current system state.</p><p>New CV types should implement this function. This function does not apply the molecule correction over the boundaries; if required, <code>coords</code> can be obtained from <code>unwrap_molecules</code> first. The gradient of this function with respect to coordinates, used to calculate forces, is by default calculated with automatic differentiation when Enzyme is imported. Alternatively, the <code>cv_gradient</code> function can be defined for a new CV type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/bias/cv.jl#L196-L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.charge-Tuple{Any}"><a class="docstring-binding" href="#Molly.charge-Tuple{Any}"><code>Molly.charge</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">charge(atom)</code></pre><p>The partial charge of an <a href="#Molly.Atom"><code>Atom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L283-L287">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.charges-Tuple{Union{ReplicaSystem, System}}"><a class="docstring-binding" href="#Molly.charges-Tuple{Union{ReplicaSystem, System}}"><code>Molly.charges</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">charges(sys)</code></pre><p>The partial charges of the atoms in a <a href="#Molly.System"><code>System</code></a> or <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L1219-L1223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.check_constraints-Tuple{Any}"><a class="docstring-binding" href="#Molly.check_constraints-Tuple{Any}"><code>Molly.check_constraints</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_constraints(sys)
check_constraints(sys, constraints)</code></pre><p>Check whether the coordinates and velocities of a system satisfy the coordinate and velocity constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/constraints/constraints.jl#L432-L438">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.check_position_constraints-Tuple{Any}"><a class="docstring-binding" href="#Molly.check_position_constraints-Tuple{Any}"><code>Molly.check_position_constraints</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_position_constraints(sys)
check_position_constraints(sys, constraints)</code></pre><p>Check whether the coordinates of a system satisfy the position constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/constraints/constraints.jl#L367-L372">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.check_velocity_constraints-Tuple{Any}"><a class="docstring-binding" href="#Molly.check_velocity_constraints-Tuple{Any}"><code>Molly.check_velocity_constraints</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_velocity_constraints(sys)
check_velocity_constraints(sys, constraints)</code></pre><p>Check whether the velocities of a system satisfy the velocity constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/constraints/constraints.jl#L399-L404">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.density-Tuple{Any}"><a class="docstring-binding" href="#Molly.density-Tuple{Any}"><code>Molly.density</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">density(sys)</code></pre><p>The density of a <a href="#Molly.System"><code>System</code></a>.</p><p>Returns zero density for infinite boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L388-L394">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.dipole_moment-Tuple{Any}"><a class="docstring-binding" href="#Molly.dipole_moment-Tuple{Any}"><code>Molly.dipole_moment</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dipole_moment(sys)</code></pre><p>The dipole moment Œº of a system.</p><p>Requires the charges on the atoms to be set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L1250-L1256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.displacements-Tuple{Any, Any}"><a class="docstring-binding" href="#Molly.displacements-Tuple{Any, Any}"><code>Molly.displacements</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">displacements(coords, boundary)</code></pre><p>Calculate the pairwise vector displacements of a set of coordinates, accounting for the periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/analysis.jl#L12-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.distances-Tuple{Any, Any}"><a class="docstring-binding" href="#Molly.distances-Tuple{Any, Any}"><code>Molly.distances</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">distances(coords, boundary)</code></pre><p>Calculate the pairwise distances of a set of coordinates, accounting for the periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/analysis.jl#L26-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.find_neighbors-Tuple{System}"><a class="docstring-binding" href="#Molly.find_neighbors-Tuple{System}"><code>Molly.find_neighbors</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_neighbors(system; n_threads=Threads.nthreads())
find_neighbors(system, neighbor_finder, current_neighbors=nothing, step_n=0,
               force_recompute=false; n_threads=Threads.nthreads())</code></pre><p>Obtain a list of close atoms in a <a href="#Molly.System"><code>System</code></a>.</p><p>Custom neighbor finders should implement this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/neighbors.jl#L33-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.float_type-Union{Tuple{Union{ReplicaSystem{&lt;:Any, &lt;:Any, T}, System{&lt;:Any, &lt;:Any, T}}}, Tuple{T}} where T"><a class="docstring-binding" href="#Molly.float_type-Union{Tuple{Union{ReplicaSystem{&lt;:Any, &lt;:Any, T}, System{&lt;:Any, &lt;:Any, T}}}, Tuple{T}} where T"><code>Molly.float_type</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">float_type(sys)
float_type(boundary)</code></pre><p>The float type a <a href="#Molly.System"><code>System</code></a>, <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a> or bounding box uses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L1203-L1208">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.force"><a class="docstring-binding" href="#Molly.force"><code>Molly.force</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">force(inter, vec_ij, atom_i, atom_j, force_units, special, coord_i, coord_j,
      boundary, velocity_i, velocity_j, step_n)
force(inter, coord_i, boundary, atom_i, force_units, velocity_i, step_n)
force(inter, coord_i, coord_j, boundary, atom_i, atom_j, force_units, velocity_i,
      velocity_j, step_n)
force(inter, coord_i, coord_j, coord_k, boundary, atom_i, atom_j, atom_k,
      force_units, velocity_i, velocity_j, velocity_k, step_n)
force(inter, coord_i, coord_j, coord_k, coord_l, boundary, atom_i, atom_j, atom_k,
      atom_l, force_units, velocity_i, velocity_j, velocity_k, velocity_l, step_n)</code></pre><p>Calculate the force between atoms due to a given interaction type.</p><p>For pairwise interactions returns a single force vector and for specific interactions returns a type such as <a href="#Molly.SpecificForce2Atoms"><code>SpecificForce2Atoms</code></a>. Custom pairwise and specific interaction types should implement this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/force.jl#L34-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.forces-Tuple{Any}"><a class="docstring-binding" href="#Molly.forces-Tuple{Any}"><code>Molly.forces</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forces(system, neighbors=find_neighbors(system), step_n=0;
       n_threads=Threads.nthreads())</code></pre><p>Calculate the forces on all atoms in a system using the pairwise, specific and general interactions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/force.jl#L218-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.forces_virial-Tuple{Any}"><a class="docstring-binding" href="#Molly.forces_virial-Tuple{Any}"><code>Molly.forces_virial</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forces_virial(system, neighbors=find_neighbors(system), step_n=0;
              n_threads=Threads.nthreads())</code></pre><p>Calculate the forces on all atoms in a system and the virial using the pairwise, specific and general interactions.</p><p>Returns a tuple of the forces and the virial. This is faster than calling <a href="#Molly.forces-Tuple{Any}"><code>forces</code></a> and <a href="#Molly.virial-Tuple{Any}"><code>virial</code></a> separately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/force.jl#L236-L245">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.hydrodynamic_radius-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{SVector{D, T}}, Any}} where {D, T}"><a class="docstring-binding" href="#Molly.hydrodynamic_radius-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{SVector{D, T}}, Any}} where {D, T}"><code>Molly.hydrodynamic_radius</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hydrodynamic_radius(coords, boundary)</code></pre><p>Calculate the hydrodynamic radius of a set of coordinates.</p><p><span>$R_{hyd}$</span> is defined by</p><p class="math-container">\[\frac{1}{R_{hyd}} = \frac{1}{2N^2}\sum_{i \neq j} \frac{1}{r_{ij}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/analysis.jl#L106-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.is_any_atom-Tuple{Any, Any}"><a class="docstring-binding" href="#Molly.is_any_atom-Tuple{Any, Any}"><code>Molly.is_any_atom</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_any_atom(at, at_data)</code></pre><p>Placeholder function that returns <code>true</code>, used to select any <a href="#Molly.Atom"><code>Atom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/setup.jl#L1458-L1462">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.is_heavy_atom-Tuple{Any, Any}"><a class="docstring-binding" href="#Molly.is_heavy_atom-Tuple{Any, Any}"><code>Molly.is_heavy_atom</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_heavy_atom(at, at_data)</code></pre><p>Determines whether an <a href="#Molly.Atom"><code>Atom</code></a> is a heavy atom, i.e. any element other than hydrogen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/setup.jl#L1465-L1469">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.is_on_gpu-Union{Tuple{Union{ReplicaSystem{&lt;:Any, AT}, System{&lt;:Any, AT}, AT}}, Tuple{AT}} where AT"><a class="docstring-binding" href="#Molly.is_on_gpu-Union{Tuple{Union{ReplicaSystem{&lt;:Any, AT}, System{&lt;:Any, AT}, AT}}, Tuple{AT}} where AT"><code>Molly.is_on_gpu</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_on_gpu(sys)
is_on_gpu(arr)</code></pre><p>Whether a <a href="#Molly.System"><code>System</code></a>, <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a> or array type is on the GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L1193-L1198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.iterate_mbar-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Molly.iterate_mbar-Tuple{Any, Any, Any}"><code>Molly.iterate_mbar</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iterate_mbar(u, win_of, N_counts; rtol=1e-8, max_iter=10_000)</code></pre><p>Solve the MBAR self-consistent equations, see <a href="https://doi.org/10.1063/1.2978177">Shirts and Chodera 2008</a> Eq C3.</p><p><strong>Arguments</strong></p><ul><li><code>u::AbstractMatrix</code> - <code>N√óK</code> reduced potentials (<code>rows = frames</code>, <code>cols = states</code>).</li><li><code>win_of::AbstractVector</code> - length-<code>N</code> vector giving the generating state index per frame.</li><li><code>N_counts::AbstractVector</code> - length-<code>K</code> sample counts per state.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>rtol::Float64=1e-8</code> - relative convergence tolerance.</li><li><code>max_iter::Int=10_000</code> - maximum iterations.</li></ul><p><strong>Returns</strong></p><ul><li><code>f::Vector{Float64}</code> - relative free energies per state (gauge-fixed to <code>f[1]=0</code>).</li><li><code>logN::Vector{Float64}</code> - <code>log.(N_counts)</code> for reuse downstream.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/free_energy/mbar.jl#L302-L320">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.kinetic_energy-Tuple{Any}"><a class="docstring-binding" href="#Molly.kinetic_energy-Tuple{Any}"><code>Molly.kinetic_energy</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kinetic_energy(system; kin_tensor=nothing)</code></pre><p>Calculate the kinetic energy of a system.</p><p>The scalar kinetic energy is defined as</p><p class="math-container">\[K = \rm{Tr}\left[ \bf{K} \right]\]</p><p>where <span>$\bf{K}$</span> is the kinetic energy tensor:</p><p class="math-container">\[\bf{K} = \frac{1}{2} \sum_{i} m_i \bf{v_i} \otimes \bf{v_i}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/energy.jl#L58-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.kinetic_energy_tensor-Union{Tuple{System{D}}, Tuple{D}} where D"><a class="docstring-binding" href="#Molly.kinetic_energy_tensor-Union{Tuple{System{D}}, Tuple{D}} where D"><code>Molly.kinetic_energy_tensor</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kinetic_energy_tensor(system; kin_tensor=nothing)</code></pre><p>Calculate the kinetic energy of a system in its tensorial form.</p><p>The kinetic energy tensor is defined as</p><p class="math-container">\[bf{K} = \frac{1}{2} \sum_{i} m_i \bf{v_i} \otimes \bf{v_i}\]</p><p>where <span>$m_i$</span> is the mass and <span>$\bf{v_i}$</span> is the velocity vector of atom <span>$i$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/energy.jl#L27-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.log_property!"><a class="docstring-binding" href="#Molly.log_property!"><code>Molly.log_property!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">log_property!(logger, system, buffers, neighbors=nothing, step_n=0;
              n_threads=Threads.nthreads(), kwargs...)</code></pre><p>Log a property of a system throughout a simulation.</p><p>Custom loggers should implement this function. Additional keyword arguments can be passed to the logger if required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L81-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.mass-Tuple{Any}"><a class="docstring-binding" href="#Molly.mass-Tuple{Any}"><code>Molly.mass</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mass(atom)</code></pre><p>The mass of an <a href="#Molly.Atom"><code>Atom</code></a>.</p><p>Custom atom types should implement this function unless they have a <code>mass</code> field defined, which the function accesses by default. Virtual sites should have zero mass, and non-virtual sites should have non-zero mass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L290-L298">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.masses-Tuple{System}"><a class="docstring-binding" href="#Molly.masses-Tuple{System}"><code>Molly.masses</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">masses(sys)</code></pre><p>The masses of the atoms in a <a href="#Molly.System"><code>System</code></a> or <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/types.jl#L1211-L1215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.maxwell_boltzmann"><a class="docstring-binding" href="#Molly.maxwell_boltzmann"><code>Molly.maxwell_boltzmann</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">maxwell_boltzmann(atom_mass::Unitful.Mass, temp::Unitful.Temperature,
                  k::BoltzmannConstUnits=Unitful.k; rng=Random.default_rng())
maxwell_boltzmann(atom_mass::MolarMass, temp::Unitful.Temperature,
                  k_molar::MolarBoltzmannConstUnits=(Unitful.k * Unitful.Na);
                  rng=Random.default_rng())
maxwell_boltzmann(atom_mass::Real, temperature::Real,
                  k::Real=ustrip(u&quot;u * nm^2 * ps^-2 * K^-1&quot;, Unitful.k);
                  rng=Random.default_rng())</code></pre><p>Generate a random velocity along one dimension from the Maxwell-Boltzmann distribution, with optional custom Boltzmann constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L786-L798">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.mbar_weights-Tuple{AbstractMatrix, Vararg{AbstractVector, 4}}"><a class="docstring-binding" href="#Molly.mbar_weights-Tuple{AbstractMatrix, Vararg{AbstractVector, 4}}"><code>Molly.mbar_weights</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mbar_weights(u, u_target, f, N_counts, logN; shifts=nothing, check=true)</code></pre><p>Compute MBAR weights for sampled states and for a target state, see <a href="https://doi.org/10.1063/1.2978177">Shirts and Chodera 2008</a> Eq 13.</p><p><strong>Arguments</strong></p><ul><li><code>u::AbstractMatrix</code> - <code>N√óK</code> reduced potentials for sampled states.</li><li><code>u_target::AbstractVector</code> - length-<code>N</code> reduced potential for the target state.</li><li><code>f::AbstractVector</code> - length-<code>K</code> relative free energies.</li><li><code>N_counts::AbstractVector</code> - length-<code>K</code> sample counts per state.</li><li><code>logN::AbstractVector</code> - <code>log.(N_counts)</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>shifts::Union{Nothing, AbstractVector}=nothing</code> - per-frame shifts previously   subtracted from <code>u</code>, if any.</li><li><code>check::Bool=true</code> - perform basic normalization checks.</li></ul><p><strong>Returns</strong></p><ul><li><code>W::Matrix{Float64}</code> - <code>N√óK</code> sampled-state weights.</li><li><code>w_target::Vector{Float64}</code> - length-<code>N</code> target-state weights.</li><li><code>logD::Vector{Float64}</code> - length-<code>N</code> log normalizers used in the weights.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/free_energy/mbar.jl#L460-L482">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.mbar_weights-Tuple{Molly.MBARInput}"><a class="docstring-binding" href="#Molly.mbar_weights-Tuple{Molly.MBARInput}"><code>Molly.mbar_weights</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mbar_weights(mbar_generator::MBARInput)</code></pre><p>High-level MBAR wrapper that computes free energies and reweighting weights from a pre-assembled <code>MBARInput</code> struct.</p><p><strong>Arguments</strong></p><p><code>mbar_generator::MBARInput</code> - result from <a href="#Molly.assemble_mbar_inputs-Tuple{Any, Any, Vector{ThermoState}}"><code>assemble_mbar_inputs</code></a> containing:</p><ul><li><code>u::AbstractMatrix</code> - reduced potentials (<code>N√óK</code>).</li><li><code>u_target::Union{AbstractVector, Nothing}</code> - reduced potentials at the target state.</li><li><code>N::AbstractVector</code> - sample counts per state.</li><li><code>win_of::AbstractVector</code> - window index for each frame.</li><li><code>shifts::Union{AbstractVector,Nothing}</code> - per-frame energy shifts (optional).</li></ul><p><strong>Returns</strong></p><p><code>(W, w_target, logD)</code> where:</p><ul><li><code>W::Matrix{Float64}</code> - <code>N√óK</code> sampled-state weights.</li><li><code>w_target::Vector{Float64}</code> - target-state weights.</li><li><code>logD::Vector{Float64}</code> - per-frame log normalizers.</li></ul><p>This routine runs <a href="#Molly.iterate_mbar-Tuple{Any, Any, Any}"><code>iterate_mbar</code></a> to obtain relative free energies <code>F_k</code> and then calls the lower-level <code>mbar_weights(u, u_target, f, N_counts, logN)</code> using the contents of <code>mbar_generator</code>. All internal consistency checks are disabled for speed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/free_energy/mbar.jl#L537-L561">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.pairwise_force"><a class="docstring-binding" href="#Molly.pairwise_force"><code>Molly.pairwise_force</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pairwise_force(inter, r, params)</code></pre><p>Calculate the force magnitude between two atoms separated by distance <code>r</code> due to a pairwise interaction.</p><p>This function is used in <a href="#Molly.force"><code>force</code></a> to apply cutoff strategies by calculating the force at different values of <code>r</code>. Consequently, the parameters <code>params</code> should not include terms that depend on distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/force.jl#L60-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.pairwise_pe"><a class="docstring-binding" href="#Molly.pairwise_pe"><code>Molly.pairwise_pe</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pairwise_pe(inter, r, params)</code></pre><p>Calculate the potential energy between two atoms separated by distance <code>r</code> due to a pairwise interaction.</p><p>This function is used in <a href="#Molly.potential_energy-Tuple{Any}"><code>potential_energy</code></a> to apply cutoff strategies by calculating the potential energy at different values of <code>r</code>. Consequently, the parameters <code>params</code> should not include terms that depend on distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/energy.jl#L396-L405">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.place_atoms-Tuple{Integer, Any}"><a class="docstring-binding" href="#Molly.place_atoms-Tuple{Integer, Any}"><code>Molly.place_atoms</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">place_atoms(n_atoms, boundary; min_dist=nothing, max_attempts=100, rng=Random.default_rng())</code></pre><p>Generate random coordinates.</p><p>Obtain <code>n_atoms</code> coordinates in bounding box <code>boundary</code> where no two points are closer than <code>min_dist</code>, accounting for periodic boundary conditions. The keyword argument <code>max_attempts</code> determines the number of failed tries after which to stop placing atoms. Can not be used if one or more dimensions has infinite boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/setup.jl#L12-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.place_diatomics-Tuple{Integer, Any, Any}"><a class="docstring-binding" href="#Molly.place_diatomics-Tuple{Integer, Any, Any}"><code>Molly.place_diatomics</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">place_diatomics(n_molecules, boundary, bond_length; min_dist=nothing,
                max_attempts=100, aligned=false, rng=Random.default_rng())</code></pre><p>Generate random diatomic molecule coordinates.</p><p>Obtain coordinates for <code>n_molecules</code> diatomics in bounding box <code>boundary</code> where no two points are closer than <code>min_dist</code> and the bond length is <code>bond_length</code>, accounting for periodic boundary conditions. The keyword argument <code>max_attempts</code> determines the number of failed tries after which to stop placing atoms. The keyword argument <code>aligned</code> determines whether the bonds all point the same direction (<code>true</code>) or random directions (<code>false</code>). Can not be used if one or more dimensions has infinite boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/setup.jl#L62-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.place_virtual_sites!"><a class="docstring-binding" href="#Molly.place_virtual_sites!"><code>Molly.place_virtual_sites!</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">place_virtual_sites!(sys, virtual_sites=sys.virtual_sites)</code></pre><p>Set the coordinates of virtual sites based on the coordinates of the atoms that define them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/virtual.jl#L179-L183">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.pmf_with_uncertainty-Tuple{AbstractMatrix, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Vector}"><a class="docstring-binding" href="#Molly.pmf_with_uncertainty-Tuple{AbstractMatrix, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Vector}"><code>Molly.pmf_with_uncertainty</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pmf_with_uncertainty(u, u_target, f, N_counts, logN, R_k;
                     shifts=nothing, nbins=nothing, edges=nothing, kBT=nothing,
                     zero=:min, rmin=nothing, rmax=nothing)</code></pre><p>Estimate a 1D PMF along a scalar CV and its large-sample uncertainty using MBAR, see <a href="https://doi.org/10.1063/1.2978177">Shirts and Chodera 2008</a> Eq D8.</p><p><strong>Arguments</strong></p><ul><li><code>u::AbstractMatrix</code> - <code>N√óK</code> reduced potentials.</li><li><code>u_target::AbstractVector</code> - length-<code>N</code> reduced potentials at the target state.</li><li><code>f::AbstractVector</code> - length-<code>K</code> relative free energies.</li><li><code>N_counts::AbstractVector</code> - length-<code>K</code> sample counts.</li><li><code>logN::AbstractVector</code> - <code>log.(N_counts)</code>.</li><li><code>R_k::Vector{&lt;:AbstractVector}</code> - CV values per window, concatenating to length <code>N</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>shifts=nothing</code> - per-frame shifts used on <code>u</code>, if any.</li><li><code>nbins=nothing</code>, <code>edges=nothing</code> - bin count or explicit bin edges.</li><li><code>rmin=nothing</code>, <code>rmax=nothing</code> - bounds when <code>edges</code> is omitted.</li><li><code>zero=:min</code> - PMF gauge: <code>:min</code> or <code>:last</code>.</li><li><code>kBT=nothing</code> - if set, also return dimensional <code>F_energy = F*kBT</code>.</li></ul><p><strong>Returns</strong></p><p><code>PMF</code> struct with:</p><ul><li><code>centers</code> - the center of the histogram bins used to sample the CV.</li><li><code>widths</code> - the width of the histogram bins used to sample the CV.</li><li><code>edges</code> - the edges of the histogram bins used to sample the CV.</li><li><code>F</code> - PMF in kBT units.</li><li><code>F_energy</code> - PMF in energy units, if provided.</li><li><code>sigma_F</code> - uncertainty of the PMF in kBT units.</li><li><code>sigma_F_energy</code> - uncertainty of the PMF in energy units, if provided.</li><li><code>p</code> - probability density along the CV.</li><li><code>var_p</code> - variance of the probability density along the CV.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/free_energy/mbar.jl#L588-L622">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.pmf_with_uncertainty-Tuple{AbstractVector, AbstractVector, Vector{ThermoState}, ThermoState, AbstractVector}"><a class="docstring-binding" href="#Molly.pmf_with_uncertainty-Tuple{AbstractVector, AbstractVector, Vector{ThermoState}, ThermoState, AbstractVector}"><code>Molly.pmf_with_uncertainty</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pmf_with_uncertainty(coords_k, boundaries_k, states, target_state, CV;
                     shift=false)</code></pre><p>High-level PMF wrapper that builds MBAR inputs from trajectories, solves MBAR, and computes the PMF along <code>CV</code>.</p><p><strong>Arguments</strong></p><ul><li><code>coords_k::AbstractVector</code> - coordinates per window.</li><li><code>boundaries_k::AbstractVector</code> - boundaries per window.</li><li><code>states::Vector{ThermoState}</code> - thermodynamic states per window.</li><li><code>target_state::ThermoState</code> - state to reweight to.</li><li><code>CV::AbstractVector</code> - CV values per window.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>shift::Bool=false</code> - subtract per-frame minima from <code>u</code> for stability.</li></ul><p><strong>Returns</strong></p><p>Same <code>PMF</code> struct as the lower-level <code>pmf_with_uncertainty</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/free_energy/mbar.jl#L806-L825">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.potential_energy-Tuple{Any}"><a class="docstring-binding" href="#Molly.potential_energy-Tuple{Any}"><code>Molly.potential_energy</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">potential_energy(system, neighbors=find_neighbors(system), step_n=0;
                 n_threads=Threads.nthreads())</code></pre><p>Calculate the potential energy of a system using the pairwise, specific and general interactions.</p><pre><code class="language-julia hljs">potential_energy(inter, vec_ij, atom_i, atom_j, energy_units, special, coord_i, coord_j,
                 boundary, velocity_i, velocity_j, step_n)
potential_energy(inter, coord_i, boundary, atom_i, energy_units, velocity_i, step_n)
potential_energy(inter, coord_i, coord_j, boundary, atom_i, atom_j, energy_units,
                 velocity_i, velocity_j, step_n)
potential_energy(inter, coord_i, coord_j, coord_k, boundary, atom_i, atom_j, atom_k,
                 energy_units, velocity_i, velocity_j, velocity_k, step_n)
potential_energy(inter, coord_i, coord_j, coord_k, coord_l, boundary, atom_i, atom_j,
                 atom_k, atom_l, energy_units, velocity_i, velocity_j, velocity_k,
                 velocity_l, step_n)
potential_energy(bias_pot, cv; kwargs...)</code></pre><p>Calculate the potential energy due to a given interaction type.</p><p>Custom interaction types should implement this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/energy.jl#L148-L170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.pressure-Tuple{Any}"><a class="docstring-binding" href="#Molly.pressure-Tuple{Any}"><code>Molly.pressure</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pressure(system, neighbors=find_neighbors(system), step_n=0, buffers=nothing;
         recompute=true, n_threads=Threads.nthreads())</code></pre><p>Calculate the pressure tensor of the system.</p><p>The pressure is defined as</p><p class="math-container">\[\bf{P} = \frac{ 2 \cdot \bf{K} + \bf{W} }{V}\]</p><p>where <span>$V$</span> is the system volume, <span>$\bf{K}$</span> is the kinetic energy tensor and <span>$\bf{W}$</span> is the virial tensor.</p><p>To calculate the scalar pressure, see <a href="#Molly.scalar_pressure-Tuple{Any}"><code>scalar_pressure</code></a>.</p><p>Not compatible with infinite boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L941-L957">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.radius_gyration-Tuple{Any, Any}"><a class="docstring-binding" href="#Molly.radius_gyration-Tuple{Any, Any}"><code>Molly.radius_gyration</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">radius_gyration(coords, atoms)</code></pre><p>Calculate the radius of gyration of a set of coordinates.</p><p>Assumes the coordinates do not cross the bounding box, i.e. all coordinates correspond to the same periodic image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/analysis.jl#L90-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.random_coord-Union{Tuple{CubicBoundary{3, T}}, Tuple{T}} where T"><a class="docstring-binding" href="#Molly.random_coord-Union{Tuple{CubicBoundary{3, T}}, Tuple{T}} where T"><code>Molly.random_coord</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">random_coord(boundary; rng=Random.default_rng())</code></pre><p>Generate a random coordinate uniformly distributed within a bounding box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L480-L484">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.random_normal_translation!-Union{Tuple{System{D, &lt;:Any, T}}, Tuple{T}, Tuple{D}} where {D, T}"><a class="docstring-binding" href="#Molly.random_normal_translation!-Union{Tuple{System{D, &lt;:Any, T}}, Tuple{T}, Tuple{D}} where {D, T}"><code>Molly.random_normal_translation!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">random_normal_translation!(sys::System; shift_size=oneunit(eltype(eltype(sys.coords))),
                           rng=Random.default_rng())</code></pre><p>Performs a random translation of the coordinates of a randomly selected atom in a <a href="#Molly.System"><code>System</code></a>.</p><p>The translation is generated using a uniformly chosen direction and length selected from the standard normal distribution i.e. with mean 0 and standard deviation 1, scaled by <code>shift_size</code> which should have appropriate length units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L1122-L1131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.random_uniform_translation!-Union{Tuple{System{D, &lt;:Any, T}}, Tuple{T}, Tuple{D}} where {D, T}"><a class="docstring-binding" href="#Molly.random_uniform_translation!-Union{Tuple{System{D, &lt;:Any, T}}, Tuple{T}, Tuple{D}} where {D, T}"><code>Molly.random_uniform_translation!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">random_uniform_translation!(sys::System; shift_size=oneunit(eltype(eltype(sys.coords))),
                            rng=Random.default_rng())</code></pre><p>Performs a random translation of the coordinates of a randomly selected atom in a <a href="#Molly.System"><code>System</code></a>.</p><p>The translation is generated using a uniformly selected direction and uniformly selected length in range [0, 1) scaled by <code>shift_size</code> which should have appropriate length units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L1103-L1111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.random_velocities!-Tuple{Any, Any}"><a class="docstring-binding" href="#Molly.random_velocities!-Tuple{Any, Any}"><code>Molly.random_velocities!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">random_velocities!(sys, temp; rng=Random.default_rng())
random_velocities!(vels, sys, temp; rng=Random.default_rng())</code></pre><p>Set the velocities of a <a href="#Molly.System"><code>System</code></a>, or a vector, to random velocities generated from the Maxwell-Boltzmann distribution.</p><p>Virtual sites are given a velocity of zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L843-L851">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.random_velocities-Union{Tuple{AT}, Tuple{System{3, AT}, Any}} where AT"><a class="docstring-binding" href="#Molly.random_velocities-Union{Tuple{AT}, Tuple{System{3, AT}, Any}} where AT"><code>Molly.random_velocities</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">random_velocities(sys, temp; rng=Random.default_rng())</code></pre><p>Generate random velocities from the Maxwell-Boltzmann distribution for a <a href="#Molly.System"><code>System</code></a>.</p><p>Virtual sites are given a velocity of zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L823-L830">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.random_velocity-Tuple{Union{Level{L, S, Quantity{T, ùêå, U}} where {T, U, L, S}, Level{L, S, Quantity{T, ùêå ùêç^-1, U}} where {T, U, L, S}, Quantity{T, ùêå} where T, Quantity{T, ùêå ùêç^-1} where T}, Union{Quantity{T, ùöØ, U}, Level{L, S, Quantity{T, ùöØ, U}} where {L, S}} where {T, U}}"><a class="docstring-binding" href="#Molly.random_velocity-Tuple{Union{Level{L, S, Quantity{T, ùêå, U}} where {T, U, L, S}, Level{L, S, Quantity{T, ùêå ùêç^-1, U}} where {T, U, L, S}, Quantity{T, ùêå} where T, Quantity{T, ùêå ùêç^-1} where T}, Union{Quantity{T, ùöØ, U}, Level{L, S, Quantity{T, ùöØ, U}} where {L, S}} where {T, U}}"><code>Molly.random_velocity</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">random_velocity(atom_mass::Union{Unitful.Mass, MolarMass}, temp::Unitful.Temperature;
                dims=3, rng=Random.default_rng())
random_velocity(atom_mass::Union{Unitful.Mass, MolarMass}, temp::Unitful.Temperature,
                k::Union{BoltzmannConstUnits, MolarBoltzmannConstUnits};
                dims=3, rng=Random.default_rng())
random_velocity(atom_mass::Real, temp::Real, k::Real=ustrip(u&quot;u * nm^2 * ps^-2 * K^-1&quot;, Unitful.k);
                dims=3, rng=Random.default_rng())</code></pre><p>Generate a random velocity from the Maxwell-Boltzmann distribution, with optional custom Boltzmann constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L696-L707">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.rdf"><a class="docstring-binding" href="#Molly.rdf"><code>Molly.rdf</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rdf(coords, boundary; npoints=200)</code></pre><p>Calculate the radial distribution function of a set of coordinates.</p><p>This function is only available when KernelDensity is imported. This describes how density varies as a function of distance from each atom. Returns a list of distance bin centers and a list of the corresponding densities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/analysis.jl#L169-L178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.read_frame!-Union{Tuple{T}, Tuple{AT}, Tuple{D}, Tuple{EnsembleSystem{&lt;:System{D, AT, T}}, Integer}} where {D, AT, T}"><a class="docstring-binding" href="#Molly.read_frame!-Union{Tuple{T}, Tuple{AT}, Tuple{D}, Tuple{EnsembleSystem{&lt;:System{D, AT, T}}, Integer}} where {D, AT, T}"><code>Molly.read_frame!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_frame!(ens_sys::EnsembleSystem, frame_idx::Integer)</code></pre><p>Read a frame from an <a href="#Molly.EnsembleSystem"><code>EnsembleSystem</code></a> and return a <a href="#Molly.System"><code>System</code></a> representing the frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/trajectory.jl#L33-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.remd_exchange!-Tuple{ReplicaSystem, TemperatureREMD, Integer, Integer}"><a class="docstring-binding" href="#Molly.remd_exchange!-Tuple{ReplicaSystem, TemperatureREMD, Integer, Integer}"><code>Molly.remd_exchange!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">remd_exchange!(sys, sim, n, m; n_threads=Threads.nthreads(), rng=Random.default_rng())</code></pre><p>Attempt an exchange of replicas <code>n</code> and <code>m</code> in a <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a> during a REMD simulation.</p><p>Successful exchanges should exchange coordinates and velocities as appropriate. Returns acceptance quantity <code>Œî</code> and a <code>Bool</code> indicating whether the exchange was successful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L840-L847">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.remove_CM_motion!-Tuple{Any}"><a class="docstring-binding" href="#Molly.remove_CM_motion!-Tuple{Any}"><code>Molly.remove_CM_motion!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">remove_CM_motion!(system)</code></pre><p>Remove the center of mass motion from a <a href="#Molly.System"><code>System</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L911-L915">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.rmsd-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{SVector{D, T}}, AbstractArray{SVector{D, T}}}} where {D, T}"><a class="docstring-binding" href="#Molly.rmsd-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{SVector{D, T}}, AbstractArray{SVector{D, T}}}} where {D, T}"><code>Molly.rmsd</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rmsd(coords_1, coords_2)</code></pre><p>Calculate the root-mean-square deviation (RMSD) of two sets of 3D coordinates after superimposition by the Kabsch algorithm.</p><p>Assumes the coordinates do not cross the bounding box, i.e. all coordinates in each set correspond to the same periodic image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/analysis.jl#L73-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.scalar_pressure-Tuple{Any}"><a class="docstring-binding" href="#Molly.scalar_pressure-Tuple{Any}"><code>Molly.scalar_pressure</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scalar_pressure(system, neighbors=find_neighbors(system), step_n=0, buffers=nothing;
                recompute=true, n_threads=Threads.nthreads())</code></pre><p>Calculate the pressure of the system as a scalar.</p><p>This is the trace of the <a href="#Molly.pressure-Tuple{Any}"><code>pressure</code></a> tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L997-L1004">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.scalar_virial-Tuple{Any}"><a class="docstring-binding" href="#Molly.scalar_virial-Tuple{Any}"><code>Molly.scalar_virial</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scalar_virial(system, neighbors=find_neighbors(system), step_n=0;
              n_threads=Threads.nthreads())</code></pre><p>Calculate the virial of the system as a scalar.</p><p>This is the trace of the <a href="#Molly.virial-Tuple{Any}"><code>virial</code></a> tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/energy.jl#L107-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.scale_boundary-Tuple{CubicBoundary, Any}"><a class="docstring-binding" href="#Molly.scale_boundary-Tuple{CubicBoundary, Any}"><code>Molly.scale_boundary</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scale_boundary(boundary, scale_factor)</code></pre><p>Scale the sides of a bounding box by a scaling factor.</p><p>The scaling factor can be a single number or a <code>SVector</code> of the appropriate number of dimensions corresponding to the scaling factor for each axis. For a 3D bounding box the volume scales as the cube of the scaling factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L423-L431">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.scale_coords!-Union{Tuple{D}, Tuple{AT}, Tuple{System{&lt;:Any, AT}, SMatrix{D, D}}} where {AT, D}"><a class="docstring-binding" href="#Molly.scale_coords!-Union{Tuple{D}, Tuple{AT}, Tuple{System{&lt;:Any, AT}, SMatrix{D, D}}} where {AT, D}"><code>Molly.scale_coords!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scale_coords!(sys::System{&lt;:Any, AT}, Œº::SMatrix{D,D};
              rotate::Bool=true,
              ignore_molecules::Bool=false,
              scale_velocities::Bool=false)</code></pre><p>Rigid-molecular barostat update with optional rotation.</p><ul><li>Box:        B‚Ä≤ = Œº * B</li><li>Positions:  r‚Ä≤ = Œº * r  (implemented via COM affine + optional rotation of internal offsets)</li><li>Velocities: v‚Ä≤ = Œº‚Åª¬π * v  (applied when <code>scale_velocities=true</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L1137-L1148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.simulate!-Tuple{Any, SteepestDescentMinimizer}"><a class="docstring-binding" href="#Molly.simulate!-Tuple{Any, SteepestDescentMinimizer}"><code>Molly.simulate!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate!(system, simulator, n_steps; &lt;keyword arguments&gt;)
simulate!(system, simulator; &lt;keyword arguments&gt;)</code></pre><p>Run a simulation on a system according to the rules of the given simulator.</p><p>Custom simulators should implement this function. Constraints are applied during minimization, which can lead to issues.</p><p><strong>Arguments</strong></p><ul><li><code>n_threads=Threads.nthreads()</code>: the number of threads to run the simulation on, only   relevant when running on CPU.</li><li><code>run_loggers</code>: whether to run the loggers during the simulation. Can be <code>true</code>, <code>false</code>   or <code>:skipzero</code>, in which case the loggers are not run before the first step. <code>run_loggers</code>   is <code>true</code> by default except for <a href="#Molly.SteepestDescentMinimizer"><code>SteepestDescentMinimizer</code></a>, where it is <code>false</code>.</li><li><code>rng=Random.default_rng()</code>: the random number generator used for the simulation. Setting   this allows reproducible stochastic simulations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L48-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.simulate_remd!-Tuple{ReplicaSystem, Any, Integer}"><a class="docstring-binding" href="#Molly.simulate_remd!-Tuple{ReplicaSystem, Any, Integer}"><code>Molly.simulate_remd!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate_remd!(sys, remd_sim, n_steps; n_threads=Threads.nthreads(),
               run_loggers=true, rng=Random.default_rng())</code></pre><p>Run a REMD simulation on a <a href="#Molly.ReplicaSystem"><code>ReplicaSystem</code></a> using a REMD simulator.</p><p>Not currently compatible with interactions that depend on step number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/simulators.jl#L972-L979">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.statistical_inefficiency-Tuple{AbstractVector}"><a class="docstring-binding" href="#Molly.statistical_inefficiency-Tuple{AbstractVector}"><code>Molly.statistical_inefficiency</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">statistical_inefficiency(series::AbstractVector; maxlag::Union{Nothing, Int}=nothing)</code></pre><p>Integrated autocorrelation time estimator with IPS truncation and finite-sample taper.</p><p>Returns a <code>StatisticalInefficiency</code> struct with:</p><ul><li>inefficiency: statistical inefficiency</li><li>stride: ceil(Int, g)</li><li>input_length: input length</li><li>effective_size: floor(N / stride)</li><li>lag: truncation lag used</li></ul><p>Notes:</p><ul><li>Uses initial positive sequence (IPS) on paired lags to choose L.</li><li>Uses normalized ACF of the mean-removed series.</li><li>Includes the (1 - œÑ/N) taper in the sum.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/free_energy/stats.jl#L13-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.temperature-Union{Tuple{System{D}}, Tuple{D}} where D"><a class="docstring-binding" href="#Molly.temperature-Union{Tuple{System{D}}, Tuple{D}} where D"><code>Molly.temperature</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">temperature(system; kin_tensor=nothing, recompute=true)</code></pre><p>Calculate the temperature of a system from the kinetic energy of the atoms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/energy.jl#L124-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.torsion_angle-NTuple{5, Any}"><a class="docstring-binding" href="#Molly.torsion_angle-NTuple{5, Any}"><code>Molly.torsion_angle</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">torsion_angle(coord_i, coord_j, coord_k, coord_l, boundary)
torsion_angle(vec_ij, vec_jk, vec_kl)</code></pre><p>Calculate the torsion angle in radians defined by four coordinates or three vectors.</p><p>The angle between the planes defined by atoms (i, j, k) and (j, k, l) is returned in the range -œÄ to œÄ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L884-L893">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.total_energy-Tuple{Any}"><a class="docstring-binding" href="#Molly.total_energy-Tuple{Any}"><code>Molly.total_energy</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">total_energy(system, neighbors=find_neighbors(sys); n_threads=Threads.nthreads())</code></pre><p>Calculate the total energy of a system as the sum of the <a href="#Molly.kinetic_energy-Tuple{Any}"><code>kinetic_energy</code></a> and the <a href="#Molly.potential_energy-Tuple{Any}"><code>potential_energy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/energy.jl#L13-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.use_neighbors-Tuple{Any}"><a class="docstring-binding" href="#Molly.use_neighbors-Tuple{Any}"><code>Molly.use_neighbors</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">use_neighbors(inter)</code></pre><p>Whether a pairwise interaction uses the neighbor list, default <code>false</code>.</p><p>Custom pairwise interactions can define a method for this function. For built-in interactions such as <a href="#Molly.LennardJones"><code>LennardJones</code></a> this function accesses the <code>use_neighbors</code> field of the struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/neighbors.jl#L12-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.ustrip_vec-Tuple"><a class="docstring-binding" href="#Molly.ustrip_vec-Tuple"><code>Molly.ustrip_vec</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ustrip_vec(x)
ustrip_vec(u, x)</code></pre><p>Broadcasted form of <code>ustrip</code> from Unitful.jl, allowing e.g. <code>ustrip_vec.(coords)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/units.jl#L10-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.vector-Tuple{Any, Any, CubicBoundary}"><a class="docstring-binding" href="#Molly.vector-Tuple{Any, Any, CubicBoundary}"><code>Molly.vector</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vector(c1, c2, boundary)</code></pre><p>Displacement between two coordinate values from c1 to c2, accounting for periodic boundary conditions.</p><p>The minimum image convention is used, so the displacement is to the closest version of the coordinates accounting for the periodic boundaries. For the <a href="#Molly.TriclinicBoundary"><code>TriclinicBoundary</code></a> an approximation is used to find the closest version by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L517-L527">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.vector_1D-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Molly.vector_1D-Tuple{Any, Any, Any}"><code>Molly.vector_1D</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vector_1D(c1, c2, side_length)</code></pre><p>Displacement between two 1D coordinate values from c1 to c2, accounting for periodic boundary conditions in a <a href="#Molly.CubicBoundary"><code>CubicBoundary</code></a> or <a href="#Molly.RectangularBoundary"><code>RectangularBoundary</code></a>.</p><p>The minimum image convention is used, so the displacement is to the closest version of the coordinate accounting for the periodic boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L497-L505">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.virial-Tuple{Any}"><a class="docstring-binding" href="#Molly.virial-Tuple{Any}"><code>Molly.virial</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">virial(system, neighbors=find_neighbors(system), step_n=0;
       n_threads=Threads.nthreads())</code></pre><p>Calculate the virial tensor of the system.</p><p>The virial, in its most general form, is defined as:</p><p class="math-container">\[\bf{W} = \sum_i \bf{r_i} \otimes \bf{f_i}\]</p><p>where <span>$\bf{r_i}$</span> and <span>$\bf{f_i}$</span> are the position and force vectors, respectively, acting on atom <span>$i$</span>. The <a href="https://docs.lammps.org/compute_stress_atom.html">virial definition from LAMMPS</a> is used, taking into account pairwise interactions, specific interactions, and the <a href="#Molly.Ewald"><code>Ewald</code></a> and <a href="#Molly.PME"><code>PME</code></a> methods computed as indicated in <a href="https://doi.org/10.1063/1.470117">Essmann et al. 1995</a>. Contributions from constraints, implicit solvent methods and bias potentials are ignored. Compatible with virtual sites apart from <a href="#Molly.OutOfPlaneSite-Union{Tuple{T}, Tuple{Integer, Integer, Integer, Integer, T, T, Any}} where T"><code>OutOfPlaneSite</code></a>.</p><p>To calculate the scalar virial, see <a href="#Molly.scalar_virial-Tuple{Any}"><code>scalar_virial</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/energy.jl#L77-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.visualize"><a class="docstring-binding" href="#Molly.visualize"><code>Molly.visualize</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">visualize(coord_logger, boundary, out_filepath; &lt;keyword arguments&gt;)</code></pre><p>Visualize a simulation as an animation.</p><p>This function is only available when GLMakie is imported. It can take a while to run, depending on the length of the simulation and the number of atoms.</p><p><strong>Arguments</strong></p><ul><li><code>connections=Tuple{Int, Int}[]</code>: pairs of atoms indices to link with bonds.</li><li><code>connection_frames</code>: the frames in which bonds are shown. Should be a list of   the same length as the number of frames, where each item is a list of   <code>Bool</code>s of the same length as <code>connections</code>. Defaults to always <code>true</code>.</li><li><code>trails::Integer=0</code>: the number of preceding frames to show as transparent   trails.</li><li><code>framerate::Integer=30</code>: the frame rate of the animation.</li><li><code>color=:purple</code>: the color of the atoms. Can be a single color or a list of   colors of the same length as the number of atoms.</li><li><code>connection_color=:orange</code>: the color of the bonds. Can be a single color or a   list of colors of the same length as <code>connections</code>.</li><li><code>markersize=0.05</code>: the size of the atom markers, in the units of the data.</li><li><code>linewidth=2.0</code>: the width of the bond lines.</li><li><code>transparency=true</code>: whether transparency is active on the plot.</li><li><code>show_boundary::Bool=true</code>: whether to show the bounding box as lines.</li><li><code>boundary_linewidth=2.0</code>: the width of the boundary lines.</li><li><code>boundary_color=:black</code>: the color of the boundary lines.</li><li><code>kwargs...</code>: other keyword arguments are passed to the point plotting   function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/analysis.jl#L137-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.volume-Tuple{Any}"><a class="docstring-binding" href="#Molly.volume-Tuple{Any}"><code>Molly.volume</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">volume(sys)
volume(boundary)</code></pre><p>Calculate the volume (3D) or area (2D) of a <a href="#Molly.System"><code>System</code></a> or bounding box.</p><p>Returns infinite volume for infinite boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L377-L384">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.wrap_coord_1D-Tuple{Any, Any}"><a class="docstring-binding" href="#Molly.wrap_coord_1D-Tuple{Any, Any}"><code>Molly.wrap_coord_1D</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">wrap_coord_1D(c, side_length)</code></pre><p>Ensure a 1D coordinate is within the bounding box and return the coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L583-L587">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.wrap_coords-Tuple{Any, Union{CubicBoundary, RectangularBoundary}}"><a class="docstring-binding" href="#Molly.wrap_coords-Tuple{Any, Union{CubicBoundary, RectangularBoundary}}"><code>Molly.wrap_coords</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">wrap_coords(c, boundary)</code></pre><p>Ensure a coordinate is within the bounding box and return the coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/spatial.jl#L596-L600">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Molly.write_structure-Tuple{Any, Any}"><a class="docstring-binding" href="#Molly.write_structure-Tuple{Any, Any}"><code>Molly.write_structure</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_structure(filepath, sys; format=&quot;&quot;, correction=:pbc, atom_inds=[],
                excluded_res=String[], write_velocities=false, write_boundary=true)</code></pre><p>Write the 3D structure of a system to a file.</p><p>Uses Chemfiles.jl to write to one of a variety of formats including DCD, XTC, PDB, CIF, MOL2, SDF, TRR and XYZ. The full list of file formats can be found in the <a href="https://chemfiles.org/chemfiles/latest/formats.html#list-of-supported-formats">Chemfiles docs</a>. By default the format is guessed from the file extension but it can also be given as a string, e.g. <code>format=&quot;DCD&quot;</code>. BioStructures.jl is used to write to the PDB format.</p><p>The atom indices to be written can be given as a list or range to <code>atom_inds</code>, with all atoms being written by default. Residue names to be excluded can be given as <code>excluded_res</code>. Velocities can be written in addition to coordinates by setting <code>write_velocities=true</code>. Chemfiles does not support writing velocities to all file formats. The correction to be applied to the molecules is chosen with <code>correction</code>. <code>:pbc</code>, the default, keeps molecules whole, whereas <code>:wrap</code> wraps all atoms inside the simulation box regardless of connectivity.</p><p>The <a href="#Molly.System"><code>System</code></a> should have <code>atoms_data</code> defined, and <code>topology</code> if bonding information is required. The file will be overwritten if it already exists.</p><p>Not compatible with 2D systems. The CRYST1 record is not written for infinite boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/Molly.jl/blob/388d2f07f9a2f7f49aa073be206c1e59cb4b52a5/src/loggers.jl#L596-L626">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../developer/">¬´ Developer documentation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 17 February 2026 11:48">Tuesday 17 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
